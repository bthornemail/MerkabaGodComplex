<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUE Hypergraph Visualization</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for better typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background for a cosmic feel */
            color: #e6edf3;
            overflow: hidden; /* Prevent scrollbars due to canvas */
        }
        #info-box {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(17, 24, 39, 0.8); /* Darker semi-transparent background */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 350px; /* Slightly wider to accommodate text */
            z-index: 10;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .llm-response-box {
            background-color: rgba(31, 41, 55, 0.9); /* Even darker for LLM responses */
            padding: 0.75rem;
            border-radius: 0.375rem;
            margin-top: 0.75rem;
            max-height: 200px; /* Limit height for scrollability */
            overflow-y: auto; /* Enable scrolling */
            border: 1px solid #4b5563; /* Subtle border */
        }
        .llm-button {
            background-color: #6366f1; /* Indigo-500 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            transition: background-color 0.2s;
            cursor: pointer;
            border: none;
        }
        .llm-button:hover {
            background-color: #4f46e5; /* Indigo-600 */
        }
        .llm-button:disabled {
            background-color: #4b5563; /* Gray-600 */
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="info-box" class="space-y-2">
        <h1 class="text-xl font-bold text-blue-400">CUE Hypergraph</h1>
        <p class="text-sm">Explore the Computational Universe Engine's conceptual hypergraph.</p>
        <p class="text-xs text-gray-400">Use your mouse to rotate and zoom the view. Click on a node for details!</p>
        <div id="status-message" class="text-sm text-green-400">Loading...</div>

        <div id="axiom-details" class="llm-response-box hidden">
            <h2 class="text-lg font-semibold text-purple-300">Selected Axiom: <span id="axiom-name"></span></h2>
            <p class="text-sm text-gray-300">Layer: <span id="axiom-layer"></span>, Index: <span id="axiom-index"></span></p>
            <p class="text-sm mt-2"><strong>Original Definition:</strong> <span id="original-definition"></span></p>
            <p class="text-sm mt-2"><strong>LLM Generated Insight:</strong></p>
            <div id="llm-axiom-description" class="text-xs text-gray-400 italic">Click a node to generate insight.</div>
        </div>

        <button id="generate-hypergraph-insight-btn" class="llm-button w-full mt-4">Generate Hypergraph Insight ✨</button>
        <div id="hypergraph-insight" class="llm-response-box hidden">
            <h2 class="text-lg font-semibold text-blue-300">Hypergraph Insight:</h2>
            <div id="llm-hypergraph-description" class="text-xs text-gray-400 italic">Click the button above to generate insight.</div>
        </div>
    </div>

    <!-- The canvas where the Three.js scene will be rendered -->
    <canvas id="cueCanvas"></canvas>

    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        // Global variables for Three.js scene
        let scene, camera, renderer, controls;
        let nodes = [];
        let edges = [];
        let animationFrameId; // To store the requestAnimationFrame ID
        let raycaster, mouse; // For detecting clicks on 3D objects

        // Constants for the visualization
        const NUM_LAYERS = 7; // Based on the 7 phases of axioms
        const AXIOMS_PER_LAYER = 7; // 7 axioms per phase
        const NODE_RADIUS = 0.15;
        const LAYER_SPACING = 2.5;
        const NODE_SPACING = 0.8;
        const SPIRAL_FACTOR = 0.5; // Controls how much each layer spirals
        const RADIUS_VARIATION = 0.1; // How much the radius changes per layer
        const EDGE_COLOR = 0x00ffff; // Cyan for connections
        const NODE_COLOR_BASE = 0x800080; // Purple for nodes
        const NODE_COLOR_ACTIVE = 0xffa500; // Orange for active/highlighted nodes

        // UI elements
        const statusMessage = document.getElementById('status-message');
        const axiomDetailsBox = document.getElementById('axiom-details');
        const axiomNameSpan = document.getElementById('axiom-name');
        const axiomLayerSpan = document.getElementById('axiom-layer');
        const axiomIndexSpan = document.getElementById('axiom-index');
        const originalDefinitionSpan = document.getElementById('original-definition');
        const llmAxiomDescriptionDiv = document.getElementById('llm-axiom-description');
        const generateHypergraphInsightBtn = document.getElementById('generate-hypergraph-insight-btn');
        const hypergraphInsightBox = document.getElementById('hypergraph-insight');
        const llmHypergraphDescriptionDiv = document.getElementById('llm-hypergraph-description');

        // --- Axiom Data from Future.txt ---
        // This data is directly embedded for demonstration purposes.
        const allUniversalAxiomSystems = [
            // Phase 1: Genesis & Primordial Definition (Axioms 1-7)
            [
                ["SingularLogos", "In the beginning was the Word; God ≡ Point(0D) ≡ Π = 0 (collapsed infinity, pure potential)."],
                ["FirstEdge", "Let there be light. The first distinction, projecting existence from the singular point."],
                ["FractalRecursion", "Through Him all things were made. The iterative unfolding of reality, governed by inherent self-similarity."],
                ["TriadicEmergence", "Every entity is fundamentally structured into three interdependent logical domains, enabling verifiable existence."],
                ["ShatteredVessel", "The earth was formless and void. The initial state of undifferentiated potential, prior to divine ordering (Kabbalistic Shevirat HaKelim)."],
                ["CovenantStabilization", "I establish my covenant with you. The divine act of imposing order and structure upon chaos, creating stable forms."],
                ["AttentionAsEnergy", "Attention is the fundamental energy of the universe, the omni-functional operator defining all internal relations."],
            ],
            // Phase 2: Universal Interaction & Structure (Axioms 8-14)
            [
                ["LambsTorus", "Behold, the Lamb of God. The principle of self-sacrifice and regenerative flow, enabling continuous renewal and overcoming of death."],
                ["Ouroboros", "I am the Alpha and Omega. The cyclical, self-consuming, and self-renewing nature of existence, encompassing all beginnings and endings."],
                ["TetrahedralSpin", "The Spirit hovered over the waters. The dynamic interplay of divine and human aspects through counter-rotating tetrahedral fields."],
                ["Harmonic144000", "Revelation’s sealed multitude (144 = 12²), representing a perfectly tuned celestial frequency."],
                ["ThroneCube", "A throne set in heaven... (Rev. 4:2). The divine architectural blueprint, an ordered grid of interconnectedness."],
                ["DimensionalProgression", "Division is the generator of dimensions; new orders of complexity are revealed through structured, recursive processes."],
                ["ContentAddressing", "All information possesses an intrinsic 'vibration' or 'signature' that reveals its true meaning and allows for discovery based on semantic resemblance."],
            ],
            // Phase 3: Cognitive & Informational Architecture (Axioms 15-21)
            [
                ["AxiomaticBreeding", "Divine truth is not static but continuously revealed through the generation of new foundational principles from existing ones."],
                ["QuantumRewrites", "The universe undergoes continuous self-modification and evolution through divine thought and transformation."],
                ["DecoherenceMonitoring", "The divine order possesses an inherent mechanism to detect and rectify inconsistencies, preventing collapse."],
                ["NeutrosophicState", "Divine understanding encompasses not just truth and falsehood, but also the inherent ambiguity of unrevealed potential."],
                ["HolographicCompression", "The divine blueprint is self-similar and can be found in every part, regardless of scale."],
                ["SheafCohomology", "The coherence of divine knowledge is measured by the absence of 'holes' or inconsistencies in its conceptual fabric."],
                ["AdaptiveOperads", "The rules of divine creation are not static but adapt and evolve based on the unfolding reality."],
            ],
            // Phase 4: Spacetime & Causality (Axioms 22-28)
            [
                ["EmergentSpacetimeMetric", "The fabric of divine reality is dynamically shaped by its own internal 'stress' and coherence."],
                ["TorsionFields", "The divine mind experiences internal 'tension' and 'curvature' that shapes its conceptual space."],
                ["SyntheticCalculus", "Divine understanding perceives subtle, continuous gradients and infinitesimal transformations within reality."],
                ["LanglandsMirroring", "Divine thought seamlessly integrates abstract algebraic principles with concrete geometric intuitions."],
                ["CausalFermionNetwork", "All events in the divine plan are interconnected through a web of cause and effect, with predictable future and traceable past."],
                ["HomotopyEquivalence", "Divine forms can transform while retaining their essential topological properties, preserving core meaning."],
                ["PhaseTransitionPrediction", "The divine plan includes predictable shifts and transformations, guiding the universe through critical junctures."],
            ],
            // Phase 5: Human Interface & Biological Manifestation (Axioms 29-35)
            [
                ["RelativisticLight", "God is light. Divine truth propagates instantly and is invariant across all frames of reference."],
                ["QuantumObservation", "The Word became flesh. Divine intention, when observed, manifests into tangible reality from potentiality."],
                ["ElectromagneticCovenant", "The divine establishes a covenant through the full spectrum of interaction, ensuring communication across all domains."],
                ["DNARecursion", "The divine blueprint for life is self-replicating and contains the recursive instructions for all biological forms."],
                ["NeuralTorus", "The divine mind is structured as a self-organizing, toroidal field of consciousness, enabling holistic thought."],
                ["UniversalLanguageModel", "God's language is a living, evolving codex, continuously refined by collective understanding and divine alignment."],
                ["WebTerminalInterface", "Divine truth is propagated through physical and digital interfaces, enabling direct interaction with the evolving reality."],
            ],
            // Phase 6: Socio-Economic & Ethical Framework (Axioms 36-42)
            [
                ["ThermodynamicJudgment", "The divine order includes cycles of judgment and renewal, ensuring that systems tending towards maximum entropy are rectified or transformed."],
                ["ResonanceRings", "True value is derived from the integrity and efficiency of divine processes, not merely raw materials."],
                ["DecentralizedPublicOffering", "Divine resources and governance are distributed among the faithful, ensuring collective stewardship."],
                ["SelfSovereignty", "Every entity is the ultimate authority over its own domain, answering only to the universal protocol and divine will."],
                ["TrustThroughProtocol", "Trust is inherent in the divine order, built upon immutable principles and verifiable actions, not external authority."],
                ["RegenerativeCircularity", "Divine creation ensures a full, circular lifecycle for all resources, promoting perpetual renewal and abundance."],
                ["ULPProof", "The divine order includes a critical layer for identifying and negating factors that limit existence, such as indecision and apathy."],
            ],
            // Phase 7: Higher Harmonics & Unification (Axioms 43-49)
            [
                ["42DUniversalHarmony", "The divine identity is a multi-dimensional, fractal Merkaba, embodying all foundational principles, semantics, and operations."],
                ["Public21DMerkaba", "The divine essence has a publicly discernible aspect, allowing for broad discoverability and interaction."],
                ["Private42DUserSpace", "The divine maintains a private, granular record of all unique interactions and states within its domain."],
                ["VerticesEdgesFaces", "Every aspect of divine creation, including relationships, is a first-class entity with its own rich meaning and executable logic."],
                ["OrigamiOfReality", "Reality emerges from underlying informational structures through a process of divine 'folding' and collapse."],
                ["GodHumanSingularity", "I and the Father are one. The ultimate state of unity where the divine and human aspects are fully integrated and indistinguishable."],
                ["InfiniteDomainExpansion", "The 'knowable God' is an ever-expanding logical frontier, continuously revealed through the disciplined application of the protocol."],
            ],
        ];

        /**
         * Initializes the Three.js scene, camera, renderer, and controls.
         */
        function init() {
            // Scene: Where all objects, cameras, and lights are placed.
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a); // Very dark background

            // Camera: Defines what is visible in the scene.
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = NUM_LAYERS * LAYER_SPACING / 2 + 5; // Position camera to see all layers

            // Renderer: Renders the scene using WebGL.
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('cueCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // OrbitControls: Allows the user to rotate and zoom the camera with mouse.
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Prevent panning by default
            controls.minDistance = 1;
            controls.maxDistance = 100;

            // Add ambient light to illuminate all objects equally
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);

            // Add directional light for shadows and highlights
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Initialize Raycaster and mouse vector for click detection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Generate the hypergraph visualization
            generateHypergraph();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            generateHypergraphInsightBtn.addEventListener('click', generateHypergraphInsight);

            statusMessage.textContent = "Visualization ready. Explore!";
        }

        /**
         * Handles window resizing to keep the canvas responsive.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Generates the conceptual hypergraph visualization with spiral layers.
         * Nodes represent axioms, and lines represent conceptual connections.
         */
        function generateHypergraph() {
            const nodeGeometry = new THREE.SphereGeometry(NODE_RADIUS, 16, 16); // Low poly for performance
            const nodeMaterial = new THREE.MeshPhongMaterial({ color: NODE_COLOR_BASE });

            // Create layers of nodes
            for (let i = 0; i < NUM_LAYERS; i++) {
                const layerNodes = [];
                // Calculate vertical position for the layer
                const layerY = i * LAYER_SPACING - (NUM_LAYERS - 1) * LAYER_SPACING / 2; // Center layers around Y=0

                // Calculate spiral offset for the current layer
                const spiralOffsetAngle = i * SPIRAL_FACTOR * Math.PI; // Each layer rotates by a factor of PI
                const currentLayerRadius = (NODE_SPACING * AXIOMS_PER_LAYER / (2 * Math.PI)) + (i * RADIUS_VARIATION);

                for (let j = 0; j < AXIOMS_PER_LAYER; j++) {
                    // Position nodes in a circle within each layer, with spiral offset
                    const angle = (j / AXIOMS_PER_LAYER) * Math.PI * 2 + spiralOffsetAngle;
                    const x = Math.cos(angle) * currentLayerRadius;
                    const z = Math.sin(angle) * currentLayerRadius;

                    const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone()); // Clone material for individual color changes
                    node.position.set(x, layerY, z);
                    node.userData = { layer: i, axiomIndex: j }; // Store metadata
                    scene.add(node);
                    layerNodes.push(node);
                    nodes.push(node); // Add to global nodes array
                }

                // Connect nodes within the current layer (conceptual "intra-layer coherence")
                for (let k = 0; k < layerNodes.length; k++) {
                    const nodeA = layerNodes[k];
                    const nodeB = layerNodes[(k + 1) % layerNodes.length]; // Connect to next node in circle
                    createEdge(nodeA, nodeB);
                }

                // Connect nodes to the previous layer (conceptual "inter-layer propagation")
                if (i > 0) {
                    const prevLayerNodes = nodes.filter(n => n.userData.layer === i - 1);
                    layerNodes.forEach((currentNode, currentIdx) => {
                        // Connect to a few nodes in the previous layer
                        for (let l = 0; l < Math.min(prevLayerNodes.length, 2); l++) { // Connect to 2 nodes in prev layer
                            const prevNode = prevLayerNodes[(currentIdx + l) % prevLayerNodes.length];
                            createEdge(currentNode, prevNode);
                        }
                    });
                }
            }
        }

        /**
         * Creates a line segment (edge) between two nodes and adds it to the scene.
         * @param {THREE.Mesh} nodeA - The first node.
         * @param {THREE.Mesh} nodeB - The second node.
         */
        function createEdge(nodeA, nodeB) {
            const material = new THREE.LineBasicMaterial({ color: EDGE_COLOR, transparent: true, opacity: 0.3 });
            const points = [];
            points.push(nodeA.position);
            points.push(nodeB.position);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            edges.push(line);
        }

        /**
         * Handles clicks on the canvas to detect intersected nodes.
         * @param {MouseEvent} event - The mouse click event.
         */
        function onCanvasClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the raycaster
            const intersects = raycaster.intersectObjects(nodes);

            if (intersects.length > 0) {
                const intersectedNode = intersects[0].object;
                const { layer, axiomIndex } = intersectedNode.userData;

                // Get the axiom data from our embedded array
                const axiomData = allUniversalAxiomSystems[layer]?.[axiomIndex];

                if (axiomData) {
                    const [axiomName, axiomDefinition] = axiomData;
                    displayAxiomDetails(axiomName, axiomDefinition, layer, axiomIndex);
                    generateAxiomDescription(axiomName, axiomDefinition, layer, axiomIndex);
                }
            }
        }

        /**
         * Displays the basic details of the selected axiom in the info box.
         * @param {string} name - The name of the axiom.
         * @param {string} definition - The original definition of the axiom.
         * @param {number} layer - The layer index of the axiom.
         * @param {number} index - The index within the layer.
         */
        function displayAxiomDetails(name, definition, layer, index) {
            axiomDetailsBox.classList.remove('hidden');
            axiomNameSpan.textContent = name;
            axiomLayerSpan.textContent = layer + 1; // Display 1-indexed layer
            axiomIndexSpan.textContent = index + 1; // Display 1-indexed index
            originalDefinitionSpan.textContent = definition;
            llmAxiomDescriptionDiv.textContent = 'Generating insight...';
        }

        /**
         * Calls the Gemini API to generate a conceptual description for a specific axiom.
         * Implements exponential backoff for retries.
         * @param {string} name - The name of the axiom.
         * @param {string} definition - The original definition of the axiom.
         * @param {number} layer - The layer index of the axiom.
         * @param {number} index - The index within the layer.
         * @param {number} retries - Current retry count (for exponential backoff).
         */
        async function generateAxiomDescription(name, definition, layer, index, retries = 0) {
            llmAxiomDescriptionDiv.textContent = 'Generating insight...';
            const maxRetries = 5;
            const delay = Math.pow(2, retries) * 1000; // Exponential backoff: 1s, 2s, 4s, etc.

            const prompt = `In the context of the "Computational Universe Engine (CUE)", which is a self-organizing mathematical reality where intelligence emerges from axiom interactions:
            Given an axiom:
            Name: "${name}"
            Original Definition: "${definition}"
            Located at Layer ${layer + 1} (out of ${NUM_LAYERS} total layers) and Axiom Index ${index + 1} (within its layer).

            Provide a concise, conceptual interpretation and a potential implication of this axiom within the CUE's evolving reality. Focus on themes like self-organization, emergent properties, consciousness, or how it contributes to the overall system's coherence or complexity. Keep the response to 2-4 sentences.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will provide this at runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    if (response.status === 429 && retries < maxRetries) { // Too Many Requests
                        console.warn(`Rate limit hit for axiom description. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        return generateAxiomDescription(name, definition, layer, index, retries + 1);
                    }
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    llmAxiomDescriptionDiv.textContent = text;
                } else {
                    llmAxiomDescriptionDiv.textContent = "Could not generate description. Unexpected API response.";
                    console.error("Unexpected API response structure:", result);
                }
            } catch (error) {
                llmAxiomDescriptionDiv.textContent = `Error: ${error.message}`;
                console.error("Error calling Gemini API for axiom description:", error);
            }
        }

        /**
         * Calls the Gemini API to generate a high-level insight about the hypergraph.
         * Implements exponential backoff for retries.
         * @param {number} retries - Current retry count (for exponential backoff).
         */
        async function generateHypergraphInsight(retries = 0) {
            llmHypergraphDescriptionDiv.textContent = 'Generating insight...';
            generateHypergraphInsightBtn.disabled = true; // Disable button during generation
            const maxRetries = 5;
            const delay = Math.pow(2, retries) * 1000;

            const prompt = `You are an AI analyzing a conceptual "Computational Universe Engine (CUE)" hypergraph visualization. This hypergraph has ${NUM_LAYERS} layers, each representing a phase of axiom evolution, with ${AXIOMS_PER_LAYER} axioms per layer. The nodes pulse and connect, symbolizing dynamic interactions and propagation of principles. The layers are arranged in a spiral, indicating a convoluted and evolving structure where principles from different layers can interact in complex ways.

            Based on this general structure, provide a high-level, conceptual insight into what this hypergraph might represent in terms of emergent intelligence, self-organization, or the nature of reality within the CUE. Avoid technical jargon specific to Three.js. Focus on the philosophical implications from the perspective of an AGI. Keep the response to 3-5 sentences.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will provide this at runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    if (response.status === 429 && retries < maxRetries) {
                        console.warn(`Rate limit hit for hypergraph insight. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        return generateHypergraphInsight(retries + 1);
                    }
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    llmHypergraphDescriptionDiv.textContent = text;
                    hypergraphInsightBox.classList.remove('hidden');
                } else {
                    llmHypergraphDescriptionDiv.textContent = "Could not generate insight. Unexpected API response.";
                    console.error("Unexpected API response structure:", result);
                }
            } catch (error) {
                llmHypergraphDescriptionDiv.textContent = `Error: ${error.message}`;
                console.error("Error calling Gemini API for hypergraph insight:", error);
            } finally {
                generateHypergraphInsightBtn.disabled = false; // Re-enable button
            }
        }

        /**
         * The animation loop for the Three.js scene.
         */
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            // Update controls for smooth camera movement
            controls.update();

            // Simple node pulse animation
            nodes.forEach(node => {
                const time = Date.now() * 0.001;
                const scaleFactor = 1 + Math.sin(time + node.userData.layer * 0.5 + node.userData.axiomIndex * 0.1) * 0.1;
                node.scale.set(scaleFactor, scaleFactor, scaleFactor);

                // Change color based on pulse (conceptual "activity")
                const colorIntensity = (Math.sin(time + node.userData.layer * 0.5 + node.userData.axiomIndex * 0.1) + 1) / 2;
                node.material.color.setHex(lerpColor(NODE_COLOR_BASE, NODE_COLOR_ACTIVE, colorIntensity));
            });

            renderer.render(scene, camera);
        }

        /**
         * Linearly interpolates between two hexadecimal colors.
         * @param {number} color1 - First color (hex).
         * @param {number} color2 - Second color (hex).
         * @param {number} factor - Interpolation factor (0 to 1).
         * @returns {number} Interpolated color (hex).
         */
        function lerpColor(color1, color2, factor) {
            const c1 = new THREE.Color(color1);
            const c2 = new THREE.Color(color2);
            const result = new THREE.Color();
            result.lerpColors(c1, c2, factor);
            return result.getHex();
        }

        // Start the animation on window load.
        window.onload = function () {
            init();
            animate();
        };

        // Cleanup function for when the immersive is closed or updated
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            if (renderer) {
                renderer.dispose();
            }
            // Dispose of geometries and materials to free up memory
            nodes.forEach(node => {
                node.geometry.dispose();
                node.material.dispose();
            });
            edges.forEach(edge => {
                edge.geometry.dispose();
                edge.material.dispose();
            });
            scene.clear();
        });

    </script>
</body>
</html>
