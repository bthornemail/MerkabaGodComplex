<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Guide to the Universal Binary Hypergraph Protocol (UBHP)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Cosmic Sand -->
    <!-- Application Structure Plan: A multi-section, interactive dashboard design. It starts with high-level principles, flows into an interactive diagram of the core data process, then allows users to explore the hierarchical architecture layer by layer. A key feature is a simplified, visual simulation of the Geometric Consensus mechanism. This structure was chosen to deconstruct the dense, abstract report into a guided, interactive journey, prioritizing conceptual understanding and exploration over a linear text format. The flow is designed to build knowledge progressively, from the smallest data unit to the highest-level agent and consensus. -->
    <!-- Visualization & Content Choices: 
        - Core Principles: Goal: Inform. Method: Clickable summary cards. Interaction: JS toggle for details. Justification: Provides a high-level, scannable entry point.
        - Data Flow: Goal: Explain process. Method: Interactive diagram built with HTML/CSS. Interaction: User text input triggers JS functions to simulate `harmonize` and `typedArrayToRay`, updating UI with results. Justification: Makes the abstract data transformation tangible and engaging.
        - Architectural Layers: Goal: Organize. Method: Accordion-style cards for each Matrix. Interaction: JS toggle to show/hide details. Justification: Manages complexity by allowing progressive disclosure of information.
        - Geometric Consensus: Goal: Demystify. Method: Chart.js scatter plot. Interaction: Button click triggers JS to simulate peer states, calculate a centroid, and highlight the consensus cluster. Justification: Visually demonstrates the abstract concept of high-dimensional clustering, providing a 'wow' factor and aiding intuition.
        - Challenges: Goal: Inform. Method: Tabbed interface. Interaction: JS toggles between "Gap" and "Mitigation" content. Justification: Neatly organizes problem/solution pairs for easy comparison.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chart-container { position: relative; width: 100%; max-width: 600px; margin-left: auto; margin-right: auto; height: 350px; max-height: 400px; }
        @media (min-width: 768px) { .chart-container { height: 400px; } }
        .tab-active { border-color: #0284c7; color: #0284c7; }
        .tab-inactive { border-color: transparent; }
        .matrix-card.open .matrix-body { display: block; }
        .matrix-card.open .matrix-arrow { transform: rotate(180deg); }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <header class="bg-white shadow-sm sticky top-0 z-50">
        <nav class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <span class="text-xl font-bold text-sky-700">UBHP Explorer</span>
                </div>
                <div class="hidden md:block">
                    <div id="nav-links" class="ml-10 flex items-baseline space-x-4">
                        <a href="#principles" class="text-slate-600 hover:text-sky-700 px-3 py-2 rounded-md text-sm font-medium">Principles</a>
                        <a href="#data-flow" class="text-slate-600 hover:text-sky-700 px-3 py-2 rounded-md text-sm font-medium">Data Flow</a>
                        <a href="#architecture" class="text-slate-600 hover:text-sky-700 px-3 py-2 rounded-md text-sm font-medium">Architecture</a>
                        <a href="#consensus" class="text-slate-600 hover:text-sky-700 px-3 py-2 rounded-md text-sm font-medium">Consensus</a>
                        <a href="#challenges" class="text-slate-600 hover:text-sky-700 px-3 py-2 rounded-md text-sm font-medium">Challenges</a>
                    </div>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8 md:py-12">
        
        <section class="text-center mb-16">
            <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900 mb-4">The Universal Binary Hypergraph Protocol</h1>
            <p class="max-w-3xl mx-auto text-lg text-slate-600">An interactive guide to a framework for decentralized intelligence where all data is executable thought, organized by harmony and secured by geometry.</p>
        </section>

        <section id="principles" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2">Core Principles</h2>
            <p class="text-slate-600 text-center mb-10">UBHP is built on several foundational ideas that together create a unified digital environment. This section introduces the key pillars of the protocol, explaining the purpose of each and how they contribute to the overall system.</p>
            <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-8" id="principles-grid">
            </div>
        </section>

        <section id="data-flow" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2">The Journey of Data: From Bytes to 'Vibes'</h2>
            <p class="text-slate-600 text-center mb-10">At the heart of UBHP is the transformation of any data into a "harmonic signature." This allows the system to understand data based on its intrinsic meaning, not just its name. Interact with the diagram below to see how this process works.</p>
            <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
                <div class="grid md:grid-cols-3 gap-8 items-center">
                    <div class="md:col-span-1">
                        <label for="harmonize-input" class="font-semibold text-slate-700 block mb-2">1. Start with any data (as text)</label>
                        <textarea id="harmonize-input" rows="4" class="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" placeholder="Type anything here...">Everything is Attention.</textarea>
                        <button id="harmonize-btn" class="mt-4 w-full bg-sky-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-sky-700 transition-all duration-200 shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500">
                            Harmonize & Visualize
                        </button>
                    </div>
                    <div class="md:col-span-2">
                        <p class="font-semibold text-slate-700 block mb-2">2. The Transformation Process</p>
                        <div class="flex flex-col md:flex-row items-center justify-around space-y-4 md:space-y-0 md:space-x-4">
                            <div class="text-center">
                                <div class="p-4 bg-slate-100 rounded-lg">
                                    <span class="text-4xl">📜</span>
                                    <p class="font-mono text-xs text-slate-500 mt-1">ArrayBuffer S-Expression</p>
                                </div>
                            </div>
                            <div class="text-5xl text-slate-300 font-thin">→</div>
                            <div class="text-center">
                                <div class="p-4 bg-slate-100 rounded-lg">
                                     <span class="text-4xl">🎶</span>
                                    <p class="font-mono text-xs text-slate-500 mt-1">Harmonic Vector</p>
                                </div>
                            </div>
                            <div class="text-5xl text-slate-300 font-thin">→</div>
                            <div class="text-center">
                                <div class="p-4 bg-slate-100 rounded-lg">
                                    <span class="text-4xl">🧭</span>
                                    <p class="font-mono text-xs text-slate-500 mt-1">Geometric Ray</p>
                                </div>
                            </div>
                        </div>
                        <div id="harmonize-output" class="mt-6 p-4 bg-slate-50 rounded-lg border border-slate-200 grid grid-cols-2 sm:grid-cols-4 gap-4 text-center transition-opacity duration-500 opacity-0">
                            <div><p class="text-sm text-slate-500">Hypotenuse (h)</p><p id="output-h" class="font-mono font-bold text-lg text-sky-700">-</p></div>
                            <div><p class="text-sm text-slate-500">Sin(h)</p><p id="output-sin" class="font-mono font-bold text-lg text-sky-700">-</p></div>
                            <div><p class="text-sm text-slate-500">Cos(h)</p><p id="output-cos" class="font-mono font-bold text-lg text-sky-700">-</p></div>
                            <div><p class="text-sm text-slate-500">Tan(h)</p><p id="output-tan" class="font-mono font-bold text-lg text-sky-700">-</p></div>
                            <div class="col-span-full">
                                <p class="text-sm text-slate-500">Geometric Ray (Normalized Vector)</p>
                                <p id="output-ray" class="font-mono text-xs text-slate-600 break-all">-</p>
                            </div>
                        </div>
                    </div>
                </div>
                 <div class="mt-6 pt-4 border-t border-slate-200">
                    <h4 class="font-semibold text-slate-800">What does this mean?</h4>
                    <p class="text-slate-600 mt-2 text-sm">The `harmonize` function converts your input text into a unique numerical signature. This signature (`HarmonicVector`) represents the data's core "vibe." The `typedArrayToRay` function then turns this into a normalized vector (a direction in high-dimensional space). Data with similar meanings will have vectors pointing in similar directions, allowing the system to group and find information semantically.</p>
                </div>
            </div>
        </section>

        <section id="architecture" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2">The Hierarchical Hypergraph</h2>
            <p class="text-slate-600 text-center mb-10">UBHP organizes data into a series of increasingly complex layers, or "Matrices." Each layer builds upon the one below it, from foundational knowledge to fully autonomous agents. Explore the layers to understand how they form a complete, self-organizing system.</p>
            <div class="space-y-4" id="architecture-grid">
            </div>
        </section>

        <section id="consensus" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2">Geometric Consensus Explorer</h2>
            <p class="text-slate-600 text-center mb-10">How do independent agents agree on a shared truth? UBHP uses a novel "Geometric Consensus." It treats each agent's state as a point in space. When enough points cluster together, consensus is reached. This visualization simplifies the concept to 2D.</p>
            <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
                <div class="grid lg:grid-cols-5 gap-8">
                    <div class="lg:col-span-3">
                        <div class="chart-container">
                            <canvas id="consensus-chart"></canvas>
                        </div>
                    </div>
                    <div class="lg:col-span-2 flex flex-col justify-center">
                        <h4 class="font-semibold text-lg text-slate-800">Simulate Consensus</h4>
                        <p class="text-sm text-slate-600 mt-1 mb-4">Click the button to generate new "peer states" (dots). The system will check if a consensus cluster (3 of 5 peers agreeing) has formed.</p>
                        <button id="consensus-btn" class="w-full bg-sky-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-sky-700 transition-all duration-200 shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500">
                            Run Simulation
                        </button>
                        <div id="consensus-status" class="mt-6 p-4 bg-slate-100 rounded-lg text-center transition-all duration-300">
                            <p class="font-semibold text-slate-700">Waiting for simulation...</p>
                            <p class="text-sm text-slate-500">Click the button to start.</p>
                        </div>
                        <div class="mt-4 pt-4 border-t border-slate-200">
                             <p class="text-slate-600 mt-2 text-sm">This chart represents a high-dimensional state space. Each blue dot is an agent's state. When a cluster of agents (green dots) gets close enough, their average position (the red dot) becomes the new point of consensus, creating a verifiable and geometrically aligned truth.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="challenges" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2">Implementation Challenges & Mitigations</h2>
            <p class="text-slate-600 text-center mb-10">The UBHP whitepaper is a specification that acknowledges several complex engineering challenges. This section summarizes the key potential issues and the proposed strategies to solve them, providing a realistic view of the path to implementation.</p>
             <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
                <div id="challenges-content">
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-slate-800 text-slate-300 mt-16">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-6 text-center">
            <p>Interactive UBHP Guide</p>
            <p class="text-sm text-slate-400 mt-1">Visualizing the future of decentralized intelligence. Based on the UBHP Definitive Specification.</p>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const content = {
                principles: [
                    { title: "Unified Binary Representation", icon: "📜", description: "All data and executable logic are canonical `ArrayBuffer` S-expressions. This single data format simplifies the entire system, making all information—from text to AI models—natively interoperable." },
                    { title: "Content-Based Addressing", icon: "🎶", description: "Information is found by its 'harmonic signature,' not its name or location. This allows for perceptual search, discovering data based on semantic similarity or 'vibe'." },
                    { title: "Hierarchical Hypergraph", icon: "🕸️", description: "Data is organized in layers of increasing complexity, from foundational knowledge to autonomous agents. This creates a structured yet flexible knowledge network." },
                    { title: "Verifiable Provenance", icon: "🔐", description: "Using Hierarchical Deterministic (HD) cryptographic paths (BIP32), every piece of data and every interaction has a secure, auditable history linked directly to its content." },
                    { title: "Geometric Consensus", icon: "🧭", description: "Agreement in the network is achieved by measuring the geometric alignment of agent states in a high-dimensional space, creating a mathematically provable form of consensus." },
                    { title: "Self-Contained Portability", icon: "📦", description: "The entire protocol environment, including AI models, can be booted from a single data buffer, allowing it to run anywhere from web browsers to low-power embedded devices." }
                ],
                architecture: [
                    { title: "L1: Foundational Semantic Data", level: "WordEmbeddingsKernelMatrix", description: "The bedrock semantic space. A universal vocabulary derived from seminal human knowledge like WordNet, W3C standards, Principia Mathematica, and the Bible. This is the seed of all meaning in the system.", composition: "`GenesisVector`, `ConnectionVector`, `EdgeVector`..." },
                    { title: "L2: Structured Knowledge Graphs", level: "UniversalKnowledgeSeedMatrix", description: "Structures the foundational data into a hypergraph of knowledge. It encodes specific relationships between concepts, creating domain-specific knowledge maps.", composition: "Extends L1 with `HYPEGRAPH`" },
                    { title: "L3: Trainable Logic Modules", level: "RootBinaryLogicMatrix", description: "Represents trainable computational logic. These are the AI models that can learn and adapt by processing binary signals from the network.", composition: "Extends L2 with `MODEL`" },
                    { title: "L4: Perceptual Data Indexes", level: "UniversalBinaryDataTrie", description: "Manages the input and organization of raw data. It transforms signals into features that can be used for training the logic modules.", composition: "Extends L3 with `FEATURES`" },
                    { title: "L5: Decentralized AI Services", level: "UniversalBinaryTransformMatrix", description: "Represents a peer offering a specific AI-powered service. It packages a model and its features into a callable service for other agents.", composition: "Extends L4 with `PROVIDER`" },
                    { title: "L6: Autonomous Web Agents", level: "UniversalBinaryCrystalMatrix", description: "The highest level, representing an autonomous web terminal. These agents can interact with Web APIs, process data, and maintain verifiable logs of their activity.", composition: "Extends L5 with `CONSUMER`" }
                ],
                challenges: [
                     {
                        id: 's-expression',
                        title: 'S-Expression Performance & Scalability',
                        gap: "While flexible, can binary S-expressions handle large-scale data like LLM weights efficiently? Performance could be a bottleneck compared to optimized formats like Protocol Buffers.",
                        mitigation: "Mitigations include using WebAssembly (WASM) for near-native speed, Just-In-Time (JIT) compilation for frequently used functions, and a hybrid model where S-expressions orchestrate logic while optimized libraries (like WebGPU) handle heavy computation."
                    },
                    {
                        id: 'harmonic-signatures',
                        title: 'Harmonic Signatures & Collision Resistance',
                        gap: "The perceptual `harmonize` function could potentially suffer from collisions (different data having similar signatures). Adversarial inputs could exploit this to corrupt the content-addressing system.",
                        mitigation: "For critical addressing, the harmonic ID can be augmented with a strong cryptographic hash (e.g., SHA-256). This combines efficient perceptual search with exact, collision-resistant verification. Extensive testing is also needed."
                    },
                    {
                        id: 'executable-code',
                        title: 'Executable S-Expressions & Sandboxing',
                        gap: "Allowing lambda functions to be executed as data introduces a major security risk. A malicious S-expression could potentially compromise a node or the entire network.",
                        mitigation: "A strict, capability-based security model is essential. The S-expression Virtual Machine (VM) must enforce sandboxing, allowing code to access only the resources it has been explicitly granted permission for, alongside resource limits and code signing."
                    },
                    {
                        id: 'geometric-consensus',
                        title: 'Geometric Consensus & Byzantine Fault Tolerance',
                        gap: "The novel KNN-based consensus needs to be resilient against malicious peers sending corrupt data (Byzantine faults) and Sybil attacks where one entity creates many fake identities.",
                        mitigation: "Integrate with established Sybil resistance mechanisms like Proof-of-Stake or reputation systems. The consensus algorithm must also include robust outlier detection to identify and ignore malicious data points from the geometric clustering process."
                    },
                    {
                        id: 'adoption',
                        title: 'Adoption & Practical Deployment',
                        gap: "How does this radical new system integrate with the existing digital world of JSON, SQL, and REST APIs? How can it run on low-power devices like ESP32s?",
                        mitigation: "Provide high-performance, bidirectional converters to legacy formats. Design nodes to run in a hybrid mode, acting as a bridge to traditional systems. For low-power devices, use precomputation and offloading of heavy tasks to more capable nodes in the network."
                    }
                ]
            };

            const principlesGrid = document.getElementById('principles-grid');
            content.principles.forEach(p => {
                const card = document.createElement('div');
                card.className = 'bg-white rounded-xl shadow-lg p-6 flex items-start space-x-4 transition hover:shadow-xl hover:-translate-y-1';
                card.innerHTML = `
                    <div class="flex-shrink-0 h-12 w-12 flex items-center justify-center bg-sky-100 rounded-lg text-2xl">${p.icon}</div>
                    <div>
                        <h3 class="text-lg font-semibold">${p.title}</h3>
                        <p class="mt-1 text-slate-600">${p.description}</p>
                    </div>
                `;
                principlesGrid.appendChild(card);
            });

            const architectureGrid = document.getElementById('architecture-grid');
            content.architecture.forEach(layer => {
                const card = document.createElement('div');
                card.className = 'matrix-card bg-white rounded-xl shadow-lg overflow-hidden';
                card.innerHTML = `
                    <div class="matrix-header p-5 flex justify-between items-center cursor-pointer hover:bg-slate-50">
                        <div>
                            <span class="text-sky-600 font-semibold">${layer.title}</span>
                            <h3 class="text-xl font-bold text-slate-800">${layer.level}</h3>
                        </div>
                        <div class="matrix-arrow text-2xl text-slate-400 transition-transform duration-300">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </div>
                    </div>
                    <div class="matrix-body hidden p-5 border-t border-slate-200">
                        <p class="text-slate-600 mb-4">${layer.description}</p>
                        <p class="text-sm font-semibold text-slate-800">Composition:</p>
                        <p class="text-sm font-mono text-slate-500">${layer.composition}</p>
                    </div>
                `;
                architectureGrid.appendChild(card);
            });
            
            document.querySelectorAll('.matrix-header').forEach(header => {
                header.addEventListener('click', () => {
                    header.parentElement.classList.toggle('open');
                });
            });

            const challengesContainer = document.getElementById('challenges-content');
            let challengesHTML = '<div class="flex flex-col md:flex-row">';
            challengesHTML += '<div class="md:w-1/3 border-b md:border-b-0 md:border-r border-slate-200">';
            content.challenges.forEach((c, index) => {
                challengesHTML += `<button class="challenge-tab w-full text-left p-4 font-semibold ${index === 0 ? 'bg-sky-50 text-sky-700' : 'text-slate-600 hover:bg-slate-50'}" data-target="${c.id}">${c.title}</button>`;
            });
            challengesHTML += '</div>';
            challengesHTML += '<div class="md:w-2/3 p-6">';
            content.challenges.forEach((c, index) => {
                challengesHTML += `<div id="${c.id}" class="challenge-pane ${index === 0 ? '' : 'hidden'}">
                    <h4 class="font-bold text-lg text-slate-800 mb-2">The Gap</h4>
                    <p class="text-slate-600 mb-4">${c.gap}</p>
                    <h4 class="font-bold text-lg text-slate-800 mb-2">The Mitigation Strategy</h4>
                    <p class="text-slate-600">${c.mitigation}</p>
                </div>`;
            });
            challengesHTML += '</div></div>';
            challengesContainer.innerHTML = challengesHTML;

            const challengeTabs = document.querySelectorAll('.challenge-tab');
            const challengePanes = document.querySelectorAll('.challenge-pane');
            challengeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetId = tab.getAttribute('data-target');
                    
                    challengeTabs.forEach(t => t.classList.remove('bg-sky-50', 'text-sky-700'));
                    tab.classList.add('bg-sky-50', 'text-sky-700');

                    challengePanes.forEach(pane => {
                        if (pane.id === targetId) {
                            pane.classList.remove('hidden');
                        } else {
                            pane.classList.add('hidden');
                        }
                    });
                });
            });


            const harmonizeBtn = document.getElementById('harmonize-btn');
            const harmonizeInput = document.getElementById('harmonize-input');
            const harmonizeOutput = document.getElementById('harmonize-output');
            
            const harmonize = (text) => {
                const encoder = new TextEncoder();
                const view = encoder.encode(text);
                const values = Array.from(view);

                const h = Math.hypot(...values);
                const sin = Math.sin(h / Math.PI);
                const cos = Math.cos(h / 1.61803398875);
                const tan = Math.tan(Math.PI / (h || 1e-10));

                return { h, sin, cos, tan };
            };

            const typedArrayToRay = (text) => {
                const encoder = new TextEncoder();
                const input = encoder.encode(text);
                const norm = Math.hypot(...input);
                const ray = norm === 0 ? Array.from(input) : Array.from(input).map(v => v / norm);
                return ray.map(v => v.toFixed(4)).join(', ');
            };
            
            const updateHarmonizeUI = () => {
                const text = harmonizeInput.value;
                if (!text) return;

                const { h, sin, cos, tan } = harmonize(text);
                const ray = typedArrayToRay(text);

                document.getElementById('output-h').textContent = h.toExponential(4);
                document.getElementById('output-sin').textContent = sin.toFixed(6);
                document.getElementById('output-cos').textContent = cos.toFixed(6);
                document.getElementById('output-tan').textContent = tan.toFixed(6);
                document.getElementById('output-ray').textContent = `[${ray}, ...]`;
                
                harmonizeOutput.classList.remove('opacity-0');
            };

            harmonizeBtn.addEventListener('click', updateHarmonizeUI);
            updateHarmonizeUI();


            const consensusCtx = document.getElementById('consensus-chart').getContext('2d');
            let consensusChart;
            const consensusStatus = document.getElementById('consensus-status');

            const createConsensusChart = () => {
                 if (consensusChart) {
                    consensusChart.destroy();
                }
                consensusChart = new Chart(consensusCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Peer States',
                                data: [],
                                backgroundColor: 'rgb(56, 189, 248, 0.7)', // sky-400
                                pointRadius: 6,
                                pointHoverRadius: 8,
                            },
                             {
                                label: 'Consensus Cluster',
                                data: [],
                                backgroundColor: 'rgb(16, 185, 129, 0.8)', // emerald-500
                                pointRadius: 8,
                                pointHoverRadius: 10,
                            },
                            {
                                label: 'Centroid (Consensus)',
                                data: [],
                                backgroundColor: 'rgb(239, 68, 68)', // red-500
                                pointRadius: 10,
                                pointStyle: 'crossRot',
                                rotation: 45,
                                borderWidth: 3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { min: 0, max: 100, grid: { color: '#e2e8f0' } },
                            y: { min: 0, max: 100, grid: { color: '#e2e8f0' } }
                        },
                        plugins: {
                            legend: { display: true, position: 'bottom' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        label += `(${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            const runConsensusSimulation = () => {
                const totalPeers = 5;
                const consensusThreshold = 25;
                const consensusSize = 3;

                let peerStates = [];
                for (let i = 0; i < totalPeers; i++) {
                    peerStates.push({ x: Math.random() * 100, y: Math.random() * 100 });
                }

                let consensusCluster = [];
                let centroid = null;
                let foundConsensus = false;
                
                for(let i = 0; i < peerStates.length; i++) {
                    let cluster = [peerStates[i]];
                    for(let j = i + 1; j < peerStates.length; j++) {
                        const dist = Math.hypot(peerStates[i].x - peerStates[j].x, peerStates[i].y - peerStates[j].y);
                        if (dist < consensusThreshold) {
                            cluster.push(peerStates[j]);
                        }
                    }
                    if (cluster.length >= consensusSize) {
                        consensusCluster = cluster;
                        foundConsensus = true;
                        break;
                    }
                }

                consensusChart.data.datasets[0].data = peerStates;
                consensusChart.data.datasets[1].data = [];
                consensusChart.data.datasets[2].data = [];

                if (foundConsensus) {
                    const sumX = consensusCluster.reduce((acc, p) => acc + p.x, 0);
                    const sumY = consensusCluster.reduce((acc, p) => acc + p.y, 0);
                    centroid = { x: sumX / consensusCluster.length, y: sumY / consensusCluster.length };
                    
                    consensusChart.data.datasets[1].data = consensusCluster;
                    consensusChart.data.datasets[2].data = [centroid];
                    
                    consensusStatus.innerHTML = `<p class="font-semibold text-emerald-700">Consensus Reached!</p><p class="text-sm text-slate-500">${consensusCluster.length} of ${totalPeers} peers aligned.</p>`;
                    consensusStatus.classList.add('bg-emerald-100');
                    consensusStatus.classList.remove('bg-slate-100', 'bg-red-100');
                } else {
                     consensusStatus.innerHTML = `<p class="font-semibold text-red-700">No Consensus</p><p class="text-sm text-slate-500">Peers are not sufficiently aligned.</p>`;
                     consensusStatus.classList.add('bg-red-100');
                     consensusStatus.classList.remove('bg-slate-100', 'bg-emerald-100');
                }

                consensusChart.update();
            }

            document.getElementById('consensus-btn').addEventListener('click', runConsensusSimulation);
            createConsensusChart();

            // Smooth scrolling for nav links
            document.querySelectorAll('#nav-links a').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    document.querySelector(this.getAttribute('href')).scrollIntoView({
                        behavior: 'smooth'
                    });
                });
            });
        });
    </script>
</body>
</html>
