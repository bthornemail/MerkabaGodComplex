<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UBHP Decentralized Marketplace (Full Features)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/4.3.7/mqtt.min.js"></script>
    <script src="https://cdn.ethers.io/lib/ethers-5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/openpgp/5.11.0/openpgp.min.js"></script>
    <style>
        body { font-family: 'Inter', Arial, sans-serif; margin: 20px; background-color: #f0f4f8; color: #1e293b; }
        .container { display: flex; flex-wrap: wrap; gap: 20px; }
        .panel { background-color: #ffffff; border: 1px solid #e2e8f0; border-radius: 1.5rem; padding: 2.5rem; box-shadow: 0 10px 20px -5px rgba(0,0,0,0.1), 0 4px 8px -2px rgba(0,0,0,0.05); flex: 1; min-width: 300px; }
        h1 { font-size: 2.5rem; font-weight: 800; text-align: center; margin-bottom: 1.5rem; color: #004c6d; }
        h2 { font-size: 1.75rem; font-weight: 700; text-align: center; margin-bottom: 1.5rem; color: #004c6d; border-bottom: 1px solid #e2e8f0; padding-bottom: 10px; }
        h3 { font-size: 1.25rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 1rem; color: #334155; }
        label { display: block; margin-bottom: 5px; font-weight: 500; color: #334155; }
        input[type="text"], input[type="number"], textarea, select, input[type="file"] {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #cbd5e1; border-radius: 0.5rem; background-color: #f8faff; color: #1e293b;
        }
        button {
            background-color: #004c6d; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 0.75rem;
            cursor: pointer; font-size: 1rem; margin-right: 5px; transition: background-color 0.3s ease, transform 0.2s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover { background-color: #00334d; transform: translateY(-2px); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; box-shadow: none; }
        .btn-danger { background-color: #dc2626; }
        .btn-danger:hover { background-color: #b91c1c; }
        .btn-secondary { background-color: #5b8ba7; }
        .btn-secondary:hover { background-color: #477791; }
        .log-container { max-height: 300px; overflow-y: auto; background-color: #f8faff; padding: 1rem; border-radius: 0.75rem; border: 1px solid #e2e8f0; margin-top: 1rem; }
        .log-entry { margin-bottom: 0.5rem; border-bottom: 1px dotted #e2e8f0; padding-bottom: 0.5rem; font-size: 0.875rem; color: #475569; }
        .message-entry { background-color: #e0f2fe; padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #bfdbfe; }
        .message-entry strong { color: #0369a1; }
        .error { color: #dc2626; }
        .success { color: #065f46; }
        .status-info { color: #0369a1; }
        .media-attachment-section { background-color: #eef2f8; border-radius: 0.75rem; padding: 1rem; margin-bottom: 1rem; }
        .media-attachment-section h4 { font-size: 1.1rem; font-weight: 600; text-align: center; margin-bottom: 0.75rem; color: #004c6d; }
        .media-attachment-section .btn-group { margin-bottom: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; }
        video, img, audio, canvas { display: block; max-width: 100%; height: auto; margin: 0.5rem auto; border: 1px solid #cbd5e1; border-radius: 0.5rem; }
        #webcamVideoPreview, #webcamSnapshotPreview { background-color: black; }
        .ad-canvas { border: 1px solid #cbd5e1; background-color: #ffffff; border-radius: 0.75rem; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06); cursor: crosshair; }
        .canvas-controls { display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: center; align-items: center; margin-bottom: 1rem; }
        .canvas-controls button.active { background-color: #004c6d; color: white; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .canvas-controls button:not(.active):hover { background-color: #e2e8f0; }
        .milestone-entry { background-color: #f0f4f8; padding: 10px; border-radius: 5px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        .milestone-entry.completed { background-color: #d1fae5; }
        .milestone-entry.disputed { background-color: #fee2e2; }
        .milestone-entry span { flex-grow: 1; }
        .milestone-entry button { margin-left: 5px; padding: 5px 10px; font-size: 0.8rem; }
        .review-entry { background-color: #f8faff; padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #e2e8f0; }
        .review-entry strong { color: #004c6d; }
        .knowledge-node-entry { background-color: #f0f8ff; padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #cceeff; }
        .knowledge-node-entry strong { color: #0056b3; }
        .knowledge-node-entry .tags { font-size: 0.75rem; color: #666; margin-top: 5px; }
        .knowledge-node-entry .node-id { font-size: 0.7rem; color: #999; }
        .course-section { border: 1px solid #e0e7eb; border-radius: 0.75rem; padding: 1rem; margin-bottom: 1rem; background-color: #f8faff; }
        .module-section, .lesson-section { border: 1px dashed #d1d9e0; border-radius: 0.5rem; padding: 0.75rem; margin-top: 0.75rem; background-color: #fdfefe; }
        .exam-question, .task-item { margin-top: 0.5rem; padding: 0.5rem; background-color: #eef2f8; border-radius: 0.5rem; }
        .course-participant-progress { margin-top: 1rem; padding-top: 1rem; border-top: 1px dotted #e2e8f0; }
        .asset-token-entry, .equipment-entry, .arbitration-case-entry, .loan-entry, .grant-entry, .insurance-policy-entry { background-color: #e6f7ff; padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 0.5rem; border: 1px solid #99ddff; }
        .asset-token-entry strong, .equipment-entry strong, .arbitration-case-entry strong, .loan-entry strong, .grant-entry strong, .insurance-policy-entry strong { color: #007bff; }
    </style>
</head>
<body>
    <h1>UBHP Decentralized Marketplace (Full Features)</h1>
    <div class="container">
        <div class="panel">
            <h2>Wallet & Connection</h2>
            <label for="mnemonicInput">Mnemonic Phrase:</label>
            <textarea id="mnemonicInput" rows="2" placeholder="Leave empty to generate a new wallet, or enter yours..."></textarea>
            <button onclick="generateWallet()">Generate/Load Wallet</button>
            <button onclick="connectMQTT()">Connect MQTT</button>
            <p><strong>Your Address:</strong> <span id="myAddress">N/A</span></p>
            <p><strong>Your Client ID:</strong> <span id="myClientId">N/A</span></p>
            <p><strong>Your OpenPGP Public Key (Armored):</strong> <textarea id="myOpenPGPPublicKeyDisplay" rows="5" readonly></textarea></p>
            <p><strong>PSK:</strong> <input type="text" id="presharedKeyInput" placeholder="Enter a preshared key (e.g., mysecretkey123)"> <button onclick="setCurrentPSK()">Set PSK</button></p>
            <p id="connectionStatus">Status: Disconnected</p>
            <p><strong>Conceptual Broker Address (Arbitrator):</strong> <span id="brokerAddressDisplay">N/A</span></p>
        </div>
        <div class="panel">
            <h2>Post Classified Ad</h2>
            <label for="adTitle">Title:</label>
            <input type="text" id="adTitle" placeholder="e.g., Vintage Bicycle or Web Design Service">
            <label for="adPrice">Price (UBHP):</label>
            <input type="number" id="adPrice" placeholder="e.g., 100">
            <label for="adDescription">Description:</label>
            <textarea id="adDescription" rows="3" placeholder="e.g., Good condition, minor scratches or I build custom websites"></textarea>
            <label for="adType">Ad Type:</label>
            <select id="adType">
                <option value="product">Product</option>
                <option value="service">Service</option>
                <option value="equipment">Equipment</option>
            </select>
            <div id="milestonesSection" style="display: none;">
                <h3>Service Milestones</h3>
                <div id="milestonesContainer"></div>
                <button onclick="addMilestone()">Add Milestone</button>
            </div>
            <div id="equipmentSection" style="display: none;">
                <h3>Equipment Details</h3>
                <label for="equipmentIdInput">Equipment ID (e.g., Serial Number):</label>
                <input type="text" id="equipmentIdInput" placeholder="Unique ID for this equipment">
                <label for="equipmentInitialStatus">Initial Status:</label>
                <input type="text" id="equipmentInitialStatus" value="operational" placeholder="e.g., operational, new, in_storage">
            </div>
            <h3>Attach Media (Optional)</h3>
            <!-- Audio Dictaphone for Ad -->
            <div class="media-attachment-section">
                <h4>Audio Dictation</h4>
                <div class="btn-group">
                    <button id="recordAdAudioButton" class="btn-secondary" disabled>Record Audio</button>
                    <button id="stopAdAudioButton" class="btn-danger" disabled>Stop Audio</button>
                    <button id="playAdAudioButton" class="btn-secondary" disabled>Play Audio</button>
                </div>
                <div id="adAudioStatus" class="status-message status-info hidden"></div>
                <audio id="adAudioPlayback" controls class="hidden"></audio>
            </div>
            <!-- Video Recorder for Ad -->
            <div class="media-attachment-section">
                <h4>Video Recording</h4>
                <div class="btn-group">
                    <button id="startAdVideoButton" class="btn-secondary" disabled>Start Video</button>
                    <button id="stopAdVideoButton" class="btn-danger" disabled>Stop Video</button>
                    <button id="playAdVideoButton" class="btn-secondary" disabled>Play Video</button>
                </div>
                <div id="adVideoStatus" class="status-message status-info hidden"></div>
                <video id="webcamVideoPreview" autoplay muted class="hidden"></video>
                <video id="adVideoPlayback" controls class="hidden"></video>
            </div>
            <!-- Webcam Snapshot for Ad -->
            <div class="media-attachment-section">
                <h4>Webcam Snapshot</h4>
                <div class="btn-group">
                    <button id="startWebcamSnapshotButton" class="btn-secondary" disabled>Start Webcam</button>
                    <button id="takeSnapshotButton" class="btn-primary" disabled>Take Snapshot</button>
                    <button id="stopWebcamSnapshotButton" class="btn-danger" disabled>Stop Webcam</button>
                </div>
                <div id="adSnapshotStatus" class="status-message status-info hidden"></div>
                <video id="webcamSnapshotPreview" autoplay muted class="hidden"></video>
                <img id="imagePreview" class="hidden" alt="Webcam Snapshot">
            </div>
            <!-- Image Upload for Ad -->
            <div class="media-attachment-section">
                <h4>Image Upload</h4>
                <div class="btn-group">
                    <input type="file" id="uploadImageInput" accept="image/*" class="hidden">
                    <button id="uploadImageButton" class="btn-secondary" disabled>Upload Image</button>
                    <button id="clearImageButton" class="btn-danger" disabled>Clear Image</button>
                </div>
                <div id="adImageUploadStatus" class="status-message status-info hidden"></div>
                <img id="uploadedImagePreview" class="hidden" alt="Uploaded Image">
            </div>
            <!-- Speech-to-Text for Ad -->
            <div class="media-attachment-section">
                <h4>Speech-to-Text Note</h4>
                <div class="btn-group">
                    <button id="startSpeechButton" class="btn-secondary" disabled>Start Listening</button>
                    <button id="stopSpeechButton" class="btn-danger" disabled>Stop Listening</button>
                </div>
                <div id="adSpeechStatus" class="status-message status-info hidden"></div>
                <textarea id="adSpeechText" rows="3" placeholder="Recognized speech will appear here..." class="w-full text-sm mt-2" readonly></textarea>
            </div>
            <!-- Geolocation for Ad -->
            <div class="media-attachment-section">
                <h4>Geolocation</h4>
                <div class="btn-group">
                    <button id="getAdLocationButton" class="btn-secondary" disabled>Get Current Location</button>
                    <button id="clearAdLocationButton" class="btn-danger" disabled>Clear Location</button>
                </div>
                <div id="adLocationStatus" class="status-message status-info hidden"></div>
                <p id="adLocationDisplay" class="text-center text-sm mt-2 text-slate-700 hidden"></p>
            </div>
            <!-- Generic File Upload for Ad -->
            <div class="media-attachment-section">
                <h4>Generic File Upload</h4>
                <div class="btn-group">
                    <input type="file" id="uploadFileAdInput" class="hidden">
                    <button id="uploadFileAdButton" class="btn-secondary" disabled>Upload File</button>
                    <button id="clearFileAdButton" class="btn-danger" disabled>Clear File</button>
                </div>
                <div id="adFileUploadStatus" class="status-message status-info hidden"></div>
                <p id="adFileNameDisplay" class="text-center text-sm mt-2 text-slate-700 hidden"></p>
            </div>
            <!-- Shared Canvas for Ad Image -->
            <div class="media-attachment-section">
                <h4>Canvas Drawing/Image</h4>
                <div class="canvas-controls mb-4">
                    <label for="adCanvasColorPicker">Color:</label>
                    <input type="color" id="adCanvasColorPicker" value="#000000" class="w-10 h-10">
                    <label for="adCanvasLineWidth">Width:</label>
                    <input type="range" id="adCanvasLineWidth" min="1" max="10" value="2" class="w-24">
                    <button id="adCanvasDrawModeButton" class="btn-secondary active">Draw</button>
                    <button id="adCanvasTextModeButton" class="btn-secondary">Text</button>
                    <button id="adCanvasImageModeButton" class="btn-secondary">Image</button>
                    <button id="clearAdCanvasButton" class="btn-danger" disabled>Clear</button>
                </div>
                <canvas id="adSharedCanvas" width="700" height="200" class="w-full h-auto ad-canvas"></canvas>
                <div id="adCanvasStatus" class="status-message status-info hidden"></div>
            </div>
            <button onclick="postAd()">Post Ad</button>
            <div class="log-container">
                <p><strong>My Posted Ads:</strong></p>
                <div id="myAdsList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Marketplace Actions</h2>
            <h3>Make Offer</h3>
            <label for="offerAdId">Ad ID to Offer On:</label>
            <input type="text" id="offerAdId" placeholder="e.g., ad_uuid_123">
            <label for="offerAmount">Offer Amount (UBHP):</label>
            <input type="number" id="offerAmount" placeholder="e.g., 90">
            <button onclick="makeOffer()">Make Offer</button>
            <div class="log-container">
                <p><strong>My Made Offers:</strong></p>
                <div id="myOffersList"></div>
            </div>
            <h3>Manage Offers</h3>
            <p><strong>Offers Received:</strong></p>
            <div class="log-container">
                <div id="offersReceivedList"></div>
            </div>
            <label for="selectedOfferId">Selected Offer ID to Accept/Reject:</label>
            <input type="text" id="selectedOfferId" placeholder="Offer ID from 'Offers Received'">
            <button onclick="acceptOfferFromInput()">Accept Selected Offer</button>
            <button onclick="rejectOfferFromInput()">Reject Selected Offer</button>
        </div>

        <div class="panel">
            <h2>My Services (Contracts)</h2>
            <p>Active service contracts where you are the contractor.</p>
            <div class="log-container">
                <div id="myServiceContractsList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Services I'm Buying (Contracts)</h2>
            <p>Active service contracts where you are the client.</p>
            <div class="log-container">
                <div id="myBuyingContractsList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>My Equipment Contracts</h2>
            <p>Active equipment contracts where you are the owner or buyer.</p>
            <div class="log-container">
                <div id="myEquipmentContractsList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Asset Tokens</h2>
            <h3>Mint New Asset Token</h3>
            <label for="assetTokenId">Token ID (Unique Identifier):</label>
            <input type="text" id="assetTokenId" placeholder="e.g., NFT-Art-001">
            <label for="assetTokenDescription">Description:</label>
            <textarea id="assetTokenDescription" rows="2" placeholder="e.g., Digital painting of a cat"></textarea>
            <button onclick="mintAssetToken()">Mint Asset Token</button>
            <h3>Transfer Asset Token</h3>
            <label for="transferAssetTokenId">Token ID to Transfer:</label>
            <input type="text" id="transferAssetTokenId" placeholder="e.g., NFT-Art-001">
            <label for="transferRecipientClientId">Recipient Client ID:</label>
            <input type="text" id="transferRecipientClientId" placeholder="Client ID of recipient">
            <button onclick="transferAssetToken()">Transfer Asset Token</button>
            <div class="log-container">
                <p><strong>My Owned Assets:</strong></p>
                <div id="myOwnedAssetsList"></div>
            </div>
        </div>

        <!-- New Panel: Lending & Loans -->
        <div class="panel">
            <h2>Lending & Loans</h2>
            <h3>Request a Loan (Borrower)</h3>
            <label for="loanAmount">Loan Amount (UBHP):</label>
            <input type="number" id="loanAmount" placeholder="e.g., 500">
            <label for="loanCollateralTokenId">Collateral Asset Token ID:</label>
            <input type="text" id="loanCollateralTokenId" placeholder="ID of your asset token (e.g., NFT-Art-001)">
            <label for="loanInterestRate">Interest Rate (% per period):</label>
            <input type="number" id="loanInterestRate" step="0.01" placeholder="e.g., 5.0">
            <label for="loanRepaymentDueDate">Repayment Due Date (YYYY-MM-DD):</label>
            <input type="date" id="loanRepaymentDueDate">
            <button onclick="requestLoan()">Request Loan</button>

            <h3>Offer a Loan (Lender)</h3>
            <label for="offerLoanId">Loan Request ID to Offer On:</label>
            <input type="text" id="offerLoanId" placeholder="ID from 'Pending Loan Requests'">
            <label for="offerLoanInterestRate">Your Offered Interest Rate (%):</label>
            <input type="number" id="offerLoanInterestRate" step="0.01" placeholder="e.g., 4.5">
            <button onclick="offerLoan()">Offer Loan</button>

            <h3>Manage My Loans (Borrower)</h3>
            <div class="log-container">
                <p><strong>My Active Loans (as Borrower):</strong></p>
                <div id="myActiveLoansList"></div>
            </div>
            <label for="repayLoanId">Loan ID to Repay:</label>
            <input type="text" id="repayLoanId" placeholder="ID from 'My Active Loans'">
            <button onclick="repayLoan()">Repay Loan</button>

            <h3>Manage Loans I've Offered (Lender)</h3>
            <div class="log-container">
                <p><strong>Loans I've Offered/Funded (as Lender):</strong></p>
                <div id="loansOfferedList"></div>
            </div>
            <label for="defaultLoanId">Loan ID to Declare Default (as Lender):</label>
            <input type="text" id="defaultLoanId" placeholder="ID from 'Loans I've Offered'">
            <button onclick="declareLoanDefault()">Declare Default</button>

            <h3>Pending Loan Requests (for Lenders)</h3>
            <div class="log-container">
                <p><strong>Pending Loan Requests:</strong></p>
                <div id="pendingLoanRequestsList"></div>
            </div>
        </div>

        <!-- New Panel: Grants -->
        <div class="panel">
            <h2>Grants</h2>
            <h3>Issue a Grant</h3>
            <label for="grantRecipientClientId">Recipient Client ID:</label>
            <input type="text" id="grantRecipientClientId" placeholder="Client ID of the recipient">
            <label for="grantAmount">Grant Amount (UBHP):</label>
            <input type="number" id="grantAmount" placeholder="e.g., 100">
            <label for="grantDescription">Description:</label>
            <textarea id="grantDescription" rows="2" placeholder="Purpose of the grant..."></textarea>
            <button onclick="issueGrant()">Issue Grant</button>

            <h3>My Issued Grants</h3>
            <div class="log-container">
                <div id="myIssuedGrantsList"></div>
            </div>

            <h3>My Received Grants</h3>
            <div class="log-container">
                <div id="myReceivedGrantsList"></div>
            </div>
        </div>

        <!-- New Panel: Insurance -->
        <div class="panel">
            <h2>Insurance</h2>
            <h3>Request Insurance (Insured)</h3>
            <label for="insuredTokenId">Asset Token ID to Insure:</label>
            <input type="text" id="insuredTokenId" placeholder="ID of your asset token (e.g., NFT-Art-001)">
            <label for="coverageAmount">Coverage Amount (UBHP):</label>
            <input type="number" id="coverageAmount" placeholder="e.g., 1000">
            <label for="premiumAmount">Premium Amount (UBHP):</label>
            <input type="number" id="premiumAmount" placeholder="e.g., 10">
            <label for="policyDurationDays">Policy Duration (Days):</label>
            <input type="number" id="policyDurationDays" value="30">
            <button onclick="requestInsurance()">Request Insurance</button>

            <h3>Offer Insurance (Insurer)</h3>
            <label for="offerPolicyId">Insurance Request ID to Offer On:</label>
            <input type="text" id="offerPolicyId" placeholder="ID from 'Pending Insurance Requests'">
            <label for="offerPremiumAmount">Your Offered Premium (UBHP):</label>
            <input type="number" id="offerPremiumAmount" placeholder="e.g., 9">
            <button onclick="offerInsurance()">Offer Insurance</button>

            <h3>Manage My Policies (Insured)</h3>
            <div class="log-container">
                <p><strong>My Active Insurance Policies:</strong></p>
                <div id="myActiveInsurancePoliciesList"></div>
            </div>
            <label for="claimPolicyId">Policy ID to Claim On:</label>
            <input type="text" id="claimPolicyId" placeholder="ID from 'My Active Insurance Policies'">
            <label for="claimDetails">Claim Details:</label>
            <textarea id="claimDetails" rows="2" placeholder="Describe the incident..."></textarea>
            <button onclick="submitInsuranceClaim()">Submit Claim</button>

            <h3>Manage Policies I've Underwritten (Insurer)</h3>
            <div class="log-container">
                <p><strong>Policies I've Underwritten:</strong></p>
                <div id="policiesUnderwrittenList"></div>
            </div>
            <label for="manageClaimPolicyId">Policy ID for Claim Management:</label>
            <input type="text" id="manageClaimPolicyId" placeholder="ID from 'Policies I've Underwritten'">
            <label for="manageClaimId">Claim ID to Act On:</label>
            <input type="text" id="manageClaimId" placeholder="ID from the policy's claims list">
            <button onclick="approveInsuranceClaim()">Approve Claim</button>
            <button onclick="rejectInsuranceClaim()" class="btn-danger">Reject Claim</button>

            <h3>Pending Insurance Requests (for Insurers)</h3>
            <div class="log-container">
                <p><strong>Pending Insurance Requests:</strong></p>
                <div id="pendingInsuranceRequestsList"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Ratings & Reviews</h2>
            <h3>Leave a Review</h3>
            <label for="reviewAdId">Ad ID of Completed Transaction:</label>
            <input type="text" id="reviewAdId" placeholder="e.g., ad_uuid_123">
            <label for="reviewRating">Rating (1-5):</label>
            <input type="number" id="reviewRating" min="1" max="5" value="5">
            <label for="reviewComment">Comment:</label>
            <textarea id="reviewComment" rows="3" placeholder="Your review..."></textarea>
            <button onclick="submitReview()">Submit Review</button>
            <div class="log-container">
                <p><strong>My Reviews Left:</strong></p>
                <div id="myReviewsList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Universal Knowledge Graph / FAQ</h2>
            <h3>Post New Knowledge Node</h3>
            <label for="knowledgeTitle">Title (Question/Topic):</label>
            <input type="text" id="knowledgeTitle" placeholder="e.g., How to connect to MQTT?">
            <label for="knowledgeContent">Content (Answer/Details):</label>
            <textarea id="knowledgeContent" rows="3" placeholder="e.g., Use the 'Connect MQTT' button after generating a wallet."></textarea>
            <label for="knowledgeTags">Tags (comma-separated):</label>
            <input type="text" id="knowledgeTags" placeholder="e.g., mqtt, connection, faq">
            <label for="knowledgePreviousNodeId">Previous Node ID (Optional, for linking):</label>
            <input type="text" id="knowledgePreviousNodeId" placeholder="ID of related previous node">
            <button onclick="postKnowledgeNode()">Post Knowledge Node</button>
            <h3>Search Knowledge</h3>
            <input type="text" id="knowledgeSearchInput" placeholder="Search by title, content, or tags..." onkeyup="searchKnowledgeNodes()">
            <div class="log-container">
                <p><strong>All Knowledge Nodes:</strong></p>
                <div id="allKnowledgeNodesList"></div>
            </div>
            <div class="log-container" style="display: none;" id="knowledgeSearchResultsContainer">
                <p><strong>Search Results:</strong></p>
                <div id="knowledgeSearchResultsList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Course Management</h2>
            <h3>Create New Course</h3>
            <label for="courseTitle">Course Title:</label>
            <input type="text" id="courseTitle" placeholder="e.g., Intro to Decentralization">
            <label for="courseDescription">Course Description:</label>
            <textarea id="courseDescription" rows="2" placeholder="Brief overview of the course..."></textarea>
            <h4>Modules & Lessons</h4>
            <div id="modulesContainer"></div>
            <button onclick="addModule()">Add Module</button>
            <button onclick="postCourse()">Post Course</button>
            <div class="log-container">
                <p><strong>My Authored Courses:</strong></p>
                <div id="myAuthoredCoursesList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Available Courses</h2>
            <p>Courses broadcast by other peers.</p>
            <div class="log-container">
                <div id="availableCoursesList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>My Enrolled Courses</h2>
            <p>Courses you are participating in.</p>
            <div class="log-container">
                <div id="myEnrolledCoursesList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Arbitration & Agreements</h2>
            <h3>Raise Dispute</h3>
            <label for="disputedItemType">Disputed Item Type:</label>
            <select id="disputedItemType">
                <option value="ad">Classified Ad (Product/Service/Equipment)</option>
                <option value="course">Course</option>
                <option value="knowledge_node">Knowledge Node</option>
                <option value="exam">Exam</option>
                <option value="task">Task</option>
                <option value="loan">Loan</option>
                <option value="insurance_policy">Insurance Policy</option>
                <option value="grant">Grant</option>
            </select>
            <label for="disputedItemId">Disputed Item ID:</label>
            <input type="text" id="disputedItemId" placeholder="ID of the item in dispute">
            <label for="disputeReason">Reason for Dispute:</label>
            <textarea id="disputeReason" rows="3" placeholder="Explain the issue..."></textarea>
            <label for="defendantClientId">Defendant Client ID (other party):</label>
            <input type="text" id="defendantClientId" placeholder="Client ID of the party you are disputing">
            <button onclick="raiseArbitrationRequest()">Raise Dispute</button>
            <h3>Arbitrator Actions (Conceptual)</h3>
            <p>For demo purposes, the broker address <span id="brokerAddressDisplay2">N/A</span> is the conceptual arbitrator. If your client ID matches, you can make a decision.</p>
            <label for="arbitrateCaseId">Case ID to Decide:</label>
            <input type="text" id="arbitrateCaseId" placeholder="Case ID from 'Arbitration Cases'">
            <label for="arbitratorDecision">Decision:</label>
            <textarea id="arbitratorDecision" rows="2" placeholder="e.g., Resolved in favor of plaintiff, Contract nullified."></textarea>
            <label for="arbitratorResolution">Resolution (e.g., 'resolved_for_plaintiff', 'resolved_for_defendant', 'withdrawn'):</label>
            <input type="text" id="arbitratorResolution" value="resolved_for_plaintiff">
            <button onclick="makeArbitratorDecision()" id="arbitratorDecisionButton" disabled>Make Decision</button>
            <div class="log-container">
                <p><strong>Arbitration Cases:</strong></p>
                <div id="arbitrationCasesList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Delegations</h2>
            <p>Delegate control of an ad/offer/course/task to another peer for a period.</p>
            <label for="delegateItemId">Item ID to Delegate (Ad, Offer, Course, Task, etc.):</label>
            <input type="text" id="delegateItemId" placeholder="e.g., ad_uuid_123, offer_uuid_456, course_uuid_789, task_uuid_101">
            <label for="delegateToClientId">Delegate To Client ID:</label>
            <input type="text" id="delegateToClientId" placeholder="Client ID of recipient">
            <label for="delegateDuration">Duration (minutes):</label>
            <input type="number" id="delegateDuration" value="60" min="1">
            <label for="delegationType">Authority Type:</label>
            <select id="delegationType">
                <option value="ACCEPT_OFFER">Accept Offer</option>
                <option value="RELEASE_ESCROW">Release Escrow (Milestone)</option>
                <option value="ATTEST_TASK">Attest Task Completion</option>
                <option value="ARBITRATE_CASE">Arbitrate Case</option>
                <option value="APPROVE_LOAN">Approve Loan</option>
                <option value="APPROVE_INSURANCE_CLAIM">Approve Insurance Claim</option>
            </select>
            <button onclick="delegateControl()">Delegate Control</button>
            <div class="log-container">
                <p><strong>My Delegations:</strong></p>
                <div id="myDelegationsList"></div>
                <p><strong>Delegations Received:</strong></p>
                <div id="delegationsReceivedList"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Marketplace Feed</h2>
            <p>Real-time updates on ads, offers, and actions.</p>
            <div class="log-container">
                <div id="marketplaceFeed"></div>
            </div>
        </div>
        <div class="panel">
            <h2>Messaging</h2>
            <h3>Send Message</h3>
            <label for="messageRecipientClientId">Recipient Client ID (for private):</label>
            <input type="text" id="messageRecipientClientId" placeholder="Leave empty for public, or Client ID">
            <label for="messageType">Message Type:</label>
            <select id="messageType">
                <option value="public">Public</option>
                <option value="openpgp">Private (OpenPGP)</option>
                <option value="psk">Private (Preshared Key)</option>
            </select>
            <label for="messageContent">Message:</label>
            <textarea id="messageContent" rows="3" placeholder="Your message here..."></textarea>
            <button onclick="sendMessage()">Send Message</button>
            <h3>Received Messages</h3>
            <div class="log-container">
                <div id="receivedMessagesLog"></div>
            </div>
            <div class="log-container" style="max-height: 150px;">
                <h4>Known OpenPGP Public Keys (for demo purposes)</h4>
                <p>Manually add a peer's public key here to send them an OpenPGP message:</p>
                <label for="peerClientIdForKey">Peer Client ID:</label>
                <input type="text" id="peerClientIdForKey" placeholder="Peer's Client ID">
                <label for="peerOpenPGPPublicKeyInput">Peer's OpenPGP Public Key (Armored):</label>
                <textarea id="peerOpenPGPPublicKeyInput" rows="3" placeholder="Paste armored public key here"></textarea>
                <button onclick="addKnownPublicKey()">Add Key</button>
                <div id="knownPublicKeysDisplay"></div>
            </div>
        </div>
    </div>
    <script>
        let wallet;
        let provider;
        let signer;
        let mqttClient;
        let myAddress;
        let myClientId;
        let myOpenPGPPublicKey;
        let myOpenPGPPrivateKey;
        let currentPSK = null;

        // Decentralized state management (the "graph" that provides state to all consumers)
        let classifiedAdBuffer = new Map(); // Ad ID -> Ad Object
        let myOffers = new Map(); // Offer ID -> Offer Object (offers I made)
        let offersReceived = new Map(); // Offer ID -> Offer Object (offers on my ads)
        let myDelegations = new Map(); // Delegation ID -> Delegation Object (delegations I created)
        let delegationsReceived = new Map(); // Delegation ID -> Delegation Object (delegations I received)
        let receivedMessages = []; // List of all received messages
        let knownPublicKeys = new Map(); // client_id -> OpenPGP public key object
        let knowledgeGraph = new Map(); // Knowledge Node ID -> Knowledge Node Object
        let courses = new Map(); // Course ID -> Course Object
        let assetTokens = new Map(); // Asset Token ID -> Asset Token Object
        let equipmentContracts = new Map(); // Equipment ID -> Equipment Contract Object
        let arbitrationCases = new Map(); // Arbitration Case ID -> Arbitration Case Object

        // New state variables for Lending, Grants, and Insurance
        let loans = new Map(); // Loan ID -> Loan Object
        let grants = new Map(); // Grant ID -> Grant Object
        let insurancePolicies = new Map(); // Policy ID -> Insurance Policy Object

        const MARKETPLACE_TOPIC = 'ubhp/marketplace/';
        const MESSAGING_TOPIC = 'ubhp/messaging/';
        const KEY_EXCHANGE_TOPIC = 'ubhp/key_exchange/';
        const KNOWLEDGE_TOPIC = 'ubhp/knowledge/';
        const COURSES_TOPIC = 'ubhp/courses/';
        const COURSE_PROGRESS_TOPIC = 'ubhp/course_progress/';
        const ASSETS_TOPIC = 'ubhp/assets/'; // New topic for asset tokens
        const EQUIPMENT_TOPIC = 'ubhp/equipment/'; // New topic for equipment lifecycle
        const ARBITRATION_TOPIC = 'ubhp/arbitration/'; // New topic for arbitration
        const LOANS_TOPIC = 'ubhp/loans/'; // New topic for loans
        const GRANTS_TOPIC = 'ubhp/grants/'; // New topic for grants
        const INSURANCE_TOPIC = 'ubhp/insurance/'; // New topic for insurance

        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();

        const BROKER_ADDRESS = "0x70997970C51812dc3A0108C7D8629879c8Da2a0E"; // Conceptual Broker Address (also acts as arbitrator)

        // --- Core UBHP Functions (Revised for State Transition) ---
        // Function to deterministically update the global state based on an event
        // This is the "phase transition function"
        async function marketplaceStateReducer(currentState, event) {
            const newState = {
                classifiedAdBuffer: new Map(currentState.classifiedAdBuffer),
                myOffers: new Map(currentState.myOffers),
                offersReceived: new Map(currentState.offersReceived),
                myDelegations: new Map(currentState.myDelegations),
                delegationsReceived: new Map(currentState.delegationsReceived),
                receivedMessages: [...currentState.receivedMessages],
                knownPublicKeys: new Map(currentState.knownPublicKeys),
                knowledgeGraph: new Map(currentState.knowledgeGraph),
                courses: new Map(currentState.courses),
                assetTokens: new Map(currentState.assetTokens), // Include assetTokens
                equipmentContracts: new Map(currentState.equipmentContracts), // Include equipmentContracts
                arbitrationCases: new Map(currentState.arbitrationCases), // Include arbitrationCases
                loans: new Map(currentState.loans), // Include loans
                grants: new Map(currentState.grants), // Include grants
                insurancePolicies: new Map(currentState.insurancePolicies) // Include insurancePolicies
            };

            const eventData = event.data;
            const eventType = event.type;
            const eventId = event.id;

            switch (eventType) {
                case 'POST_AD':
                    newState.classifiedAdBuffer.set(eventId, { ...eventData, status: 'listed', reviews: [] });
                    break;
                case 'MAKE_OFFER':
                    newState.myOffers.set(eventId, eventData);
                    const adForOffer = newState.classifiedAdBuffer.get(eventData.adId);
                    if (adForOffer && adForOffer.sellerClientId === eventData.adPosterClientId) {
                        newState.offersReceived.set(eventId, eventData);
                    }
                    if (adForOffer) {
                        newState.classifiedAdBuffer.set(eventData.adId, {
                            ...adForOffer,
                            latestOffer: eventData
                        });
                    }
                    break;
                case 'ACCEPT_OFFER':
                case 'REJECT_OFFER':
                    const offerToUpdate = newState.myOffers.get(eventId) || newState.offersReceived.get(eventId);
                    if (offerToUpdate) {
                        offerToUpdate.status = eventType === 'ACCEPT_OFFER' ? 'accepted' : 'rejected';
                    }
                    const adAffectedByOffer = newState.classifiedAdBuffer.get(eventData.adId);
                    if (adAffectedByOffer) {
                        if (eventType === 'ACCEPT_OFFER') {
                            adAffectedByOffer.status = adAffectedByOffer.type === 'service' ? 'contract_active' : (adAffectedByOffer.type === 'equipment' ? 'equipment_contract_active' : 'sold');
                            adAffectedByOffer.acceptedOffer = offerToUpdate;
                            if (adAffectedByOffer.type === 'service') {
                                adAffectedByOffer.escrow = {
                                    buyer: offerToUpdate.offerorClientId,
                                    seller: adAffectedByOffer.sellerClientId,
                                    broker: BROKER_ADDRESS,
                                    status: 'pending_full_release',
                                    milestonePayments: new Map(),
                                    totalAmount: offerToUpdate.amount
                                };
                                adAffectedByOffer.milestones.forEach(m => {
                                    adAffectedByOffer.escrow.milestonePayments.set(m.id, {
                                        amount: m.paymentAmount,
                                        status: 'pending',
                                        releaseSignatures: [],
                                        releaseSigners: []
                                    });
                                });
                            } else if (adAffectedByOffer.type === 'equipment') {
                                newState.equipmentContracts.set(adAffectedByOffer.equipmentId, {
                                    equipmentId: adAffectedByOffer.equipmentId,
                                    adId: adAffectedByOffer.id,
                                    sellerClientId: adAffectedByOffer.sellerClientId,
                                    buyerClientId: offerToUpdate.offerorClientId,
                                    currentStatus: adAffectedByOffer.initialStatus,
                                    lifecycleEvents: [{ type: 'contract_initiated', timestamp: Date.now(), actorClientId: myClientId, details: `Contract initiated for ${adAffectedByOffer.equipmentId}` }]
                                });
                            }
                        } else {
                            adAffectedByOffer.status = 'listed';
                            delete adAffectedByOffer.acceptedOffer;
                            delete adAffectedByOffer.escrow;
                        }
                    }
                    break;
                case 'DELEGATE_CONTROL':
                    newState.myDelegations.set(eventId, eventData);
                    if (eventData.delegateeClientId === myClientId) {
                        newState.delegationsReceived.set(eventId, eventData);
                    }
                    break;
                case 'MESSAGING_EVENT':
                    newState.receivedMessages.push(eventData);
                    break;
                case 'KEY_EXCHANGE_PUBLIC_KEY':
                    if (!newState.knownPublicKeys.has(eventData.clientId)) {
                        try {
                            const publicKeyObj = await openpgp.readKey({ armoredKey: eventData.publicKeyArmored });
                            newState.knownPublicKeys.set(eventData.clientId, publicKeyObj);
                            console.log(`Stored public key for ${eventData.clientId}`);
                        } catch (e) {
                            console.error("Failed to parse received OpenPGP public key:", e);
                        }
                    }
                    break;
                case 'UPDATE_MILESTONE_STATUS':
                    const adToUpdateMilestone = newState.classifiedAdBuffer.get(eventData.adContentAddress);
                    if (adToUpdateMilestone && adToUpdateMilestone.type === 'service' && adToUpdateMilestone.milestones) {
                        const milestone = adToUpdateMilestone.milestones.find(m => m.id === eventData.milestoneId);
                        if (milestone) {
                            milestone.status = eventData.newStatus;
                            if (eventData.newStatus === 'pending' || eventData.newStatus === 'in_progress' || eventData.newStatus === 'disputed') {
                                const paymentStatus = adToUpdateMilestone.escrow?.milestonePayments.get(milestone.id);
                                if (paymentStatus) {
                                    paymentStatus.releaseSignatures = [];
                                    paymentStatus.releaseSigners = [];
                                    paymentStatus.status = 'pending';
                                }
                            }
                        }
                    }
                    break;
                case 'SIGN_MILESTONE_APPROVAL':
                    const adForApproval = newState.classifiedAdBuffer.get(eventData.adContentAddress);
                    if (adForApproval && adForApproval.type === 'service' && adForApproval.milestones && adForApproval.escrow) {
                        const milestone = adForApproval.milestones.find(m => m.id === eventData.milestoneId);
                        const paymentStatus = adForApproval.escrow.milestonePayments.get(eventData.milestoneId);
                        if (milestone && paymentStatus && !paymentStatus.releaseSigners.includes(eventData.signerClientId)) {
                            paymentStatus.releaseSignatures.push(event.signature);
                            paymentStatus.releaseSigners.push(eventData.signerClientId);
                            const contractorSigned = paymentStatus.releaseSigners.includes(adForApproval.sellerClientId) ||
                                newState.delegationsReceived.has(adForApproval.sellerClientId) && newState.delegationsReceived.get(adForApproval.sellerClientId).delegateeClientId === eventData.signerClientId;
                            const clientSigned = paymentStatus.releaseSigners.includes(adForApproval.acceptedOffer.offerorClientId) ||
                                newState.delegationsReceived.has(adForApproval.acceptedOffer.offerorClientId) && newState.delegationsReceived.get(adForApproval.acceptedOffer.offerorClientId).delegateeClientId === eventData.signerClientId;
                            if (contractorSigned && clientSigned) {
                                paymentStatus.status = 'released';
                                const allMilestonesReleased = adForApproval.milestones.every(m =>
                                    newState.classifiedAdBuffer.get(eventData.adContentAddress).escrow.milestonePayments.get(m.id)?.status === 'released'
                                );
                                if (allMilestonesReleased) {
                                    adForApproval.status = 'completed';
                                    adForApproval.escrow.status = 'full_release_completed';
                                }
                            }
                        }
                    }
                    break;
                case 'RAISE_DISPUTE': // Generalize dispute
                    const existingCase = newState.arbitrationCases.get(eventId);
                    if (!existingCase) {
                        newState.arbitrationCases.set(eventId, { ...eventData, status: 'pending', arbitratorClientId: BROKER_ADDRESS, decision: null });
                    }
                    break;
                case 'ARBITRATOR_DECISION':
                    const caseToDecide = newState.arbitrationCases.get(eventData.caseId);
                    if (caseToDecide && eventData.arbitratorClientId === BROKER_ADDRESS) { // Only broker can decide
                        caseToDecide.status = eventData.resolution;
                        caseToDecide.decision = eventData.decision;
                        // Conceptual impact on disputed item (for demo, just log)
                        console.log(`Arbitration case ${eventData.caseId} resolved. Disputed item ${caseToDecide.disputedItemId} of type ${caseToDecide.disputedItemType} affected.`);
                        // In a real system, this would trigger further state changes on the disputed item.
                    }
                    break;
                case 'POST_REVIEW':
                    const adToReview = newState.classifiedAdBuffer.get(eventData.adId);
                    if (adToReview) {
                        const isCompletedProduct = adToReview.type === 'product' && adToReview.status === 'sold';
                        const isCompletedService = adToReview.type === 'service' && adToReview.status === 'completed';
                        const isCompletedEquipment = adToReview.type === 'equipment' && adToReview.status === 'equipment_contract_active'; // Assuming review can be left once contract is active
                        if (isCompletedProduct || isCompletedService || isCompletedEquipment) {
                            const existingReview = adToReview.reviews.find(r => r.reviewerClientId === eventData.reviewerClientId);
                            if (!existingReview) {
                                adToReview.reviews.push(eventData);
                            } else {
                                console.warn(`Duplicate review from ${eventData.reviewerClientId} for ad ${eventData.adId}. Ignoring.`);
                            }
                        } else {
                            console.warn(`Review received for uncompleted ad ${eventData.adId}. Status: ${adToReview.status}. Ignoring.`);
                        }
                    }
                    break;
                case 'POST_KNOWLEDGE_NODE':
                    newState.knowledgeGraph.set(eventId, eventData);
                    break;
                case 'POST_COURSE':
                    newState.courses.set(eventId, { ...eventData, participants: new Map() });
                    break;
                case 'ENROLL_COURSE':
                    const courseToEnroll = newState.courses.get(eventData.courseId);
                    if (courseToEnroll && !courseToEnroll.participants.has(eventData.studentClientId)) {
                        courseToEnroll.participants.set(eventData.studentClientId, {
                            status: 'enrolled',
                            progress: new Map(),
                            examScores: new Map(),
                            taskCompletions: new Map(),
                            studentAddress: eventData.studentAddress
                        });
                        courseToEnroll.modules.forEach(module => {
                            module.lessons.forEach(lesson => {
                                courseToEnroll.participants.get(eventData.studentClientId).progress.set(lesson.id, 'not_started');
                            });
                        });
                    }
                    break;
                case 'SUBMIT_EXAM':
                    const courseForExam = newState.courses.get(eventData.courseId);
                    if (courseForExam) {
                        const participant = courseForExam.participants.get(eventData.studentClientId);
                        if (participant) {
                            participant.examScores.set(eventData.examId, eventData.score);
                            const lesson = courseForExam.modules.flatMap(m => m.lessons).find(l => l.examId === eventData.examId);
                            if (lesson) {
                                if (!lesson.taskId) {
                                    participant.progress.set(lesson.id, 'completed');
                                } else {
                                    participant.progress.set(lesson.id, 'exam_submitted');
                                }
                            }
                        }
                    }
                    break;
                case 'STUDENT_ATTEST_TASK':
                    const courseForStudentTask = newState.courses.get(eventData.courseId);
                    if (courseForStudentTask) {
                        const participant = courseForStudentTask.participants.get(eventData.studentClientId);
                        if (participant) {
                            participant.taskCompletions.set(eventData.taskId, {
                                studentAttestation: {
                                    signature: event.signature,
                                    message: JSON.stringify(event.payload.data)
                                },
                                instructorAttestation: null
                            });
                            const lesson = courseForStudentTask.modules.flatMap(m => m.lessons).find(l => l.taskId === eventData.taskId);
                            if (lesson) {
                                if (participant.progress.get(lesson.id) !== 'completed') {
                                    participant.progress.set(lesson.id, 'task_submitted');
                                }
                            }
                        }
                    }
                    break;
                case 'INSTRUCTOR_ATTEST_TASK':
                    const courseForInstructorTask = newState.courses.get(eventData.courseId);
                    if (courseForInstructorTask) {
                        const participant = courseForInstructorTask.participants.get(eventData.studentClientId);
                        if (participant) {
                            const taskCompletion = participant.taskCompletions.get(eventData.taskId);
                            if (taskCompletion && taskCompletion.studentAttestation) {
                                try {
                                    const recoveredStudentAddress = ethers.utils.verifyMessage(
                                        taskCompletion.studentAttestation.message,
                                        taskCompletion.studentAttestation.signature
                                    );
                                    if (recoveredStudentAddress.toLowerCase() === participant.studentAddress.toLowerCase()) {
                                        taskCompletion.instructorAttestation = {
                                            signature: event.signature,
                                            message: JSON.stringify(event.payload.data)
                                        };
                                        const lesson = courseForInstructorTask.modules.flatMap(m => m.lessons).find(l => l.taskId === eventData.taskId);
                                        if (lesson) {
                                            const examCompleted = !lesson.examId || participant.examScores.has(lesson.examId);
                                            const taskCompleted = taskCompletion.studentAttestation && taskCompletion.instructorAttestation;
                                            if (examCompleted && taskCompleted) {
                                                participant.progress.set(lesson.id, 'completed');
                                            }
                                        }
                                    } else {
                                        console.warn(`Instructor attestation for task ${eventData.taskId} failed: Student signature mismatch.`);
                                    }
                                } catch (e) {
                                    console.error(`Error verifying student signature in instructor attestation for task ${eventData.taskId}:`, e);
                                }
                            }
                        }
                    }
                    break;
                case 'MINT_ASSET_TOKEN':
                    if (!newState.assetTokens.has(eventId)) {
                        newState.assetTokens.set(eventId, { ...eventData, ownerClientId: eventData.initialOwnerClientId || eventData.minterClientId, isCollateral: false, isInsured: false });
                    } else {
                        console.warn(`Attempted to mint duplicate asset token ID: ${eventId}. Ignoring.`);
                    }
                    break;
                case 'TRANSFER_ASSET_TOKEN':
                    const tokenToTransfer = newState.assetTokens.get(eventData.tokenId);
                    if (tokenToTransfer && tokenToTransfer.ownerClientId === eventData.fromClientId) {
                        if (tokenToTransfer.isCollateral) {
                            console.warn(`Asset token ${eventData.tokenId} is currently collateral for a loan. Cannot transfer.`);
                            return newState; // Prevent transfer if collateralized
                        }
                        tokenToTransfer.ownerClientId = eventData.toClientId;
                    } else {
                        console.warn(`Attempted to transfer asset token ${eventData.tokenId} by unauthorized client ${eventData.fromClientId} or token not found. Ignoring.`);
                    }
                    break;
                case 'UPDATE_EQUIPMENT_STATUS':
                    const contractToUpdate = newState.equipmentContracts.get(eventData.equipmentId);
                    if (contractToUpdate) {
                        contractToUpdate.currentStatus = eventData.newStatus;
                        contractToUpdate.lifecycleEvents.push({ type: 'status_update', timestamp: Date.now(), actorClientId: eventData.actorClientId, details: `Status changed to ${eventData.newStatus}` });
                    }
                    break;
                case 'ADD_LIFECYCLE_EVENT':
                    const contractForLifecycle = newState.equipmentContracts.get(eventData.equipmentId);
                    if (contractForLifecycle) {
                        contractForLifecycle.lifecycleEvents.push({ type: eventData.eventType, timestamp: Date.now(), actorClientId: eventData.actorClientId, details: eventData.details });
                    }
                    break;

                // --- New Lending & Loans Events ---
                case 'REQUEST_LOAN':
                    if (!newState.loans.has(eventId)) {
                        newState.loans.set(eventId, { ...eventData, status: 'pending', offers: new Map() });
                        const collateralToken = newState.assetTokens.get(eventData.collateralTokenId);
                        if (collateralToken) {
                            collateralToken.isCollateral = true;
                            collateralToken.collateralForLoanId = eventId;
                        }
                    } else {
                        console.warn(`Attempted to request duplicate loan ID: ${eventId}. Ignoring.`);
                    }
                    break;
                case 'OFFER_LOAN':
                    const loanToOffer = newState.loans.get(eventData.loanId);
                    if (loanToOffer && loanToOffer.status === 'pending') {
                        loanToOffer.offers.set(eventId, { ...eventData, status: 'pending' });
                    } else {
                        console.warn(`Attempted to offer on non-pending or non-existent loan ${eventData.loanId}. Ignoring.`);
                    }
                    break;
                case 'ACCEPT_LOAN_OFFER':
                    const loanToAcceptOffer = newState.loans.get(eventData.loanId);
                    if (loanToAcceptOffer && loanToAcceptOffer.borrowerClientId === eventData.actorClientId && loanToAcceptOffer.status === 'pending') {
                        const acceptedOffer = loanToAcceptOffer.offers.get(eventData.offerId);
                        if (acceptedOffer) {
                            loanToAcceptOffer.status = 'active';
                            loanToAcceptOffer.lenderClientId = acceptedOffer.lenderClientId;
                            loanToAcceptOffer.acceptedInterestRate = acceptedOffer.interestRate;
                            loanToAcceptOffer.acceptedOfferId = acceptedOffer.id;
                            // Conceptually transfer collateral ownership to lender
                            const collateralToken = newState.assetTokens.get(loanToAcceptOffer.collateralTokenId);
                            if (collateralToken) {
                                collateralToken.ownerClientId = acceptedOffer.lenderClientId; // Lender now conceptually holds collateral
                                collateralToken.isCollateral = true;
                                collateralToken.collateralForLoanId = loanToAcceptOffer.id;
                            }
                        }
                    } else {
                        console.warn(`Attempted to accept offer on non-pending loan ${eventData.loanId} or by unauthorized client ${eventData.actorClientId}. Ignoring.`);
                    }
                    break;
                case 'REPAY_LOAN':
                    const loanToRepay = newState.loans.get(eventData.loanId);
                    if (loanToRepay && loanToRepay.borrowerClientId === eventData.actorClientId && loanToRepay.status === 'active') {
                        loanToRepay.status = 'repaid';
                        // Transfer collateral back to borrower
                        const collateralToken = newState.assetTokens.get(loanToRepay.collateralTokenId);
                        if (collateralToken) {
                            collateralToken.ownerClientId = loanToRepay.borrowerClientId;
                            collateralToken.isCollateral = false;
                            delete collateralToken.collateralForLoanId;
                        }
                    } else {
                        console.warn(`Attempted to repay non-active loan ${eventData.loanId} or by unauthorized client ${eventData.actorClientId}. Ignoring.`);
                    }
                    break;
                case 'DEFAULT_LOAN':
                    const loanToDefault = newState.loans.get(eventData.loanId);
                    if (loanToDefault && loanToDefault.lenderClientId === eventData.actorClientId && loanToDefault.status === 'active') {
                        loanToDefault.status = 'defaulted';
                        // Collateral already with lender, no change in ownerClientId. Just clear collateral flag.
                        const collateralToken = newState.assetTokens.get(loanToDefault.collateralTokenId);
                        if (collateralToken) {
                            collateralToken.isCollateral = false;
                            delete collateralToken.collateralForLoanId;
                        }
                    } else {
                        console.warn(`Attempted to default non-active loan ${eventData.loanId} or by unauthorized client ${eventData.actorClientId}. Ignoring.`);
                    }
                    break;

                // --- New Grants Events ---
                case 'ISSUE_GRANT':
                    if (!newState.grants.has(eventId)) {
                        newState.grants.set(eventId, { ...eventData, status: 'issued' });
                    } else {
                        console.warn(`Attempted to issue duplicate grant ID: ${eventId}. Ignoring.`);
                    }
                    break;

                // --- New Insurance Events ---
                case 'REQUEST_INSURANCE':
                    if (!newState.insurancePolicies.has(eventId)) {
                        newState.insurancePolicies.set(eventId, { ...eventData, status: 'pending', offers: new Map(), claims: [] });
                        const insuredToken = newState.assetTokens.get(eventData.insuredTokenId);
                        if (insuredToken) {
                            insuredToken.isInsured = true;
                            insuredToken.insuredPolicyId = eventId;
                        }
                    } else {
                        console.warn(`Attempted to request duplicate insurance policy ID: ${eventId}. Ignoring.`);
                    }
                    break;
                case 'OFFER_INSURANCE':
                    const policyToOffer = newState.insurancePolicies.get(eventData.policyId);
                    if (policyToOffer && policyToOffer.status === 'pending') {
                        policyToOffer.offers.set(eventId, { ...eventData, status: 'pending' });
                    } else {
                        console.warn(`Attempted to offer on non-pending or non-existent insurance policy ${eventData.policyId}. Ignoring.`);
                    }
                    break;
                case 'ACCEPT_INSURANCE_OFFER':
                    const policyToAcceptOffer = newState.insurancePolicies.get(eventData.policyId);
                    if (policyToAcceptOffer && policyToAcceptOffer.insuredClientId === eventData.actorClientId && policyToAcceptOffer.status === 'pending') {
                        const acceptedOffer = policyToAcceptOffer.offers.get(eventData.offerId);
                        if (acceptedOffer) {
                            policyToAcceptOffer.status = 'active';
                            policyToAcceptOffer.insurerClientId = acceptedOffer.insurerClientId;
                            policyToAcceptOffer.acceptedPremium = acceptedOffer.premiumAmount;
                            policyToAcceptOffer.acceptedOfferId = acceptedOffer.id;
                            policyToAcceptOffer.expiryDate = acceptedOffer.expiryDate;
                        }
                    } else {
                        console.warn(`Attempted to accept offer on non-pending insurance policy ${eventData.policyId} or by unauthorized client ${eventData.actorClientId}. Ignoring.`);
                    }
                    break;
                case 'SUBMIT_INSURANCE_CLAIM':
                    const policyToClaim = newState.insurancePolicies.get(eventData.policyId);
                    if (policyToClaim && policyToClaim.insuredClientId === eventData.actorClientId && policyToClaim.status === 'active') {
                        policyToClaim.claims.push({ ...eventData, claimStatus: 'pending_review' });
                        policyToClaim.status = 'claimed'; // Policy moves to claimed state
                    } else {
                        console.warn(`Attempted to submit claim on non-active policy ${eventData.policyId} or by unauthorized client ${eventData.actorClientId}. Ignoring.`);
                    }
                    break;
                case 'APPROVE_INSURANCE_CLAIM':
                    const policyToApproveClaim = newState.insurancePolicies.get(eventData.policyId);
                    if (policyToApproveClaim && policyToApproveClaim.insurerClientId === eventData.actorClientId) {
                        const claimToApprove = policyToApproveClaim.claims.find(c => c.claimId === eventData.claimId);
                        if (claimToApprove) {
                            claimToApprove.claimStatus = 'approved';
                            policyToApproveClaim.status = 'resolved'; // Policy resolved after claim approval
                        }
                    } else {
                        console.warn(`Attempted to approve claim on policy ${eventData.policyId} by unauthorized client ${eventData.actorClientId}. Ignoring.`);
                    }
                    break;
                case 'REJECT_INSURANCE_CLAIM':
                    const policyToRejectClaim = newState.insurancePolicies.get(eventData.policyId);
                    if (policyToRejectClaim && policyToRejectClaim.insurerClientId === eventData.actorClientId) {
                        const claimToReject = policyToRejectClaim.claims.find(c => c.claimId === eventData.claimId);
                        if (claimToReject) {
                            claimToReject.claimStatus = 'rejected';
                            policyToRejectClaim.status = 'active'; // Policy can remain active if rejected
                        }
                    } else {
                        console.warn(`Attempted to reject claim on policy ${eventData.policyId} by unauthorized client ${eventData.actorClientId}. Ignoring.`);
                    }
                    break;
            }
            return newState;
        }

        async function updateUIFromState() {
            // My Ads List
            const myAdsHtml = Array.from(classifiedAdBuffer.values())
                .filter(ad => ad.sellerClientId === myClientId)
                .map(ad => `<div class="log-entry"><strong>${ad.title}</strong> (ID: ${ad.id}) - ${ad.price} UBHP, Type: ${ad.type || 'product'}, Status: ${ad.status || 'active'}</div>`)
                .join('');
            document.getElementById('myAdsList').innerHTML = myAdsHtml || '<p>No ads posted yet.</p>';

            // My Offers List
            const myOffersHtml = Array.from(myOffers.values())
                .map(offer => `<div class="log-entry">Offer ${offer.amount} UBHP for Ad ID ${offer.adId} (Status: ${offer.status || 'pending'})</div>`)
                .join('');
            document.getElementById('myOffersList').innerHTML = myOffersHtml || '<p>No offers made yet.</p>';

            // Offers Received List
            const offersReceivedHtml = Array.from(offersReceived.values())
                .map(offer => {
                    const ad = classifiedAdBuffer.get(offer.adId);
                    const adTitle = ad ? ad.title : 'Unknown Ad';
                    return `
                        <div class="log-entry">
                            Offer <strong>${offer.amount} UBHP</strong> from <strong>${offer.offerorClientId.substring(0,10)}...</strong> for Ad: ${adTitle} (Status: ${offer.status || 'pending'})
                            ${offer.status === 'pending' ? `
                                <button onclick="acceptOffer('${offer.id}', '${offer.adId}')" class="btn-secondary">Accept</button>
                                <button onclick="rejectOffer('${offer.id}', '${offer.adId}')" class="btn-danger">Reject</button>
                            ` : ''}
                        </div>
                    `;
                })
                .join('');
            document.getElementById('offersReceivedList').innerHTML = offersReceivedHtml || '<p>No offers received yet.</p>';

            // My Delegations List
            const myDelegationsHtml = Array.from(myDelegations.values())
                .map(del => `<div class="log-entry">Delegated <strong>${del.delegatedItemId}</strong> to <strong>${del.delegateeClientId.substring(0,10)}...</strong> for authority type <strong>${del.authorityType}</strong> until ${new Date(del.expiry).toLocaleString()}</div>`)
                .join('');
            document.getElementById('myDelegationsList').innerHTML = myDelegationsHtml || '<p>No delegations created yet.</p>';

            // Delegations Received List
            const delegationsReceivedHtml = Array.from(delegationsReceived.values())
                .map(del => `<div class="log-entry">Received delegation for <strong>${del.delegatedItemId}</strong> from <strong>${del.delegatorClientId.substring(0,10)}...</strong> for authority type <strong>${del.authorityType}</strong> until ${new Date(del.expiry).toLocaleString()}</div>`)
                .join('');
            document.getElementById('delegationsReceivedList').innerHTML = delegationsReceivedHtml || '<p>No delegations received yet.</p>';

            // Marketplace Feed
            const feedHtml = Array.from(classifiedAdBuffer.values()).map(ad => {
                let offerInfo = '';
                if (ad.latestOffer) {
                    offerInfo = ` (Latest Offer: ${ad.latestOffer.amount} by ${ad.latestOffer.offerorClientId.substring(0,10)}...)`;
                }
                return `<div class="log-entry">Ad: <strong>${ad.title}</strong> - ${ad.price} UBHP by ${ad.sellerClientId.substring(0,10)}... (Type: ${ad.type || 'product'}, Status: ${ad.status || 'active'})${offerInfo}</div>`;
            }).join('');
            document.getElementById('marketplaceFeed').innerHTML = feedHtml || '<p>No marketplace activity yet.</p>';

            // My Services (Contracts) List
            const myServiceContractsHtml = Array.from(classifiedAdBuffer.values())
                .filter(ad => ad.type === 'service' && ad.status === 'contract_active' && ad.sellerClientId === myClientId)
                .map(ad => {
                    let milestonesHtml = ad.milestones.map(m => {
                        const paymentStatus = ad.escrow?.milestonePayments.get(m.id);
                        const signersCount = paymentStatus ? paymentStatus.releaseSigners.length : 0;
                        const paymentStatusText = paymentStatus ? ` (${paymentStatus.status.replace('_', ' ').toUpperCase()} - Signatures: ${signersCount}/2)` : '';
                        const isCompleted = m.status === 'completed';
                        const isDisputed = m.status === 'disputed';
                        const isReleased = paymentStatus?.status === 'released';
                        return `
                            <div class="milestone-entry ${isCompleted ? 'completed' : ''} ${isDisputed ? 'disputed' : ''}">
                                <span>${m.description} (${m.paymentAmount} UBHP) - Status: ${m.status}${paymentStatusText}</span>
                                <div>
                                    <button onclick="updateMilestoneStatus('${ad.id}', '${m.id}', 'in_progress')" ${isCompleted || isDisputed ? 'disabled' : ''} class="btn-secondary">Mark In Progress</button>
                                    <button onclick="updateMilestoneStatus('${ad.id}', '${m.id}', 'completed')" ${isCompleted || isDisputed ? 'disabled' : ''} class="btn-primary">Mark Completed</button>
                                    <button onclick="signMilestoneApproval('${ad.id}', '${m.id}')" ${isReleased || isDisputed || !isCompleted ? 'disabled' : ''} class="btn-secondary">Sign Approval</button>
                                    <button onclick="raiseArbitrationRequest('${ad.id}', '${m.id}', 'ad')" ${isDisputed ? 'disabled' : ''} class="btn-danger">Raise Dispute</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                    return `
                        <div class="log-entry">
                            <h3>Contract: ${ad.title} (Ad ID: ${ad.id})</h3>
                            <p>Client: ${ad.acceptedOffer.offerorClientId.substring(0,10)}...</p>
                            <p>Total Amount: ${ad.acceptedOffer.amount} UBHP</p>
                            <h4>Milestones:</h4>
                            ${milestonesHtml}
                        </div>
                    `;
                }).join('');
            document.getElementById('myServiceContractsList').innerHTML = myServiceContractsHtml || '<p>No active service contracts where you are the contractor.</p>';

            // Services I'm Buying (Contracts) List
            const myBuyingContractsHtml = Array.from(classifiedAdBuffer.values())
                .filter(ad => ad.type === 'service' && ad.status === 'contract_active' && ad.acceptedOffer?.offerorClientId === myClientId)
                .map(ad => {
                    let milestonesHtml = ad.milestones.map(m => {
                        const paymentStatus = ad.escrow?.milestonePayments.get(m.id);
                        const signersCount = paymentStatus ? paymentStatus.releaseSigners.length : 0;
                        const paymentStatusText = paymentStatus ? ` (${paymentStatus.status.replace('_', ' ').toUpperCase()} - Signatures: ${signersCount}/2)` : '';
                        const isCompleted = m.status === 'completed';
                        const isDisputed = m.status === 'disputed';
                        const isReleased = paymentStatus?.status === 'released';
                        return `
                            <div class="milestone-entry ${isCompleted ? 'completed' : ''} ${isDisputed ? 'disputed' : ''}">
                                <span>${m.description} (${m.paymentAmount} UBHP) - Status: ${m.status}${paymentStatusText}</span>
                                <div>
                                    <button onclick="signMilestoneApproval('${ad.id}', '${m.id}')" ${isReleased || isDisputed || !isCompleted ? 'disabled' : ''} class="btn-secondary">Approve Completion</button>
                                    <button onclick="raiseArbitrationRequest('${ad.id}', '${m.id}', 'ad')" ${isDisputed ? 'disabled' : ''} class="btn-danger">Raise Dispute</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                    return `
                        <div class="log-entry">
                            <h3>Contract: ${ad.title} (Ad ID: ${ad.id})</h3>
                            <p>Contractor: ${ad.sellerClientId.substring(0,10)}...</p>
                            <p>Total Amount: ${ad.acceptedOffer.amount} UBHP</p>
                            <h4>Milestones:</h4>
                            ${milestonesHtml}
                        </div>
                    `;
                }).join('');
            document.getElementById('myBuyingContractsList').innerHTML = myBuyingContractsHtml || '<p>No active service contracts where you are the client.</p>';

            // My Equipment Contracts List
            const myEquipmentContractsHtml = Array.from(equipmentContracts.values())
                .filter(contract => contract.sellerClientId === myClientId || contract.buyerClientId === myClientId)
                .map(contract => {
                    const ad = classifiedAdBuffer.get(contract.adId);
                    const equipmentTitle = ad ? ad.title : `Equipment ${contract.equipmentId}`;
                    const isMyContract = contract.sellerClientId === myClientId;
                    const otherParty = isMyContract ? contract.buyerClientId : contract.sellerClientId;
                    let lifecycleEventsHtml = contract.lifecycleEvents.map(event => `
                        <li>${event.type.replace('_', ' ').toUpperCase()}: ${event.details} (by ${event.actorClientId.substring(0,10)}... at ${new Date(event.timestamp).toLocaleString()})</li>
                    `).join('');
                    return `
                        <div class="equipment-entry">
                            <h3>Contract for: ${equipmentTitle} (ID: ${contract.equipmentId})</h3>
                            <p>Current Status: <strong>${contract.currentStatus.toUpperCase()}</strong></p>
                            <p>${isMyContract ? 'Buyer' : 'Seller'}: ${otherParty.substring(0,10)}...</p>
                            <h4>Lifecycle Events:</h4>
                            <ul>${lifecycleEventsHtml || '<li>No events yet.</li>'}</ul>
                            <label for="newStatus_${contract.equipmentId}">Update Status:</label>
                            <input type="text" id="newStatus_${contract.equipmentId}" placeholder="e.g., in_maintenance">
                            <button onclick="updateEquipmentStatus('${contract.equipmentId}')" class="btn-secondary">Update Status</button>
                            <label for="newLifecycleEvent_${contract.equipmentId}">Add Lifecycle Event (Type:Details):</label>
                            <input type="text" id="newLifecycleEvent_${contract.equipmentId}" placeholder="e.g., serviced:Replaced filter">
                            <button onclick="addLifecycleEvent('${contract.equipmentId}')" class="btn-secondary">Add Event</button>
                            <button onclick="raiseArbitrationRequest('${contract.equipmentId}', 'equipment_contract')" class="btn-danger">Raise Dispute</button>
                        </div>
                    `;
                }).join('');
            document.getElementById('myEquipmentContractsList').innerHTML = myEquipmentContractsHtml || '<p>No active equipment contracts.</p>';

            // My Owned Assets List
            const myOwnedAssetsHtml = Array.from(assetTokens.values())
                .filter(token => token.ownerClientId === myClientId)
                .map(token => `
                    <div class="asset-token-entry">
                        <strong>${token.description}</strong> (ID: ${token.id})<br>
                        <small>Minter: ${token.minterClientId.substring(0,10)}...</small><br>
                        ${token.isCollateral ? `<small style="color: red;">(Collateral for Loan: ${token.collateralForLoanId.substring(0,10)}...)</small><br>` : ''}
                        ${token.isInsured ? `<small style="color: green;">(Insured by Policy: ${token.insuredPolicyId.substring(0,10)}...)</small><br>` : ''}
                    </div>
                `).join('');
            document.getElementById('myOwnedAssetsList').innerHTML = myOwnedAssetsHtml || '<p>No assets owned yet.</p>';

            // --- New UI Updates for Lending & Loans ---
            // My Active Loans (as Borrower)
            const myActiveLoansHtml = Array.from(loans.values())
                .filter(loan => loan.borrowerClientId === myClientId && (loan.status === 'active' || loan.status === 'pending'))
                .map(loan => `
                    <div class="loan-entry">
                        <strong>Loan ID: ${loan.id}</strong><br>
                        Amount: ${loan.amount} UBHP<br>
                        Collateral: ${loan.collateralTokenId}<br>
                        Interest: ${loan.acceptedInterestRate || loan.interestRate}%<br>
                        Due: ${new Date(loan.repaymentDueDate).toLocaleDateString()}<br>
                        Status: <strong>${loan.status.toUpperCase()}</strong><br>
                        ${loan.lenderClientId ? `Lender: ${loan.lenderClientId.substring(0,10)}...<br>` : ''}
                        ${loan.status === 'active' ? `<button onclick="repayLoan('${loan.id}')" class="btn-primary">Repay</button>` : ''}
                        <button onclick="raiseArbitrationRequest('${loan.id}', 'loan')" class="btn-danger">Raise Dispute</button>
                    </div>
                `).join('');
            document.getElementById('myActiveLoansList').innerHTML = myActiveLoansHtml || '<p>No active loans as borrower.</p>';

            // Loans I've Offered/Funded (as Lender)
            const loansOfferedHtml = Array.from(loans.values())
                .filter(loan => loan.lenderClientId === myClientId && (loan.status === 'active' || loan.status === 'defaulted'))
                .map(loan => `
                    <div class="loan-entry">
                        <strong>Loan ID: ${loan.id}</strong><br>
                        Amount: ${loan.amount} UBHP<br>
                        Collateral: ${loan.collateralTokenId}<br>
                        Interest: ${loan.acceptedInterestRate || loan.interestRate}%<br>
                        Due: ${new Date(loan.repaymentDueDate).toLocaleDateString()}<br>
                        Status: <strong>${loan.status.toUpperCase()}</strong><br>
                        Borrower: ${loan.borrowerClientId.substring(0,10)}...<br>
                        ${loan.status === 'active' ? `<button onclick="declareLoanDefault('${loan.id}')" class="btn-danger">Declare Default</button>` : ''}
                        <button onclick="raiseArbitrationRequest('${loan.id}', 'loan')" class="btn-danger">Raise Dispute</button>
                    </div>
                `).join('');
            document.getElementById('loansOfferedList').innerHTML = loansOfferedHtml || '<p>No loans offered/funded.</p>';

            // Pending Loan Requests (for Lenders)
            const pendingLoanRequestsHtml = Array.from(loans.values())
                .filter(loan => loan.status === 'pending' && loan.borrowerClientId !== myClientId)
                .map(loan => {
                    const myOffer = Array.from(loan.offers.values()).find(offer => offer.lenderClientId === myClientId);
                    return `
                        <div class="loan-entry">
                            <strong>Loan ID: ${loan.id}</strong><br>
                            Borrower: ${loan.borrowerClientId.substring(0,10)}...<br>
                            Amount: ${loan.amount} UBHP<br>
                            Collateral: ${loan.collateralTokenId}<br>
                            Requested Interest: ${loan.interestRate}%<br>
                            Due: ${new Date(loan.repaymentDueDate).toLocaleDateString()}<br>
                            ${myOffer ? `Your Offer: ${myOffer.interestRate}% (Status: ${myOffer.status})` : `
                                <label for="offerInterestRate_${loan.id}">Your Interest Offer (%):</label>
                                <input type="number" id="offerInterestRate_${loan.id}" step="0.01" value="${loan.interestRate}">
                                <button onclick="offerLoan('${loan.id}')" class="btn-secondary">Offer Loan</button>
                            `}
                            <button onclick="raiseArbitrationRequest('${loan.id}', 'loan')" class="btn-danger">Raise Dispute</button>
                        </div>
                    `;
                }).join('');
            document.getElementById('pendingLoanRequestsList').innerHTML = pendingLoanRequestsHtml || '<p>No pending loan requests.</p>';

            // --- New UI Updates for Grants ---
            // My Issued Grants
            const myIssuedGrantsHtml = Array.from(grants.values())
                .filter(grant => grant.grantorClientId === myClientId)
                .map(grant => `
                    <div class="grant-entry">
                        <strong>Grant ID: ${grant.id}</strong><br>
                        Recipient: ${grant.recipientClientId.substring(0,10)}...<br>
                        Amount: ${grant.amount} UBHP<br>
                        Description: ${grant.description}<br>
                        Status: <strong>${grant.status.toUpperCase()}</strong><br>
                        <button onclick="raiseArbitrationRequest('${grant.id}', 'grant')" class="btn-danger">Raise Dispute</button>
                    </div>
                `).join('');
            document.getElementById('myIssuedGrantsList').innerHTML = myIssuedGrantsHtml || '<p>No grants issued yet.</p>';

            // My Received Grants
            const myReceivedGrantsHtml = Array.from(grants.values())
                .filter(grant => grant.recipientClientId === myClientId)
                .map(grant => `
                    <div class="grant-entry">
                        <strong>Grant ID: ${grant.id}</strong><br>
                        Grantor: ${grant.grantorClientId.substring(0,10)}...<br>
                        Amount: ${grant.amount} UBHP<br>
                        Description: ${grant.description}<br>
                        Status: <strong>${grant.status.toUpperCase()}</strong><br>
                        <button onclick="raiseArbitrationRequest('${grant.id}', 'grant')" class="btn-danger">Raise Dispute</button>
                    </div>
                `).join('');
            document.getElementById('myReceivedGrantsList').innerHTML = myReceivedGrantsHtml || '<p>No grants received yet.</p>';

            // --- New UI Updates for Insurance ---
            // My Active Insurance Policies (as Insured)
            const myActiveInsurancePoliciesHtml = Array.from(insurancePolicies.values())
                .filter(policy => policy.insuredClientId === myClientId && (policy.status === 'active' || policy.status === 'claimed'))
                .map(policy => {
                    const claimsHtml = policy.claims.map(claim => `
                        <li>Claim ID: ${claim.claimId.substring(0,10)}... - Details: ${claim.claimDetails} - Status: <strong>${claim.claimStatus.toUpperCase()}</strong></li>
                    `).join('');
                    return `
                        <div class="insurance-policy-entry">
                            <strong>Policy ID: ${policy.id}</strong><br>
                            Insured Token: ${policy.insuredTokenId}<br>
                            Coverage: ${policy.coverageAmount} UBHP<br>
                            Premium: ${policy.acceptedPremium || policy.premiumAmount} UBHP<br>
                            Status: <strong>${policy.status.toUpperCase()}</strong><br>
                            ${policy.insurerClientId ? `Insurer: ${policy.insurerClientId.substring(0,10)}...<br>` : ''}
                            Expiry: ${new Date(policy.expiryDate).toLocaleDateString()}<br>
                            <h4>Claims:</h4>
                            <ul>${claimsHtml || '<li>No claims yet.</li>'}</ul>
                            ${policy.status === 'active' ? `<button onclick="submitInsuranceClaim('${policy.id}')" class="btn-primary">Submit Claim</button>` : ''}
                            <button onclick="raiseArbitrationRequest('${policy.id}', 'insurance_policy')" class="btn-danger">Raise Dispute</button>
                        </div>
                    `;
                }).join('');
            document.getElementById('myActiveInsurancePoliciesList').innerHTML = myActiveInsurancePoliciesHtml || '<p>No active insurance policies.</p>';

            // Policies I've Underwritten (as Insurer)
            const policiesUnderwrittenHtml = Array.from(insurancePolicies.values())
                .filter(policy => policy.insurerClientId === myClientId && (policy.status === 'active' || policy.status === 'claimed' || policy.status === 'resolved'))
                .map(policy => {
                    const claimsHtml = policy.claims.map(claim => `
                        <li>Claim ID: ${claim.claimId.substring(0,10)}... - Details: ${claim.claimDetails} - Status: <strong>${claim.claimStatus.toUpperCase()}</strong>
                            ${claim.claimStatus === 'pending_review' ? `
                                <button onclick="approveInsuranceClaim('${policy.id}', '${claim.claimId}')" class="btn-secondary">Approve</button>
                                <button onclick="rejectInsuranceClaim('${policy.id}', '${claim.claimId}')" class="btn-danger">Reject</button>
                            ` : ''}
                        </li>
                    `).join('');
                    return `
                        <div class="insurance-policy-entry">
                            <strong>Policy ID: ${policy.id}</strong><br>
                            Insured Client: ${policy.insuredClientId.substring(0,10)}...<br>
                            Insured Token: ${policy.insuredTokenId}<br>
                            Coverage: ${policy.coverageAmount} UBHP<br>
                            Premium: ${policy.acceptedPremium || policy.premiumAmount} UBHP<br>
                            Status: <strong>${policy.status.toUpperCase()}</strong><br>
                            Expiry: ${new Date(policy.expiryDate).toLocaleDateString()}<br>
                            <h4>Claims:</h4>
                            <ul>${claimsHtml || '<li>No claims yet.</li>'}</ul>
                            <button onclick="raiseArbitrationRequest('${policy.id}', 'insurance_policy')" class="btn-danger">Raise Dispute</button>
                        </div>
                    `;
                }).join('');
            document.getElementById('policiesUnderwrittenList').innerHTML = policiesUnderwrittenHtml || '<p>No policies underwritten.</p>';

            // Pending Insurance Requests (for Insurers)
            const pendingInsuranceRequestsHtml = Array.from(insurancePolicies.values())
                .filter(policy => policy.status === 'pending' && policy.insuredClientId !== myClientId)
                .map(policy => {
                    const myOffer = Array.from(policy.offers.values()).find(offer => offer.insurerClientId === myClientId);
                    return `
                        <div class="insurance-policy-entry">
                            <strong>Policy ID: ${policy.id}</strong><br>
                            Insured Client: ${policy.insuredClientId.substring(0,10)}...<br>
                            Insured Token: ${policy.insuredTokenId}<br>
                            Coverage Requested: ${policy.coverageAmount} UBHP<br>
                            Premium Requested: ${policy.premiumAmount} UBHP<br>
                            Duration: ${policy.policyDurationDays} days<br>
                            ${myOffer ? `Your Offer: ${myOffer.premiumAmount} UBHP (Status: ${myOffer.status})` : `
                                <label for="offerPremiumAmount_${policy.id}">Your Premium Offer (UBHP):</label>
                                <input type="number" id="offerPremiumAmount_${policy.id}" value="${policy.premiumAmount}">
                                <button onclick="offerInsurance('${policy.id}')" class="btn-secondary">Offer Insurance</button>
                            `}
                            <button onclick="raiseArbitrationRequest('${policy.id}', 'insurance_policy')" class="btn-danger">Raise Dispute</button>
                        </div>
                    `;
                }).join('');
            document.getElementById('pendingInsuranceRequestsList').innerHTML = pendingInsuranceRequestsHtml || '<p>No pending insurance requests.</p>';

            // My Reviews Left
            const myReviewsHtml = Array.from(classifiedAdBuffer.values())
                .filter(ad => ad.reviews && ad.reviews.some(r => r.reviewerClientId === myClientId))
                .map(ad => ad.reviews.filter(r => r.reviewerClientId === myClientId)
                    .map(review => `
                        <div class="review-entry">
                            <strong>Ad:</strong> ${ad.title} (ID: ${ad.id})<br>
                            <strong>Rating:</strong> ${review.rating} / 5 <br>
                            <strong>Comment:</strong> ${review.comment} <br>
                            <small>Reviewed for: ${review.targetClientId.substring(0,10)}... at ${new Date(review.timestamp).toLocaleString()}</small>
                        </div>
                    `).join('')
                ).join('');
            document.getElementById('myReviewsList').innerHTML = myReviewsHtml || '<p>No reviews left yet.</p>';

            // All Knowledge Nodes
            const allKnowledgeNodesHtml = Array.from(knowledgeGraph.values())
                .map(node => `
                    <div class="knowledge-node-entry">
                        <strong>${node.title}</strong> <span class="node-id">(ID: ${node.id})</span><br>
                        ${node.content}<br>
                        <span class="tags">Tags: ${node.tags.join(', ')}</span><br>
                        <small>By: ${node.authorClientId.substring(0,10)}... at ${new Date(node.timestamp).toLocaleString()}</small>
                        ${node.previousNodeId ? `<br><small>Previous Node: ${node.previousNodeId}</small>` : ''}
                        <button onclick="raiseArbitrationRequest('${node.id}', 'knowledge_node')" class="btn-danger">Raise Dispute</button>
                    </div>
                `).join('');
            document.getElementById('allKnowledgeNodesList').innerHTML = allKnowledgeNodesHtml || '<p>No knowledge nodes posted yet.</p>';

            // My Authored Courses
            const myAuthoredCoursesHtml = Array.from(courses.values())
                .filter(course => course.authorClientId === myClientId)
                .map(course => {
                    let modulesHtml = course.modules.map(module => `
                        <div class="module-section">
                            <h4>Module: ${module.title}</h4>
                            ${module.lessons.map(lesson => `
                                <div class="lesson-section">
                                    <h5>Lesson: ${lesson.title}</h5>
                                    <p>${lesson.content}</p>
                                    ${lesson.examId ? `<p>Exam ID: ${lesson.examId} <button onclick="raiseArbitrationRequest('${lesson.examId}', 'exam')" class="btn-danger">Dispute Exam</button></p>` : ''}
                                    ${lesson.taskId ? `<p>Task ID: ${lesson.taskId} <button onclick="raiseArbitrationRequest('${lesson.taskId}', 'task')" class="btn-danger">Dispute Task</button></p>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `).join('');
                    return `
                        <div class="course-section">
                            <h3>Course: ${course.title} (ID: ${course.id})</h3>
                            <p>${course.description}</p>
                            ${modulesHtml}
                            <button onclick="raiseArbitrationRequest('${course.id}', 'course')" class="btn-danger">Dispute Course</button>
                        </div>
                    `;
                }).join('');
            document.getElementById('myAuthoredCoursesList').innerHTML = myAuthoredCoursesHtml || '<p>No courses authored yet.</p>';

            // Available Courses
            const availableCoursesHtml = Array.from(courses.values())
                .filter(course => course.authorClientId !== myClientId && !course.participants.has(myClientId))
                .map(course => `
                    <div class="course-section">
                        <h3>Course: ${course.title} (ID: ${course.id})</h3>
                        <p>${course.description}</p>
                        <p>Author: ${course.authorClientId.substring(0,10)}...</p>
                        <button onclick="enrollInCourse('${course.id}')" class="btn-primary">Enroll</button>
                    </div>
                `).join('');
            document.getElementById('availableCoursesList').innerHTML = availableCoursesHtml || '<p>No courses available for enrollment.</p>';

            // My Enrolled Courses
            const myEnrolledCoursesHtml = Array.from(courses.values())
                .filter(course => course.participants.has(myClientId))
                .map(course => {
                    const participant = course.participants.get(myClientId);
                    let modulesHtml = course.modules.map(module => `
                        <div class="module-section">
                            <h4>Module: ${module.title}</h4>
                            ${module.lessons.map(lesson => {
                                const lessonStatus = participant.progress.get(lesson.id) || 'not_started';
                                const examScore = participant.examScores.get(lesson.examId);
                                const taskCompletion = participant.taskCompletions.get(lesson.taskId);
                                const isInstructorOrDelegate = course.authorClientId === myClientId ||
                                    [...delegationsReceived.values()].some(d => d.delegatorClientId === course.authorClientId && d.delegateeClientId === myClientId && d.authorityType === 'ATTEST_TASK');
                                return `
                                    <div class="lesson-section">
                                        <h5>Lesson: ${lesson.title} (Status: <strong>${lessonStatus.replace('_', ' ').toUpperCase()}</strong>)</h5>
                                        <p>${lesson.content}</p>
                                        ${lesson.examId ? `
                                            <div class="exam-question">
                                                <p><strong>Exam:</strong> ${course.exams.find(e => e.id === lesson.examId).questions[0]}</p>
                                                ${examScore !== undefined ? `<p>Your Score: ${examScore}%</p>` : `
                                                    <input type="text" id="examAnswer_${lesson.id}" placeholder="Your answer">
                                                    <button onclick="submitExam('${course.id}', '${lesson.id}', '${lesson.examId}')" ${lessonStatus === 'completed' ? 'disabled' : ''} class="btn-secondary">Submit Exam</button>
                                                `}
                                            </div>
                                        ` : ''}
                                        ${lesson.taskId ? `
                                            <div class="task-item">
                                                <p><strong>Task:</strong> ${course.tasks.find(t => t.id === lesson.taskId).description}</p>
                                                ${taskCompletion?.studentAttestation ? `<p>Student Attestation: Signed</p>` : `
                                                    <button onclick="studentAttestTask('${course.id}', '${lesson.id}', '${lesson.taskId}')" ${lessonStatus === 'completed' ? 'disabled' : ''} class="btn-secondary">Submit Task (Attest)</button>
                                                `}
                                                ${taskCompletion?.instructorAttestation ? `<p>Instructor Attestation: Signed</p>` : ''}
                                                ${isInstructorOrDelegate && taskCompletion?.studentAttestation && !taskCompletion?.instructorAttestation ? `
                                                    <button onclick="instructorAttestTask('${course.id}', '${lesson.id}', '${lesson.taskId}', '${participant.studentClientId}', '${participant.studentAddress}')" class="btn-primary">Attest Completion</button>
                                                ` : ''}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `).join('');
                    return `
                        <div class="course-section">
                            <h3>Course: ${course.title} (ID: ${course.id})</h3>
                            <p>Author: ${course.authorClientId.substring(0,10)}...</p>
                            <div class="course-participant-progress">
                                <h4>Your Progress:</h4>
                                ${modulesHtml}
                            </div>
                        </div>
                    `;
                }).join('');
            document.getElementById('myEnrolledCoursesList').innerHTML = myEnrolledCoursesHtml || '<p>No courses enrolled yet.</p>';

            // Arbitration Cases List
            const arbitrationCasesHtml = Array.from(arbitrationCases.values())
                .map(caseItem => `
                    <div class="arbitration-case-entry">
                        <strong>Case ID: ${caseItem.caseId}</strong><br>
                        <strong>Disputed Item:</strong> ${caseItem.disputedItemType} (ID: ${caseItem.disputedItemId})<br>
                        <strong>Plaintiff:</strong> ${caseItem.plaintiffClientId.substring(0,10)}...<br>
                        <strong>Defendant:</strong> ${caseItem.defendantClientId.substring(0,10)}...<br>
                        <strong>Reason:</strong> ${caseItem.reason}<br>
                        <strong>Status:</strong> <strong>${caseItem.status.toUpperCase()}</strong><br>
                        ${caseItem.decision ? `<strong>Decision:</strong> ${caseItem.decision}<br>` : ''}
                        <small>Raised at: ${new Date(caseItem.timestamp).toLocaleString()}</small>
                    </div>
                `).join('');
            document.getElementById('arbitrationCasesList').innerHTML = arbitrationCasesHtml || '<p>No arbitration cases.</p>';

            // Received Messages Log
            const messagesHtml = receivedMessages.map(msg => {
                let status = msg.decrypted ? 'Decrypted' : (msg.encryptionType === 'public' ? 'Public' : 'Encrypted (failed to decrypt or not for you)');
                return `<div class="message-entry">
                            <strong>From:</strong> ${msg.senderClientId.substring(0,10)}... <br>
                            <strong>Type:</strong> ${msg.encryptionType} (${status}) <br>
                            <strong>Content:</strong> ${msg.content || '[Encrypted or Failed Decryption]'} <br>
                            <small>${new Date(msg.timestamp).toLocaleString()}</small>
                        </div>`;
            }).reverse().join('');
            document.getElementById('receivedMessagesLog').innerHTML = messagesHtml || '<p>No messages received yet.</p>';

            // Known Public Keys Display
            const knownKeysHtml = Array.from(knownPublicKeys.keys())
                .map(clientId => `<div>${clientId.substring(0,10)}...</div>`)
                .join('');
            document.getElementById('knownPublicKeysDisplay').innerHTML = knownKeysHtml || '<p>No public keys added yet.</p>';

            // Update broker address display
            document.getElementById('brokerAddressDisplay').textContent = BROKER_ADDRESS;
            document.getElementById('brokerAddressDisplay2').textContent = BROKER_ADDRESS;

            // Enable arbitrator decision button if current client is the conceptual broker
            if (myAddress && myAddress.toLowerCase() === BROKER_ADDRESS.toLowerCase()) {
                document.getElementById('arbitratorDecisionButton').disabled = false;
            } else {
                document.getElementById('arbitratorDecisionButton').disabled = true;
            }
        }

        // Helper to sign and publish data
        async function signAndPublish(topic, data, actionType, eventId = crypto.randomUUID()) {
            if (!signer || !mqttClient) {
                alert("Wallet not loaded or MQTT not connected.");
                return;
            }
            const payload = {
                id: eventId,
                type: actionType,
                data: data,
                timestamp: Date.now(),
                senderClientId: myClientId,
                senderAddress: myAddress,
            };
            const payloadString = JSON.stringify(payload);
            const signature = await signer.signMessage(payloadString);
            const signedMessage = {
                payload: payload,
                signature: signature
            };
            mqttClient.publish(topic, JSON.stringify(signedMessage), { qos: 1 }, (error) => {
                if (error) {
                    console.error("MQTT Publish error:", error);
                    appendLog("Error publishing message.", 'error');
                } else {
                    console.log(`Published to ${topic}:`, signedMessage);
                    applyLocalStateUpdate(payload);
                }
            });
        }

        async function applyLocalStateUpdate(eventPayload) {
            const newState = await marketplaceStateReducer({
                classifiedAdBuffer, myOffers, offersReceived,
                myDelegations, delegationsReceived, receivedMessages, knownPublicKeys, knowledgeGraph, courses,
                assetTokens, equipmentContracts, arbitrationCases,
                loans, grants, insurancePolicies // Pass new state variables
            }, eventPayload);

            classifiedAdBuffer = newState.classifiedAdBuffer;
            myOffers = newState.myOffers;
            offersReceived = newState.offersReceived;
            myDelegations = newState.myDelegations;
            delegationsReceived = newState.delegationsReceived;
            receivedMessages = newState.receivedMessages;
            knownPublicKeys = newState.knownPublicKeys;
            knowledgeGraph = newState.knowledgeGraph;
            courses = newState.courses;
            assetTokens = newState.assetTokens;
            equipmentContracts = newState.equipmentContracts;
            arbitrationCases = newState.arbitrationCases;
            loans = newState.loans; // Update new state variables
            grants = newState.grants;
            insurancePolicies = newState.insurancePolicies;

            await updateUIFromState();
        }

        // --- Wallet & MQTT Setup ---
        async function generateWallet() {
            try {
                const mnemonicInput = document.getElementById('mnemonicInput').value.trim();
                if (mnemonicInput) {
                    wallet = ethers.Wallet.fromMnemonic(mnemonicInput);
                    appendLog("Wallet loaded from mnemonic.", 'success');
                } else {
                    wallet = ethers.Wallet.createRandom();
                    document.getElementById('mnemonicInput').value = wallet.mnemonic.phrase;
                    appendLog("New wallet generated!", 'success');
                }
                provider = new ethers.providers.JsonRpcProvider('https://cloudflare-eth.com');
                signer = wallet.connect(provider);
                myAddress = await signer.getAddress();
                myClientId = `client_${myAddress.substring(2, 10)}`;
                document.getElementById('myAddress').textContent = myAddress;
                document.getElementById('myClientId').textContent = myClientId;

                await generateOpenPGPKeyPair();
                document.getElementById('myOpenPGPPublicKeyDisplay').value = myOpenPGPPublicKey.armoredKey;
                appendLog(`Your Ethereum Address: ${myAddress}`, 'success');
                appendLog(`Your Client ID: ${myClientId}`, 'success');

                // Enable relevant UI elements after wallet generation
                document.getElementById('recordAdAudioButton').disabled = false;
                document.getElementById('startAdVideoButton').disabled = false;
                document.getElementById('startWebcamSnapshotButton').disabled = false;
                document.getElementById('uploadImageButton').disabled = false;
                document.getElementById('startSpeechButton').disabled = false;
                document.getElementById('getAdLocationButton').disabled = false;
                document.getElementById('uploadFileAdButton').disabled = false;
                document.getElementById('adCanvasColorPicker').disabled = false;
                document.getElementById('adCanvasLineWidth').disabled = false;
                document.getElementById('adCanvasDrawModeButton').disabled = false;
                document.getElementById('adCanvasTextModeButton').disabled = false;
                document.getElementById('adCanvasImageModeButton').disabled = false;
                document.getElementById('clearAdCanvasButton').disabled = false;
                // Note: postAdButton, makeOfferButton, acceptOfferButton, rejectOfferButton might not exist directly,
                // instead, the functions are called from buttons with specific IDs.
                // Assuming these are the primary action buttons in the "Post Classified Ad" and "Marketplace Actions" panels.
                // If they don't exist, this will throw an error, so enable buttons by their actual IDs.
                // For now, I'll keep the original logic, but this might need refinement if buttons are not found.
                // Example: document.querySelector('button[onclick="postAd()"]').disabled = false;
                // For simplicity, I'll assume the original buttons exist or the logic is handled by other means.

                // Enable all relevant input fields and buttons for new features
                document.getElementById('loanAmount').disabled = false;
                document.getElementById('loanCollateralTokenId').disabled = false;
                document.getElementById('loanInterestRate').disabled = false;
                document.getElementById('loanRepaymentDueDate').disabled = false;
                document.querySelector('button[onclick="requestLoan()"]').disabled = false;

                document.getElementById('offerLoanId').disabled = false;
                document.getElementById('offerLoanInterestRate').disabled = false;
                document.querySelector('button[onclick="offerLoan()"]').disabled = false;

                document.getElementById('repayLoanId').disabled = false;
                document.querySelector('button[onclick="repayLoan()"]').disabled = false;

                document.getElementById('defaultLoanId').disabled = false;
                document.querySelector('button[onclick="declareLoanDefault()"]').disabled = false;

                document.getElementById('grantRecipientClientId').disabled = false;
                document.getElementById('grantAmount').disabled = false;
                document.getElementById('grantDescription').disabled = false;
                document.querySelector('button[onclick="issueGrant()"]').disabled = false;

                document.getElementById('insuredTokenId').disabled = false;
                document.getElementById('coverageAmount').disabled = false;
                document.getElementById('premiumAmount').disabled = false;
                document.getElementById('policyDurationDays').disabled = false;
                document.querySelector('button[onclick="requestInsurance()"]').disabled = false;

                document.getElementById('offerPolicyId').disabled = false;
                document.getElementById('offerPremiumAmount').disabled = false;
                document.querySelector('button[onclick="offerInsurance()"]').disabled = false;

                document.getElementById('claimPolicyId').disabled = false;
                document.getElementById('claimDetails').disabled = false;
                document.querySelector('button[onclick="submitInsuranceClaim()"]').disabled = false;

                document.getElementById('manageClaimPolicyId').disabled = false;
                document.getElementById('manageClaimId').disabled = false;
                document.querySelector('button[onclick="approveInsuranceClaim()"]').disabled = false;
                document.querySelector('button[onclick="rejectInsuranceClaim()"]').disabled = false;


                document.getElementById('presharedKeyInput').disabled = false;
                document.querySelector('button[onclick="setCurrentPSK()"]').disabled = false; // Enable Set PSK button
                document.querySelector('button[onclick="sendMessage()"]').disabled = false; // Enable Send Message button
                document.getElementById('messageContent').disabled = false;
                document.getElementById('messageType').disabled = false;
                document.getElementById('messageRecipientClientId').disabled = false;
                document.querySelector('button[onclick="addKnownPublicKey()"]').disabled = false; // Enable Add Key button
                document.getElementById('peerClientIdForKey').disabled = false;
                document.getElementById('peerOpenPGPPublicKeyInput').disabled = false;


                document.getElementById('reviewAdId').disabled = false;
                document.getElementById('reviewRating').disabled = false;
                document.getElementById('reviewComment').disabled = false;
                document.querySelector('button[onclick="submitReview()"]').disabled = false;

                document.getElementById('knowledgeTitle').disabled = false;
                document.getElementById('knowledgeContent').disabled = false;
                document.getElementById('knowledgeTags').disabled = false;
                document.getElementById('knowledgePreviousNodeId').disabled = false;
                document.querySelector('button[onclick="postKnowledgeNode()"]').disabled = false;
                document.getElementById('knowledgeSearchInput').disabled = false;

                document.getElementById('courseTitle').disabled = false;
                document.getElementById('courseDescription').disabled = false;
                document.querySelector('button[onclick="addModule()"]').disabled = false;
                document.querySelector('button[onclick="postCourse()"]').disabled = false;

                document.getElementById('assetTokenId').disabled = false;
                document.getElementById('assetTokenDescription').disabled = false;
                document.querySelector('button[onclick="mintAssetToken()"]').disabled = false;
                document.getElementById('transferAssetTokenId').disabled = false;
                document.getElementById('transferRecipientClientId').disabled = false;
                document.querySelector('button[onclick="transferAssetToken()"]').disabled = false;

                document.getElementById('disputedItemType').disabled = false;
                document.getElementById('disputedItemId').disabled = false;
                document.getElementById('disputeReason').disabled = false;
                document.getElementById('defendantClientId').disabled = false;
                document.querySelector('button[onclick="raiseArbitrationRequest()"]').disabled = false;

                document.getElementById('arbitrateCaseId').disabled = false;
                document.getElementById('arbitratorDecision').disabled = false;
                document.getElementById('arbitratorResolution').disabled = false;
                document.getElementById('arbitratorDecisionButton').disabled = false; // This one is handled specifically below

                document.getElementById('delegateItemId').disabled = false;
                document.getElementById('delegateToClientId').disabled = false;
                document.getElementById('delegateDuration').disabled = false;
                document.getElementById('delegationType').disabled = false;
                document.querySelector('button[onclick="delegateControl()"]').disabled = false;


                // Arbitrator decision button enabled based on myAddress
                if (myAddress.toLowerCase() === BROKER_ADDRESS.toLowerCase()) {
                    document.getElementById('arbitratorDecisionButton').disabled = false;
                } else {
                    document.getElementById('arbitratorDecisionButton').disabled = true;
                }
                document.getElementById('brokerAddressDisplay').textContent = BROKER_ADDRESS;
                document.getElementById('brokerAddressDisplay2').textContent = BROKER_ADDRESS;

            } catch (error) {
                console.error("Wallet generation error:", error);
                appendLog(`Error generating/loading wallet: ${error.message}`, 'error');
            }
        }

        async function connectMQTT() {
            if (!myClientId) {
                appendLog("Please generate a wallet first.", 'error');
                return;
            }
            const mqttBroker = 'wss://broker.hivemq.com:8884/mqtt';
            mqttClient = mqtt.connect(mqttBroker, { clientId: myClientId });

            document.getElementById('connectionStatus').textContent = 'Status: Connecting...';

            mqttClient.on('connect', () => {
                document.getElementById('connectionStatus').textContent = 'Status: Connected!';
                appendLog("Connected to MQTT Broker.", 'success');

                mqttClient.subscribe(MARKETPLACE_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${MARKETPLACE_TOPIC}#`);
                });
                mqttClient.subscribe(MESSAGING_TOPIC + myClientId, { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to private messages at ${MESSAGING_TOPIC}${myClientId}`);
                });
                mqttClient.subscribe(MESSAGING_TOPIC + 'public', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to public messages at ${MESSAGING_TOPIC}public`);
                });
                mqttClient.subscribe(KEY_EXCHANGE_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${KEY_EXCHANGE_TOPIC}#`);
                });
                mqttClient.subscribe(KNOWLEDGE_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${KNOWLEDGE_TOPIC}#`);
                });
                mqttClient.subscribe(COURSES_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${COURSES_TOPIC}#`);
                });
                mqttClient.subscribe(COURSE_PROGRESS_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${COURSE_PROGRESS_TOPIC}#`);
                });
                mqttClient.subscribe(ASSETS_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${ASSETS_TOPIC}#`);
                });
                mqttClient.subscribe(EQUIPMENT_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${EQUIPMENT_TOPIC}#`);
                });
                mqttClient.subscribe(ARBITRATION_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${ARBITRATION_TOPIC}#`);
                });
                // Subscribe to new topics
                mqttClient.subscribe(LOANS_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${LOANS_TOPIC}#`);
                });
                mqttClient.subscribe(GRANTS_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${GRANTS_TOPIC}#`);
                });
                mqttClient.subscribe(INSURANCE_TOPIC + '#', { qos: 1 }, (err) => {
                    if (!err) appendLog(`Subscribed to ${INSURANCE_TOPIC}#`);
                });


                publishPublicKey();
            });

            mqttClient.on('message', async (topic, message) => {
                try {
                    const received = JSON.parse(message.toString());
                    const payload = received.payload;
                    const signature = received.signature;

                    const recoveredAddress = ethers.utils.verifyMessage(JSON.stringify(payload), signature);
                    if (recoveredAddress.toLowerCase() !== payload.senderAddress.toLowerCase()) {
                        console.warn("Signature mismatch for message:", payload);
                        appendLog(`Invalid signature from ${payload.senderClientId.substring(0,10)}.... Ignoring.`, 'error');
                        return;
                    }

                    console.log(`Received message on topic ${topic}:`, payload);

                    if (topic.startsWith(MARKETPLACE_TOPIC) || topic.startsWith(KEY_EXCHANGE_TOPIC) || topic.startsWith(KNOWLEDGE_TOPIC) || topic.startsWith(COURSES_TOPIC) || topic.startsWith(COURSE_PROGRESS_TOPIC) || topic.startsWith(ASSETS_TOPIC) || topic.startsWith(EQUIPMENT_TOPIC) || topic.startsWith(ARBITRATION_TOPIC) || topic.startsWith(LOANS_TOPIC) || topic.startsWith(GRANTS_TOPIC) || topic.startsWith(INSURANCE_TOPIC)) {
                        await applyLocalStateUpdate(payload);
                        appendLog(`Event (${payload.type} from ${payload.senderClientId.substring(0,10)}...): ${JSON.stringify(payload.data)}`);
                    } else if (topic.startsWith(MESSAGING_TOPIC)) {
                        if (payload.type === 'MESSAGING_EVENT') {
                            const msgData = payload.data;
                            let decryptedContent = null;
                            let isDecrypted = false;

                            if (msgData.encryptionType === 'public') {
                                decryptedContent = msgData.content;
                                isDecrypted = true;
                            } else if (msgData.encryptionType === 'openpgp' && msgData.recipientClientId === myClientId) {
                                try {
                                    const { data: decrypted } = await decryptWithOpenPGP(msgData.encryptedPayload, myOpenPGPPrivateKey, wallet.mnemonic.phrase);
                                    decryptedContent = decrypted;
                                    isDecrypted = true;
                                } catch (e) {
                                    console.error("OpenPGP Decryption failed:", e);
                                    decryptedContent = `[Decryption Failed: ${e.message}]`;
                                    isDecrypted = false;
                                }
                            } else if (msgData.encryptionType === 'psk' && currentPSK) {
                                try {
                                    decryptedContent = await decryptWithPSK(msgData.encryptedPayload, currentPSK);
                                    isDecrypted = true;
                                } catch (e) {
                                    console.error("PSK Decryption failed:", e);
                                    decryptedContent = `[PSK Decryption Failed: ${e.message}]`;
                                    isDecrypted = false;
                                }
                            }

                            const displayMsg = {
                                senderClientId: payload.senderClientId,
                                recipientClientId: msgData.recipientClientId,
                                encryptionType: msgData.encryptionType,
                                content: decryptedContent,
                                decrypted: isDecrypted,
                                timestamp: payload.timestamp
                            };
                            await applyLocalStateUpdate({ id: crypto.randomUUID(), type: 'MESSAGING_EVENT', data: displayMsg });
                            appendLog(`Message from ${payload.senderClientId.substring(0,10)}... (${msgData.encryptionType}): ${decryptedContent || '[Encrypted]'}`);
                        }
                    }
                } catch (error) {
                    console.error("Error processing MQTT message:", error);
                    appendLog(`Error processing incoming message: ${error.message}`, 'error');
                }
            });

            mqttClient.on('error', (err) => {
                console.error("MQTT Client error:", err);
                document.getElementById('connectionStatus').textContent = 'Status: Error';
                appendLog(`MQTT Error: ${err.message}`, 'error');
            });

            mqttClient.on('close', () => {
                document.getElementById('connectionStatus').textContent = 'Status: Disconnected';
                appendLog("Disconnected from MQTT Broker.", 'error');
            });
        }

        // --- Marketplace Actions ---
        let milestoneCounter = 0;
        function addMilestone() {
            milestoneCounter++;
            const container = document.getElementById('milestonesContainer');
            const div = document.createElement('div');
            div.className = 'milestone-input';
            div.innerHTML = `
                <label>Milestone ${milestoneCounter} Description:</label>
                <input type="text" id="milestoneDesc${milestoneCounter}" placeholder="e.g., Initial consultation">
                <label>Milestone ${milestoneCounter} Payment Amount:</label>
                <input type="number" id="milestoneAmount${milestoneCounter}" placeholder="e.g., 50">
            `;
            container.appendChild(div);
        }

        document.getElementById('adType').addEventListener('change', (event) => {
            const milestonesSection = document.getElementById('milestonesSection');
            const equipmentSection = document.getElementById('equipmentSection');
            if (event.target.value === 'service') {
                milestonesSection.style.display = 'block';
                equipmentSection.style.display = 'none';
                if (milestoneCounter === 0) {
                    addMilestone();
                }
            } else if (event.target.value === 'equipment') {
                milestonesSection.style.display = 'none';
                equipmentSection.style.display = 'block';
                document.getElementById('milestonesContainer').innerHTML = '';
                milestoneCounter = 0;
            }
            else {
                milestonesSection.style.display = 'none';
                equipmentSection.style.display = 'none';
                document.getElementById('milestonesContainer').innerHTML = '';
                milestoneCounter = 0;
            }
        });

        async function postAd() {
            const title = document.getElementById('adTitle').value;
            const price = parseFloat(document.getElementById('adPrice').value);
            const description = document.getElementById('adDescription').value;
            const adType = document.getElementById('adType').value;

            if (!title || !price || !description || isNaN(price) || price <= 0) {
                alert("Please fill all ad fields correctly.");
                return;
            }

            let milestones = [];
            if (adType === 'service') {
                for (let i = 1; i <= milestoneCounter; i++) {
                    const desc = document.getElementById(`milestoneDesc${i}`)?.value;
                    const amount = parseFloat(document.getElementById(`milestoneAmount${i}`)?.value);
                    if (desc && !isNaN(amount) && amount > 0) {
                        milestones.push({
                            id: `m${i}_${crypto.randomUUID().substring(0,4)}`,
                            description: desc,
                            paymentAmount: amount,
                            status: 'pending'
                        });
                    }
                }
                if (milestones.length === 0) {
                    alert("Service ads must have at least one milestone with a valid amount.");
                    return;
                }
            }

            let equipmentDetails = null;
            if (adType === 'equipment') {
                const equipmentId = document.getElementById('equipmentIdInput').value.trim();
                const initialStatus = document.getElementById('equipmentInitialStatus').value.trim();
                if (!equipmentId || !initialStatus) {
                    alert("Please provide Equipment ID and Initial Status for equipment ads.");
                    return;
                }
                equipmentDetails = { equipmentId, initialStatus };
            }

            let adMedia = [];
            if (adAudioBlob) { adMedia.push({ type: 'audio', content: await blobToBase64(adAudioBlob), mimeType: adAudioBlob.type }); }
            if (adVideoBlob) { adMedia.push({ type: 'video', content: await blobToBase64(adVideoBlob), mimeType: adVideoBlob.type }); }
            if (adSnapshotBlob) { adMedia.push({ type: 'image_snapshot', content: await blobToBase64(adSnapshotBlob), mimeType: adSnapshotBlob.type }); }
            if (adUploadedImageBase64) { adMedia.push({ type: 'image_upload', content: adUploadedImageBase64, mimeType: adUploadedImageMimeType }); }
            if (adRecognizedText) { adMedia.push({ type: 'text_note', content: adRecognizedText }); }
            if (adGeolocation) { adMedia.push({ type: 'geolocation', content: adGeolocation }); }
            if (adUploadedFileBase64) { adMedia.push({ type: 'file_upload', content: adUploadedFileBase64, mimeType: adUploadedFileMimeType, fileName: adUploadedFileName }); }
            if (adDrawingCommands.length > 0) { adMedia.push({ type: 'canvas', content: JSON.stringify(adDrawingCommands) }); }

            const adId = `ad_${crypto.randomUUID()}`;
            const adData = {
                id: adId,
                title,
                price,
                description,
                type: adType,
                milestones: adType === 'service' ? milestones : undefined,
                equipmentId: adType === 'equipment' ? equipmentDetails.equipmentId : undefined,
                initialStatus: adType === 'equipment' ? equipmentDetails.initialStatus : undefined,
                sellerClientId: myClientId,
                sellerAddress: myAddress,
                timestamp: Date.now(),
                media: adMedia
            };

            await signAndPublish(MARKETPLACE_TOPIC + 'ads', adData, 'POST_AD', adId);
            appendLog(`Posted new ${adType} ad: ${title} for ${price} UBHP`, 'success');

            // Clear form fields and media attachments
            document.getElementById('adTitle').value = '';
            document.getElementById('adPrice').value = '';
            document.getElementById('adDescription').value = '';
            document.getElementById('adType').value = 'product';
            document.getElementById('milestonesSection').style.display = 'none';
            document.getElementById('equipmentSection').style.display = 'none';
            document.getElementById('milestonesContainer').innerHTML = '';
            milestoneCounter = 0;
            document.getElementById('equipmentIdInput').value = '';
            document.getElementById('equipmentInitialStatus').value = 'operational';

            adAudioBlob = null; document.getElementById('adAudioPlayback').src = ''; document.getElementById('adAudioPlayback').classList.add('hidden'); document.getElementById('playAdAudioButton').disabled = true; document.getElementById('stopAdAudioButton').disabled = true; displayStatus('adAudioStatus', '', 'hidden');
            adVideoBlob = null; document.getElementById('adVideoPlayback').src = ''; document.getElementById('adVideoPlayback').classList.add('hidden'); document.getElementById('webcamVideoPreview').classList.add('hidden'); document.getElementById('stopAdVideoButton').disabled = true; document.getElementById('playAdVideoButton').disabled = true; document.getElementById('startAdVideoButton').disabled = false; if (videoStream) { videoStream.getTracks().forEach(track => track.stop()); videoStream = null; } displayStatus('adVideoStatus', '', 'hidden');
            adSnapshotBlob = null; document.getElementById('imagePreview').src = ''; document.getElementById('imagePreview').classList.add('hidden'); document.getElementById('webcamSnapshotPreview').classList.add('hidden'); document.getElementById('takeSnapshotButton').disabled = true; document.getElementById('stopWebcamSnapshotButton').disabled = true; document.getElementById('startWebcamSnapshotButton').disabled = false; if (snapshotStream) { snapshotStream.getTracks().forEach(track => track.stop()); snapshotStream = null; } displayStatus('adSnapshotStatus', '', 'hidden');
            adUploadedImageBase64 = null; adUploadedImageMimeType = null; document.getElementById('uploadedImagePreview').src = ''; document.getElementById('uploadedImagePreview').classList.add('hidden'); document.getElementById('clearImageButton').disabled = true; document.getElementById('uploadImageInput').value = ''; displayStatus('adImageUploadStatus', '', 'hidden');
            adRecognizedText = ''; document.getElementById('adSpeechText').value = ''; document.getElementById('stopSpeechButton').disabled = true; document.getElementById('startSpeechButton').disabled = false; if (isSpeechListening && speechRecognition) { speechRecognition.stop(); } displayStatus('adSpeechStatus', '', 'hidden');
            adGeolocation = null; document.getElementById('adLocationDisplay').textContent = ''; document.getElementById('adLocationDisplay').classList.add('hidden'); document.getElementById('clearAdLocationButton').disabled = true; displayStatus('adLocationStatus', '', 'hidden');
            adUploadedFileBase64 = null; adUploadedFileMimeType = null; adUploadedFileName = null; document.getElementById('adFileNameDisplay').textContent = ''; document.getElementById('adFileNameDisplay').classList.add('hidden'); document.getElementById('clearFileAdButton').disabled = true; document.getElementById('uploadFileAdInput').value = ''; displayStatus('adFileUploadStatus', '', 'hidden');
            adDrawingCommands = []; document.getElementById('clearAdCanvasButton').click(); displayStatus('adCanvasStatus', '', 'hidden');
        }

        async function makeOffer() {
            const adId = document.getElementById('offerAdId').value;
            const amount = parseFloat(document.getElementById('offerAmount').value);

            if (!adId || !amount || isNaN(amount) || amount <= 0) {
                alert("Please provide a valid Ad ID and offer amount.");
                return;
            }

            const adExists = classifiedAdBuffer.has(adId);
            if (!adExists) {
                alert("Ad with this ID does not exist in your local buffer. Please ensure it was broadcast and received.");
                return;
            }
            const ad = classifiedAdBuffer.get(adId);

            const offerId = `offer_${crypto.randomUUID()}`;
            const offerData = {
                id: offerId,
                adId: adId,
                adPosterClientId: ad.sellerClientId,
                amount: amount,
                offerorClientId: myClientId,
                offerorAddress: myAddress,
                timestamp: Date.now(),
                status: 'pending'
            };

            await signAndPublish(MARKETPLACE_TOPIC + 'offers', offerData, 'MAKE_OFFER', offerId);
            appendLog(`Made offer of ${amount} UBHP for Ad ID: ${adId}`, 'success');
        }

        function acceptOfferFromInput() {
            const offerId = document.getElementById('selectedOfferId').value;
            const offer = offersReceived.get(offerId);
            if (!offer) { alert("Offer not found in 'Offers Received' list."); return; }
            acceptOffer(offer.id, offer.adId);
        }

        function rejectOfferFromInput() {
            const offerId = document.getElementById('selectedOfferId').value;
            const offer = offersReceived.get(offerId);
            if (!offer) { alert("Offer not found in 'Offers Received' list."); return; }
            rejectOffer(offer.id, offer.adId);
        }

        async function acceptOffer(offerId, adId) {
            const offerAction = {
                offerId: offerId,
                adId: adId,
                action: 'accept',
                actorClientId: myClientId,
                actorAddress: myAddress,
                timestamp: Date.now()
            };
            await signAndPublish(MARKETPLACE_TOPIC + 'actions', offerAction, 'ACCEPT_OFFER', offerId);
            appendLog(`Accepted offer ${offerId} for Ad ID ${adId}`, 'success');
        }

        async function rejectOffer(offerId, adId) {
            const offerAction = {
                offerId: offerId,
                adId: adId,
                action: 'reject',
                actorClientId: myClientId,
                actorAddress: myAddress,
                timestamp: Date.now()
            };
            await signAndPublish(MARKETPLACE_TOPIC + 'actions', offerAction, 'REJECT_OFFER', offerId);
            appendLog(`Rejected offer ${offerId} for Ad ID ${adId}`, 'success');
        }

        async function updateMilestoneStatus(adId, milestoneId, newStatus) {
            const ad = classifiedAdBuffer.get(adId);
            if (!ad || ad.sellerClientId !== myClientId) {
                alert("You are not the contractor for this service ad.");
                return;
            }
            const milestone = ad.milestones.find(m => m.id === milestoneId);
            if (!milestone) { alert("Milestone not found."); return; }

            const actionPayload = {
                adContentAddress: adId,
                milestoneId: milestoneId,
                newStatus: newStatus,
                actorClientId: myClientId
            };
            await signAndPublish(MARKETPLACE_TOPIC + 'milestones', actionPayload, 'UPDATE_MILESTONE_STATUS', `${adId}_${milestoneId}_status`);
            appendLog(`Milestone ${milestone.description} for Ad ${ad.title} updated to ${newStatus}.`, 'success');
        }

        async function signMilestoneApproval(adId, milestoneId) {
            const ad = classifiedAdBuffer.get(adId);
            if (!ad || !ad.contract || !ad.escrow) {
                alert("Ad or contract/escrow not found for this milestone.");
                return;
            }
            const milestone = ad.milestones.find(m => m.id === milestoneId);
            if (!milestone) { alert("Milestone not found."); return; }
            if (milestone.status !== 'completed') {
                alert("Milestone must be marked 'completed' before approval.");
                return;
            }

            const paymentStatus = ad.escrow.milestonePayments.get(milestoneId);
            if (paymentStatus && paymentStatus.releaseSigners.includes(myClientId)) {
                alert("You have already signed approval for this milestone payment.");
                return;
            }

            const isBuyer = ad.acceptedOffer.offerorClientId === myClientId;
            const isSeller = ad.sellerClientId === myClientId;
            const isDelegateForBuyer = [...myDelegations.values()].some(d => d.delegatorClientId === ad.acceptedOffer.offerorClientId && d.delegateeClientId === myClientId && d.authorityType === 'RELEASE_ESCROW');
            const isDelegateForSeller = [...myDelegations.values()].some(d => d.delegatorClientId === ad.sellerClientId && d.delegateeClientId === myClientId && d.authorityType === 'RELEASE_ESCROW');

            if (!isBuyer && !isSeller && !isDelegateForBuyer && !isDelegateForSeller) {
                alert("You are not authorized to approve this milestone payment.");
                return;
            }

            const actionPayload = {
                adContentAddress: adId,
                milestoneId: milestoneId,
                signerClientId: myClientId
            };
            await signAndPublish(MARKETPLACE_TOPIC + 'milestones', actionPayload, 'SIGN_MILESTONE_APPROVAL', `${adId}_${milestoneId}_approval`);
            appendLog(`Signed approval for milestone ${milestone.description} of Ad ${ad.title}.`, 'success');
        }

        async function updateEquipmentStatus(equipmentId) {
            const newStatus = document.getElementById(`newStatus_${equipmentId}`).value.trim();
            if (!newStatus) {
                alert("Please enter a new status.");
                return;
            }

            const equipmentContract = equipmentContracts.get(equipmentId);
            if (!equipmentContract || (equipmentContract.sellerClientId !== myClientId && equipmentContract.buyerClientId !== myClientId)) {
                alert("You are not a party to this equipment contract.");
                return;
            }

            const actionPayload = {
                equipmentId: equipmentId,
                newStatus: newStatus,
                actorClientId: myClientId
            };
            await signAndPublish(EQUIPMENT_TOPIC + 'status_update', actionPayload, 'UPDATE_EQUIPMENT_STATUS', `eq_status_${equipmentId}_${Date.now()}`);
            appendLog(`Equipment ${equipmentId} status updated to: ${newStatus}`, 'success');
            document.getElementById(`newStatus_${equipmentId}`).value = '';
        }

        async function addLifecycleEvent(equipmentId) {
            const eventDetails = document.getElementById(`newLifecycleEvent_${equipmentId}`).value.trim();
            if (!eventDetails || eventDetails.indexOf(':') === -1) {
                alert("Please enter event in 'Type:Details' format (e.g., serviced:Replaced filter).");
                return;
            }
            const [eventType, details] = eventDetails.split(':', 2);

            const equipmentContract = equipmentContracts.get(equipmentId);
            if (!equipmentContract || (equipmentContract.sellerClientId !== myClientId && equipmentContract.buyerClientId !== myClientId)) {
                alert("You are not a party to this equipment contract.");
                return;
            }

            const actionPayload = {
                equipmentId: equipmentId,
                eventType: eventType.trim(),
                details: details.trim(),
                actorClientId: myClientId
            };
            await signAndPublish(EQUIPMENT_TOPIC + 'lifecycle_event', actionPayload, 'ADD_LIFECYCLE_EVENT', `eq_event_${equipmentId}_${Date.now()}`);
            appendLog(`Added lifecycle event for equipment ${equipmentId}: ${eventDetails}`, 'success');
            document.getElementById(`newLifecycleEvent_${equipmentId}`).value = '';
        }

        async function raiseArbitrationRequest(disputedItemIdFromUI = null, disputedItemTypeFromUI = null) {
            const disputedItemType = disputedItemTypeFromUI || document.getElementById('disputedItemType').value;
            const disputedItemId = disputedItemIdFromUI || document.getElementById('disputedItemId').value.trim();
            const reason = document.getElementById('disputeReason').value.trim();
            const defendantClientId = document.getElementById('defendantClientId').value.trim();

            if (!disputedItemId || !reason || !defendantClientId) {
                alert("Please fill all dispute fields.");
                return;
            }

            const caseId = `case_${crypto.randomUUID()}`;
            const arbitrationData = {
                caseId: caseId,
                disputedItemId: disputedItemId,
                disputedItemType: disputedItemType,
                reason: reason,
                plaintiffClientId: myClientId,
                defendantClientId: defendantClientId,
                timestamp: Date.now()
            };

            await signAndPublish(ARBITRATION_TOPIC + 'requests', arbitrationData, 'RAISE_ARBITRATION_REQUEST', caseId);
            appendLog(`Raised arbitration request for ${disputedItemType} ID: ${disputedItemId}`, 'error');

            if (!disputedItemTypeFromUI) { // Only clear if not called from other buttons
                document.getElementById('disputedItemId').value = '';
                document.getElementById('disputeReason').value = '';
                document.getElementById('defendantClientId').value = '';
            }
        }

        async function makeArbitratorDecision() {
            const caseId = document.getElementById('arbitrateCaseId').value.trim();
            const decision = document.getElementById('arbitratorDecision').value.trim();
            const resolution = document.getElementById('arbitratorResolution').value.trim();

            if (!caseId || !decision || !resolution) {
                alert("Please fill all arbitrator decision fields.");
                return;
            }

            if (myAddress.toLowerCase() !== BROKER_ADDRESS.toLowerCase()) {
                alert("You are not the designated arbitrator (broker) for this demo.");
                return;
            }

            const arbitrationCase = arbitrationCases.get(caseId);
            if (!arbitrationCase) {
                alert("Arbitration case not found.");
                return;
            }
            if (arbitrationCase.status !== 'pending' && arbitrationCase.status !== 'in_arbitration') {
                alert("This case is already resolved or withdrawn.");
                return;
            }

            const decisionData = {
                caseId: caseId,
                decision: decision,
                resolution: resolution, // e.g., 'resolved_for_plaintiff', 'resolved_for_defendant', 'withdrawn'
                arbitratorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(ARBITRATION_TOPIC + 'decisions', decisionData, 'ARBITRATOR_DECISION', `decision_${caseId}`);
            appendLog(`Made decision for arbitration case ${caseId}: ${resolution}`, 'success');

            document.getElementById('arbitrateCaseId').value = '';
            document.getElementById('arbitratorDecision').value = '';
            document.getElementById('arbitratorResolution').value = 'resolved_for_plaintiff';
        }

        async function delegateControl() {
            const delegatedItemId = document.getElementById('delegateItemId').value.trim();
            const delegateeClientId = document.getElementById('delegateToClientId').value.trim();
            const durationMinutes = parseInt(document.getElementById('delegateDuration').value, 10);
            const delegationType = document.getElementById('delegationType').value;

            if (!delegatedItemId || !delegateeClientId || isNaN(durationMinutes) || durationMinutes <= 0 || !delegationType) {
                alert("Please fill all delegation fields correctly.");
                return;
            }

            const delegationId = `delegation_${crypto.randomUUID()}`;
            const expiryTime = Date.now() + (durationMinutes * 60 * 1000);

            const delegationData = {
                id: delegationId,
                delegatedItemId: delegatedItemId,
                delegatorClientId: myClientId,
                delegatorAddress: myAddress,
                delegateeClientId: delegateeClientId,
                expiry: expiryTime,
                authorityType: delegationType,
                timestamp: Date.now()
            };

            await signAndPublish(MARKETPLACE_TOPIC + 'delegations', delegationData, 'DELEGATE_CONTROL', delegationId);
            appendLog(`Delegated ${delegationType} control of ${delegatedItemId} to ${delegateeClientId.substring(0,10)}... for ${durationMinutes} minutes.`, 'success');
        }

        async function submitReview() {
            const adId = document.getElementById('reviewAdId').value.trim();
            const rating = parseInt(document.getElementById('reviewRating').value, 10);
            const comment = document.getElementById('reviewComment').value.trim();

            if (!adId || isNaN(rating) || rating < 1 || rating > 5 || !comment) {
                alert("Please provide a valid Ad ID, rating (1-5), and comment.");
                return;
            }

            const ad = classifiedAdBuffer.get(adId);
            if (!ad) {
                alert("Ad not found in your local buffer. Please ensure it was broadcast and received.");
                return;
            }

            const isBuyer = ad.acceptedOffer?.offerorClientId === myClientId;
            if (!isBuyer) {
                alert("You can only review transactions where you were the buyer/client.");
                return;
            }

            const isCompletedProduct = ad.type === 'product' && ad.status === 'sold';
            const isCompletedService = ad.type === 'service' && ad.status === 'completed';
            const isCompletedEquipment = ad.type === 'equipment' && ad.status === 'equipment_contract_active'; // Assuming review can be left once contract is active

            if (!isCompletedProduct && !isCompletedService && !isCompletedEquipment) {
                alert(`This transaction is not yet completed. Current status: ${ad.status}.`);
                return;
            }

            const alreadyReviewed = ad.reviews.some(r => r.reviewerClientId === myClientId);
            if (alreadyReviewed) {
                alert("You have already submitted a review for this transaction.");
                return;
            }

            const reviewId = `review_${crypto.randomUUID()}`;
            const reviewData = {
                id: reviewId,
                adId: adId,
                reviewerClientId: myClientId,
                reviewerAddress: myAddress,
                targetClientId: ad.sellerClientId,
                rating: rating,
                comment: comment,
                timestamp: Date.now()
            };

            await signAndPublish(MARKETPLACE_TOPIC + 'reviews', reviewData, 'POST_REVIEW', reviewId);
            appendLog(`Submitted review for Ad ID ${adId} (Rating: ${rating}/5).`, 'success');

            document.getElementById('reviewAdId').value = '';
            document.getElementById('reviewRating').value = '5';
            document.getElementById('reviewComment').value = '';
        }

        // --- Knowledge Graph Functions ---
        async function postKnowledgeNode() {
            const title = document.getElementById('knowledgeTitle').value.trim();
            const content = document.getElementById('knowledgeContent').value.trim();
            const tags = document.getElementById('knowledgeTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
            const previousNodeId = document.getElementById('knowledgePreviousNodeId').value.trim();

            if (!title || !content) {
                alert("Knowledge node must have a title and content.");
                return;
            }

            const nodeId = `kn_${crypto.randomUUID()}`;
            const nodeData = {
                id: nodeId,
                title: title,
                content: content,
                tags: tags,
                authorClientId: myClientId,
                authorAddress: myAddress,
                timestamp: Date.now(),
                previousNodeId: previousNodeId || null
            };

            await signAndPublish(KNOWLEDGE_TOPIC + 'nodes', nodeData, 'POST_KNOWLEDGE_NODE', nodeId);
            appendLog(`Posted new knowledge node: "${title}"`, 'success');

            document.getElementById('knowledgeTitle').value = '';
            document.getElementById('knowledgeContent').value = '';
            document.getElementById('knowledgeTags').value = '';
            document.getElementById('knowledgePreviousNodeId').value = '';
        }

        function searchKnowledgeNodes() {
            const searchTerm = document.getElementById('knowledgeSearchInput').value.toLowerCase();
            const allNodesList = document.getElementById('allKnowledgeNodesList');
            const searchResultsContainer = document.getElementById('knowledgeSearchResultsContainer');
            const searchResultsList = document.getElementById('knowledgeSearchResultsList');

            if (searchTerm === '') {
                allNodesList.style.display = 'block';
                searchResultsContainer.style.display = 'none';
                return;
            }

            allNodesList.style.display = 'none';
            searchResultsContainer.style.display = 'block';
            searchResultsList.innerHTML = '';

            const matchingNodes = Array.from(knowledgeGraph.values()).filter(node =>
                node.title.toLowerCase().includes(searchTerm) ||
                node.content.toLowerCase().includes(searchTerm) ||
                node.tags.some(tag => tag.toLowerCase().includes(searchTerm))
            );

            if (matchingNodes.length > 0) {
                const searchResultsHtml = matchingNodes.map(node => `
                    <div class="knowledge-node-entry">
                        <strong>${node.title}</strong> <span class="node-id">(ID: ${node.id})</span><br>
                        ${node.content}<br>
                        <span class="tags">Tags: ${node.tags.join(', ')}</span><br>
                        <small>By: ${node.authorClientId.substring(0,10)}... at ${new Date(node.timestamp).toLocaleString()}</small>
                        ${node.previousNodeId ? `<br><small>Previous Node: ${node.previousNodeId}</small>` : ''}
                    </div>
                `).join('');
                searchResultsList.innerHTML = searchResultsHtml;
            } else {
                searchResultsList.innerHTML = '<p>No matching knowledge nodes found.</p>';
            }
        }

        // --- Course Functions ---
        let moduleCounter = 0;
        let lessonCounter = 0;
        let examCounter = 0;
        let taskCounter = 0;

        function addModule() {
            moduleCounter++;
            const modulesContainer = document.getElementById('modulesContainer');
            const moduleId = `module_${moduleCounter}`;
            const moduleDiv = document.createElement('div');
            moduleDiv.className = 'course-section module-section';
            moduleDiv.id = moduleId;
            moduleDiv.innerHTML = `
                <h4>Module ${moduleCounter} Title:</h4>
                <input type="text" id="${moduleId}_title" placeholder="Module Title">
                <div id="${moduleId}_lessonsContainer"></div>
                <button onclick="addLesson('${moduleId}')" class="btn-secondary">Add Lesson to Module ${moduleCounter}</button>
            `;
            modulesContainer.appendChild(moduleDiv);
        }

        function addLesson(moduleId) {
            lessonCounter++;
            const lessonsContainer = document.getElementById(`${moduleId}_lessonsContainer`);
            const lessonId = `lesson_${lessonCounter}`;
            const lessonDiv = document.createElement('div');
            lessonDiv.className = 'lesson-section';
            lessonDiv.id = lessonId;
            lessonDiv.innerHTML = `
                <h5>Lesson ${lessonCounter} Title:</h5>
                <input type="text" id="${lessonId}_title" placeholder="Lesson Title">
                <label for="${lessonId}_content">Content:</label>
                <textarea id="${lessonId}_content" rows="3" placeholder="Lesson content..."></textarea>
                <div id="${lessonId}_examContainer"></div>
                <button onclick="addExam('${lessonId}')" class="btn-secondary">Add Exam to Lesson ${lessonCounter}</button>
                <div id="${lessonId}_taskContainer"></div>
                <button onclick="addTask('${lessonId}')" class="btn-secondary">Add Task to Lesson ${lessonCounter}</button>
            `;
            lessonsContainer.appendChild(lessonDiv);
        }

        function addExam(lessonId) {
            examCounter++;
            const examContainer = document.getElementById(`${lessonId}_examContainer`);
            const examId = `exam_${examCounter}`;
            const examDiv = document.createElement('div');
            examDiv.className = 'exam-question';
            examDiv.id = examId;
            examDiv.innerHTML = `
                <h6>Exam Question:</h6>
                <input type="text" id="${examId}_question" placeholder="Question">
                <label for="${examId}_answer">Correct Answer:</label>
                <input type="text" id="${examId}_answer" placeholder="Correct Answer">
            `;
            // Clear previous exam if any, then append
            examContainer.innerHTML = '';
            examContainer.appendChild(examDiv);
        }

        function addTask(lessonId) {
            taskCounter++;
            const taskContainer = document.getElementById(`${lessonId}_taskContainer`);
            const taskId = `task_${taskCounter}`;
            const taskDiv = document.createElement('div');
            taskDiv.className = 'task-item';
            taskDiv.id = taskId;
            taskDiv.innerHTML = `
                <h6>Task Description:</h6>
                <textarea id="${taskId}_description" rows="2" placeholder="Task description..."></textarea>
            `;
            // Clear previous task if any, then append
            taskContainer.innerHTML = '';
            taskContainer.appendChild(taskDiv);
        }

        async function postCourse() {
            const courseTitle = document.getElementById('courseTitle').value.trim();
            const courseDescription = document.getElementById('courseDescription').value.trim();

            if (!courseTitle || !courseDescription) {
                alert("Please fill in course title and description.");
                return;
            }

            const courseId = `course_${crypto.randomUUID()}`;
            const modules = [];
            const allExams = [];
            const allTasks = [];

            for (let i = 1; i <= moduleCounter; i++) {
                const moduleId = `module_${i}`;
                const moduleTitle = document.getElementById(`${moduleId}_title`)?.value.trim();
                if (!moduleTitle) continue;

                const lessons = [];
                const lessonsContainer = document.getElementById(`${moduleId}_lessonsContainer`);
                if (lessonsContainer) {
                    // Iterate through all possible lesson IDs to collect data
                    for (let j = 1; j <= lessonCounter; j++) {
                        const lessonId = `lesson_${j}`;
                        const lessonTitleInput = document.getElementById(`${lessonId}_title`);
                        const lessonContentInput = document.getElementById(`${lessonId}_content`);

                        if (lessonTitleInput && lessonContentInput && lessonTitleInput.value.trim() && lessonContentInput.value.trim()) {
                            const lessonTitle = lessonTitleInput.value.trim();
                            const lessonContent = lessonContentInput.value.trim();

                            let examIdForLesson = undefined;
                            const examContainer = document.getElementById(`${lessonId}_examContainer`);
                            if (examContainer && examContainer.children.length > 0) {
                                const examElem = examContainer.children[0];
                                const examId = examElem.id;
                                const question = document.getElementById(`${examId}_question`)?.value.trim();
                                const answer = document.getElementById(`${examId}_answer`)?.value.trim();
                                if (question && answer) {
                                    allExams.push({ id: examId, questions: [question], correctAnswers: [answer] });
                                    examIdForLesson = examId;
                                }
                            }

                            let taskIdForLesson = undefined;
                            const taskContainer = document.getElementById(`${lessonId}_taskContainer`);
                            if (taskContainer && taskContainer.children.length > 0) {
                                const taskElem = taskContainer.children[0];
                                const taskId = taskElem.id;
                                const description = document.getElementById(`${taskId}_description`)?.value.trim();
                                if (description) {
                                    allTasks.push({ id: taskId, description: description });
                                    taskIdForLesson = taskId;
                                }
                            }

                            lessons.push({
                                id: lessonId,
                                title: lessonTitle,
                                content: lessonContent,
                                examId: examIdForLesson,
                                taskId: taskIdForLesson
                            });
                        }
                    }
                }
                modules.push({ id: moduleId, title: moduleTitle, lessons: lessons });
            }

            const courseData = {
                id: courseId,
                title: courseTitle,
                description: courseDescription,
                authorClientId: myClientId,
                authorAddress: myAddress,
                timestamp: Date.now(),
                modules: modules,
                exams: allExams,
                tasks: allTasks
            };

            await signAndPublish(COURSES_TOPIC + 'new', courseData, 'POST_COURSE', courseId);
            appendLog(`Posted new course: "${courseTitle}"`, 'success');

            // Clear course creation form
            document.getElementById('courseTitle').value = '';
            document.getElementById('courseDescription').value = '';
            document.getElementById('modulesContainer').innerHTML = '';
            moduleCounter = 0;
            lessonCounter = 0;
            examCounter = 0;
            taskCounter = 0;
        }

        async function enrollInCourse(courseId) {
            const course = courses.get(courseId);
            if (!course) {
                alert("Course not found.");
                return;
            }
            if (course.participants.has(myClientId)) {
                alert("You are already enrolled in this course.");
                return;
            }

            const enrollmentData = {
                courseId: courseId,
                studentClientId: myClientId,
                studentAddress: myAddress,
                timestamp: Date.now()
            };

            await signAndPublish(COURSES_TOPIC + 'enroll', enrollmentData, 'ENROLL_COURSE', `enroll_${courseId}_${myClientId}`);
            appendLog(`Enrolled in course: "${course.title}"`, 'success');
        }

        async function submitExam(courseId, lessonId, examId) {
            const course = courses.get(courseId);
            if (!course) { alert("Course not found."); return; }
            const exam = course.exams.find(e => e.id === examId);
            if (!exam) { alert("Exam not found."); return; }

            const userAnswer = document.getElementById(`examAnswer_${lessonId}`).value.trim();
            const correctAnswer = exam.correctAnswers[0];
            let score = 0;
            if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                score = 100;
            }

            const examSubmissionData = {
                courseId: courseId,
                lessonId: lessonId,
                examId: examId,
                studentClientId: myClientId,
                score: score,
                timestamp: Date.now()
            };

            await signAndPublish(COURSE_PROGRESS_TOPIC + 'exam_submission', examSubmissionData, 'SUBMIT_EXAM', `exam_sub_${courseId}_${lessonId}_${myClientId}`);
            appendLog(`Submitted exam for lesson ${lessonId} in course ${course.title}. Score: ${score}%`, 'success');
        }

        async function studentAttestTask(courseId, lessonId, taskId) {
            const course = courses.get(courseId);
            if (!course) { alert("Course not found."); return; }
            const task = course.tasks.find(t => t.id === taskId);
            if (!task) { alert("Task not found."); return; }

            const attestationData = {
                courseId: courseId,
                lessonId: lessonId,
                taskId: taskId,
                studentClientId: myClientId,
                timestamp: Date.now(),
                attestation: "I have completed this task to the best of my ability."
            };

            await signAndPublish(COURSE_PROGRESS_TOPIC + 'task_attestation_student', attestationData, 'STUDENT_ATTEST_TASK', `student_attest_${courseId}_${lessonId}_${myClientId}`);
            appendLog(`Attested completion for task "${task.description}" in course "${course.title}". Awaiting instructor attestation.`, 'success');
        }

        async function instructorAttestTask(courseId, lessonId, taskId, studentClientId, studentAddress) {
            const course = courses.get(courseId);
            if (!course) { alert("Course not found."); return; }
            const task = course.tasks.find(t => t.id === taskId);
            if (!task) { alert("Task not found."); return; }

            const isAuthor = course.authorClientId === myClientId;
            const isDelegate = [...myDelegations.values()].some(d =>
                d.delegatorClientId === course.authorClientId &&
                d.delegateeClientId === myClientId &&
                d.authorityType === 'ATTEST_TASK' &&
                d.delegatedItemId === taskId
            );

            if (!isAuthor && !isDelegate) {
                alert("You are not authorized to attest completion for this task.");
                return;
            }

            const instructorAttestationData = {
                courseId: courseId,
                lessonId: lessonId,
                taskId: taskId,
                studentClientId: studentClientId,
                instructorClientId: myClientId,
                timestamp: Date.now(),
                attestation: "I have reviewed and confirmed the student's task completion."
            };

            await signAndPublish(COURSE_PROGRESS_TOPIC + 'task_attestation_instructor', instructorAttestationData, 'INSTRUCTOR_ATTEST_TASK', `instructor_attest_${courseId}_${lessonId}_${studentClientId}`);
            appendLog(`Attested completion for task "${task.description}" by ${studentClientId.substring(0,10)}... in course "${course.title}".`, 'success');
        }

        // --- Asset Token Functions ---
        async function mintAssetToken() {
            const tokenId = document.getElementById('assetTokenId').value.trim();
            const description = document.getElementById('assetTokenDescription').value.trim();

            if (!tokenId || !description) {
                alert("Please provide a Token ID and Description for the asset token.");
                return;
            }

            if (assetTokens.has(tokenId)) {
                alert("An asset token with this ID already exists.");
                return;
            }

            const tokenData = {
                id: tokenId,
                description: description,
                minterClientId: myClientId,
                initialOwnerClientId: myClientId, // Minter is initial owner
                timestamp: Date.now()
            };

            await signAndPublish(ASSETS_TOPIC + 'mint', tokenData, 'MINT_ASSET_TOKEN', tokenId);
            appendLog(`Minted new asset token: "${description}" (ID: ${tokenId})`, 'success');

            document.getElementById('assetTokenId').value = '';
            document.getElementById('assetTokenDescription').value = '';
        }

        async function transferAssetToken() {
            const tokenId = document.getElementById('transferAssetTokenId').value.trim();
            const recipientClientId = document.getElementById('transferRecipientClientId').value.trim();

            if (!tokenId || !recipientClientId) {
                alert("Please provide the Token ID and Recipient Client ID.");
                return;
            }

            const token = assetTokens.get(tokenId);
            if (!token) {
                alert("Asset token not found.");
                return;
            }
            if (token.ownerClientId !== myClientId) {
                alert("You are not the owner of this asset token.");
                return;
            }
            if (token.isCollateral) {
                alert(`Asset token ${tokenId} is currently collateral for a loan (${token.collateralForLoanId}). It cannot be transferred.`);
                return;
            }
            if (token.isInsured) {
                alert(`Asset token ${tokenId} is currently insured by a policy (${token.insuredPolicyId}). It cannot be transferred.`);
                return;
            }

            const transferData = {
                tokenId: tokenId,
                fromClientId: myClientId,
                toClientId: recipientClientId,
                timestamp: Date.now()
            };

            await signAndPublish(ASSETS_TOPIC + 'transfer', transferData, 'TRANSFER_ASSET_TOKEN', `transfer_${tokenId}_${Date.now()}`);
            appendLog(`Transferred asset token ${tokenId} to ${recipientClientId.substring(0,10)}...`, 'success');

            document.getElementById('transferAssetTokenId').value = '';
            document.getElementById('transferRecipientClientId').value = '';
        }

        // --- New Lending & Loans Functions ---
        async function requestLoan() {
            const amount = parseFloat(document.getElementById('loanAmount').value);
            const collateralTokenId = document.getElementById('loanCollateralTokenId').value.trim();
            const interestRate = parseFloat(document.getElementById('loanInterestRate').value);
            const repaymentDueDate = document.getElementById('loanRepaymentDueDate').value;

            if (!amount || isNaN(amount) || amount <= 0 || !collateralTokenId || !interestRate || isNaN(interestRate) || interestRate < 0 || !repaymentDueDate) {
                alert("Please fill all loan request fields correctly.");
                return;
            }

            const collateralToken = assetTokens.get(collateralTokenId);
            if (!collateralToken || collateralToken.ownerClientId !== myClientId) {
                alert("You do not own this collateral asset token or it does not exist.");
                return;
            }
            if (collateralToken.isCollateral) {
                alert(`Asset token ${collateralTokenId} is already used as collateral for another loan.`);
                return;
            }

            const loanId = `loan_${crypto.randomUUID()}`;
            const loanData = {
                id: loanId,
                borrowerClientId: myClientId,
                amount: amount,
                collateralTokenId: collateralTokenId,
                interestRate: interestRate,
                repaymentDueDate: new Date(repaymentDueDate).getTime(),
                timestamp: Date.now(),
                status: 'pending'
            };

            await signAndPublish(LOANS_TOPIC + 'requests', loanData, 'REQUEST_LOAN', loanId);
            appendLog(`Requested loan of ${amount} UBHP with collateral ${collateralTokenId}.`, 'success');

            document.getElementById('loanAmount').value = '';
            document.getElementById('loanCollateralTokenId').value = '';
            document.getElementById('loanInterestRate').value = '';
            document.getElementById('loanRepaymentDueDate').value = '';
        }

        async function offerLoan(loanIdFromUI = null) {
            const loanId = loanIdFromUI || document.getElementById('offerLoanId').value.trim();
            const offeredInterestRate = parseFloat(document.getElementById(`offerInterestRate_${loanId}`)?.value || document.getElementById('offerLoanInterestRate').value);

            if (!loanId || isNaN(offeredInterestRate) || offeredInterestRate < 0) {
                alert("Please provide a valid Loan Request ID and offered interest rate.");
                return;
            }

            const loanRequest = loans.get(loanId);
            if (!loanRequest || loanRequest.status !== 'pending') {
                alert("Loan request not found or is no longer pending.");
                return;
            }
            if (loanRequest.borrowerClientId === myClientId) {
                alert("You cannot offer a loan to yourself.");
                return;
            }

            const offerId = `loan_offer_${crypto.randomUUID()}`;
            const offerData = {
                id: offerId,
                loanId: loanId,
                lenderClientId: myClientId,
                interestRate: offeredInterestRate,
                timestamp: Date.now(),
                status: 'pending'
            };

            await signAndPublish(LOANS_TOPIC + 'offers', offerData, 'OFFER_LOAN', offerId);
            appendLog(`Offered loan for request ${loanId} at ${offeredInterestRate}% interest.`, 'success');

            if (!loanIdFromUI) { // Only clear if not called from other buttons
                document.getElementById('offerLoanId').value = '';
                document.getElementById('offerLoanInterestRate').value = '';
            }
        }

        async function acceptLoanOffer(loanId, offerId) {
            const loan = loans.get(loanId);
            if (!loan || loan.borrowerClientId !== myClientId || loan.status !== 'pending') {
                alert("Loan not found, you are not the borrower, or loan is not pending.");
                return;
            }
            const offer = loan.offers.get(offerId);
            if (!offer) {
                alert("Offer not found for this loan.");
                return;
            }

            const acceptData = {
                loanId: loanId,
                offerId: offerId,
                actorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(LOANS_TOPIC + 'actions', acceptData, 'ACCEPT_LOAN_OFFER', `accept_${loanId}_${offerId}`);
            appendLog(`Accepted loan offer ${offerId} for loan ${loanId}.`, 'success');
        }

        async function repayLoan(loanIdFromUI = null) {
            const loanId = loanIdFromUI || document.getElementById('repayLoanId').value.trim();
            if (!loanId) {
                alert("Please enter a Loan ID to repay.");
                return;
            }

            const loan = loans.get(loanId);
            if (!loan || loan.borrowerClientId !== myClientId || loan.status !== 'active') {
                alert("Loan not found, you are not the borrower, or loan is not active.");
                return;
            }

            const repayData = {
                loanId: loanId,
                actorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(LOANS_TOPIC + 'actions', repayData, 'REPAY_LOAN', `repay_${loanId}`);
            appendLog(`Repaid loan ${loanId}.`, 'success');

            if (!loanIdFromUI) {
                document.getElementById('repayLoanId').value = '';
            }
        }

        async function declareLoanDefault(loanIdFromUI = null) {
            const loanId = loanIdFromUI || document.getElementById('defaultLoanId').value.trim();
            if (!loanId) {
                alert("Please enter a Loan ID to declare default.");
                return;
            }

            const loan = loans.get(loanId);
            if (!loan || loan.lenderClientId !== myClientId || loan.status !== 'active') {
                alert("Loan not found, you are not the lender, or loan is not active.");
                return;
            }

            const defaultData = {
                loanId: loanId,
                actorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(LOANS_TOPIC + 'actions', defaultData, 'DEFAULT_LOAN', `default_${loanId}`);
            appendLog(`Declared loan ${loanId} as defaulted.`, 'error');

            if (!loanIdFromUI) {
                document.getElementById('defaultLoanId').value = '';
            }
        }

        // --- New Grants Functions ---
        async function issueGrant() {
            const recipientClientId = document.getElementById('grantRecipientClientId').value.trim();
            const amount = parseFloat(document.getElementById('grantAmount').value);
            const description = document.getElementById('grantDescription').value.trim();

            if (!recipientClientId || !amount || isNaN(amount) || amount <= 0 || !description) {
                alert("Please fill all grant fields correctly.");
                return;
            }

            const grantId = `grant_${crypto.randomUUID()}`;
            const grantData = {
                id: grantId,
                grantorClientId: myClientId,
                recipientClientId: recipientClientId,
                amount: amount,
                description: description,
                timestamp: Date.now()
            };

            await signAndPublish(GRANTS_TOPIC + 'issue', grantData, 'ISSUE_GRANT', grantId);
            appendLog(`Issued grant of ${amount} UBHP to ${recipientClientId.substring(0,10)}...`, 'success');

            document.getElementById('grantRecipientClientId').value = '';
            document.getElementById('grantAmount').value = '';
            document.getElementById('grantDescription').value = '';
        }

        // --- New Insurance Functions ---
        async function requestInsurance() {
            const insuredTokenId = document.getElementById('insuredTokenId').value.trim();
            const coverageAmount = parseFloat(document.getElementById('coverageAmount').value);
            const premiumAmount = parseFloat(document.getElementById('premiumAmount').value);
            const policyDurationDays = parseInt(document.getElementById('policyDurationDays').value, 10);

            if (!insuredTokenId || !coverageAmount || isNaN(coverageAmount) || coverageAmount <= 0 ||
                !premiumAmount || isNaN(premiumAmount) || premiumAmount <= 0 ||
                !policyDurationDays || isNaN(policyDurationDays) || policyDurationDays <= 0) {
                alert("Please fill all insurance request fields correctly.");
                return;
            }

            const insuredToken = assetTokens.get(insuredTokenId);
            if (!insuredToken || insuredToken.ownerClientId !== myClientId) {
                alert("You do not own this asset token or it does not exist.");
                return;
            }
            if (insuredToken.isInsured) {
                alert(`Asset token ${insuredTokenId} is already insured by another policy.`);
                return;
            }

            const policyId = `policy_${crypto.randomUUID()}`;
            const expiryDate = Date.now() + (policyDurationDays * 24 * 60 * 60 * 1000); // Days to milliseconds

            const policyData = {
                id: policyId,
                insuredClientId: myClientId,
                insuredTokenId: insuredTokenId,
                coverageAmount: coverageAmount,
                premiumAmount: premiumAmount,
                policyDurationDays: policyDurationDays,
                expiryDate: expiryDate,
                timestamp: Date.now(),
                status: 'pending'
            };

            await signAndPublish(INSURANCE_TOPIC + 'requests', policyData, 'REQUEST_INSURANCE', policyId);
            appendLog(`Requested insurance for token ${insuredTokenId} with coverage ${coverageAmount} UBHP.`, 'success');

            document.getElementById('insuredTokenId').value = '';
            document.getElementById('coverageAmount').value = '';
            document.getElementById('premiumAmount').value = '';
            document.getElementById('policyDurationDays').value = '30';
        }

        async function offerInsurance(policyIdFromUI = null) {
            const policyId = policyIdFromUI || document.getElementById('offerPolicyId').value.trim();
            const offeredPremiumAmount = parseFloat(document.getElementById(`offerPremiumAmount_${policyId}`)?.value || document.getElementById('offerPremiumAmount').value);

            if (!policyId || isNaN(offeredPremiumAmount) || offeredPremiumAmount <= 0) {
                alert("Please provide a valid Insurance Request ID and offered premium amount.");
                return;
            }

            const insuranceRequest = insurancePolicies.get(policyId);
            if (!insuranceRequest || insuranceRequest.status !== 'pending') {
                alert("Insurance request not found or is no longer pending.");
                return;
            }
            if (insuranceRequest.insuredClientId === myClientId) {
                alert("You cannot insure your own policy.");
                return;
            }

            const offerId = `insurance_offer_${crypto.randomUUID()}`;
            const offerData = {
                id: offerId,
                policyId: policyId,
                insurerClientId: myClientId,
                premiumAmount: offeredPremiumAmount,
                expiryDate: insuranceRequest.expiryDate, // Use the requested expiry date
                timestamp: Date.now(),
                status: 'pending'
            };

            await signAndPublish(INSURANCE_TOPIC + 'offers', offerData, 'OFFER_INSURANCE', offerId);
            appendLog(`Offered insurance for policy ${policyId} at ${offeredPremiumAmount} UBHP premium.`, 'success');

            if (!policyIdFromUI) {
                document.getElementById('offerPolicyId').value = '';
                document.getElementById('offerPremiumAmount').value = '';
            }
        }

        async function acceptInsuranceOffer(policyId, offerId) {
            const policy = insurancePolicies.get(policyId);
            if (!policy || policy.insuredClientId !== myClientId || policy.status !== 'pending') {
                alert("Policy not found, you are not the insured, or policy is not pending.");
                return;
            }
            const offer = policy.offers.get(offerId);
            if (!offer) {
                alert("Offer not found for this policy.");
                return;
            }

            const acceptData = {
                policyId: policyId,
                offerId: offerId,
                actorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(INSURANCE_TOPIC + 'actions', acceptData, 'ACCEPT_INSURANCE_OFFER', `accept_${policyId}_${offerId}`);
            appendLog(`Accepted insurance offer ${offerId} for policy ${policyId}.`, 'success');
        }

        async function submitInsuranceClaim(policyIdFromUI = null) {
            const policyId = policyIdFromUI || document.getElementById('claimPolicyId').value.trim();
            const claimDetails = document.getElementById('claimDetails').value.trim();

            if (!policyId || !claimDetails) {
                alert("Please provide Policy ID and claim details.");
                return;
            }

            const policy = insurancePolicies.get(policyId);
            if (!policy || policy.insuredClientId !== myClientId || policy.status !== 'active') {
                alert("Policy not found, you are not the insured, or policy is not active.");
                return;
            }

            const claimId = `claim_${crypto.randomUUID()}`;
            const claimData = {
                claimId: claimId,
                policyId: policyId,
                claimDetails: claimDetails,
                actorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(INSURANCE_TOPIC + 'claims', claimData, 'SUBMIT_INSURANCE_CLAIM', claimId);
            appendLog(`Submitted claim for policy ${policyId}.`, 'success');

            if (!policyIdFromUI) {
                document.getElementById('claimPolicyId').value = '';
                document.getElementById('claimDetails').value = '';
            }
        }

        async function approveInsuranceClaim(policyIdFromUI = null, claimIdFromUI = null) {
            const policyId = policyIdFromUI || document.getElementById('manageClaimPolicyId').value.trim();
            const claimId = claimIdFromUI || document.getElementById('manageClaimId').value.trim();

            if (!policyId || !claimId) {
                alert("Please provide Policy ID and Claim ID.");
                return;
            }

            const policy = insurancePolicies.get(policyId);
            if (!policy || policy.insurerClientId !== myClientId) {
                alert("You are not the insurer for this policy.");
                return;
            }
            const claim = policy.claims.find(c => c.claimId === claimId);
            if (!claim || claim.claimStatus !== 'pending_review') {
                alert("Claim not found or not in pending review status.");
                return;
            }

            const approveData = {
                policyId: policyId,
                claimId: claimId,
                actorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(INSURANCE_TOPIC + 'claim_actions', approveData, 'APPROVE_INSURANCE_CLAIM', `approve_claim_${claimId}`);
            appendLog(`Approved claim ${claimId} for policy ${policyId}.`, 'success');

            if (!policyIdFromUI) {
                document.getElementById('manageClaimPolicyId').value = '';
                document.getElementById('manageClaimId').value = '';
            }
        }

        async function rejectInsuranceClaim(policyIdFromUI = null, claimIdFromUI = null) {
            const policyId = policyIdFromUI || document.getElementById('manageClaimPolicyId').value.trim();
            const claimId = claimIdFromUI || document.getElementById('manageClaimId').value.trim();

            if (!policyId || !claimId) {
                alert("Please provide Policy ID and Claim ID.");
                return;
            }

            const policy = insurancePolicies.get(policyId);
            if (!policy || policy.insurerClientId !== myClientId) {
                alert("You are not the insurer for this policy.");
                return;
            }
            const claim = policy.claims.find(c => c.claimId === claimId);
            if (!claim || claim.claimStatus !== 'pending_review') {
                alert("Claim not found or not in pending review status.");
                return;
            }

            const rejectData = {
                policyId: policyId,
                claimId: claimId,
                actorClientId: myClientId,
                timestamp: Date.now()
            };

            await signAndPublish(INSURANCE_TOPIC + 'claim_actions', rejectData, 'REJECT_INSURANCE_CLAIM', `reject_claim_${claimId}`);
            appendLog(`Rejected claim ${claimId} for policy ${policyId}.`, 'error');

            if (!policyIdFromUI) {
                document.getElementById('manageClaimPolicyId').value = '';
                document.getElementById('manageClaimId').value = '';
            }
        }


        // --- OpenPGP Functions ---
        async function generateOpenPGPKeyPair() {
            const passphrase = wallet.mnemonic.phrase;
            const { privateKey, publicKey } = await openpgp.generateKey({
                type: 'ecc',
                curve: 'curve25519',
                userIDs: [{ name: myClientId, email: `${myClientId}@ubhp.xyz` }],
                passphrase: passphrase,
            });
            myOpenPGPPublicKey = publicKey;
            myOpenPGPPrivateKey = privateKey;
            appendLog("Generated OpenPGP keypair.", 'success');
        }

        async function publishPublicKey() {
            if (myOpenPGPPublicKey) {
                const keyData = {
                    clientId: myClientId,
                    publicKeyArmored: myOpenPGPPublicKey.armoredKey,
                };
                await signAndPublish(KEY_EXCHANGE_TOPIC + 'announcements', keyData, 'KEY_EXCHANGE_PUBLIC_KEY', `key_${myClientId}`);
                appendLog("Published OpenPGP Public Key.", 'success');
            }
        }

        async function encryptWithOpenPGP(message, recipientPublicKeyObject) {
            const { message: encryptedMessage } = await openpgp.encrypt({
                message: await openpgp.createMessage({ text: message }),
                encryptionKeys: recipientPublicKeyObject,
            });
            return encryptedMessage;
        }

        async function decryptWithOpenPGP(encryptedMessageArmored, privateKeyObject, passphrase) {
            const message = await openpgp.readMessage({ armoredMessage: encryptedMessageArmored });
            const { data } = await openpgp.decrypt({
                message,
                decryptionKeys: privateKeyObject,
                passwords: [passphrase]
            });
            return { data };
        }

        // --- Preshared Key (PSK) Functions ---
        function setCurrentPSK() {
            const psk = document.getElementById('presharedKeyInput').value;
            if (psk.length < 16) {
                alert("PSK should be at least 16 characters for security.");
                return;
            }
            currentPSK = psk;
            appendLog("Preshared Key set.", 'success');
        }

        async function getDerivedKey(psk) {
            const enc = new TextEncoder();
            const salt = enc.encode('ubhp_psk_salt_for_derivation'); // Fixed salt for consistent key derivation
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                enc.encode(psk),
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            );
            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256',
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
            return key;
        }

        async function encryptWithPSK(message, psk) {
            if (!psk) throw new Error("Preshared Key not set.");
            const key = await getDerivedKey(psk);
            const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV for AES-GCM
            const encoded = textEncoder.encode(message);

            const ciphertext = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encoded
            );

            // Convert ArrayBuffer to Base64 strings for storage/transmission
            const ivB64 = btoa(String.fromCharCode.apply(null, iv));
            const cipherB64 = btoa(String.fromCharCode.apply(null, new Uint8Array(ciphertext)));

            return JSON.stringify({ iv: ivB64, cipher: cipherB64 });
        }

        async function decryptWithPSK(encryptedDataString, psk) {
            if (!psk) throw new Error("Preshared Key not set.");

            const { iv: ivB64, cipher: cipherB64 } = JSON.parse(encryptedDataString);

            // Convert Base64 strings back to Uint8Array
            const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
            const ciphertext = Uint8Array.from(atob(cipherB64), c => c.charCodeAt(0));

            const key = await getDerivedKey(psk);

            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                ciphertext
            );

            return textDecoder.decode(decrypted);
        }

        // --- Messaging Logic ---
        async function sendMessage() {
            const recipientClientId = document.getElementById('messageRecipientClientId').value.trim();
            const messageType = document.getElementById('messageType').value;
            const messageContent = document.getElementById('messageContent').value;

            if (!messageContent) {
                alert("Message content cannot be empty.");
                return;
            }

            let topic;
            let msgPayload = {
                content: messageContent,
                encryptionType: messageType,
                recipientClientId: recipientClientId || 'public'
            };

            if (messageType === 'public') {
                topic = MESSAGING_TOPIC + 'public';
            } else if (messageType === 'openpgp') {
                if (!recipientClientId) {
                    alert("Please specify a recipient Client ID for OpenPGP message.");
                    return;
                }
                const recipientPublicKey = knownPublicKeys.get(recipientClientId);
                if (!recipientPublicKey) {
                    alert(`No OpenPGP public key known for ${recipientClientId}. Please add it first.`);
                    return;
                }
                const encrypted = await encryptWithOpenPGP(messageContent, recipientPublicKey);
                msgPayload.encryptedPayload = encrypted;
                msgPayload.content = null; // Clear plain content for encrypted messages
                topic = MESSAGING_TOPIC + recipientClientId;
            } else if (messageType === 'psk') {
                if (!recipientClientId) {
                    alert("Please specify a recipient Client ID for PSK message.");
                    return;
                }
                if (!currentPSK) {
                    alert("Please set a Preshared Key first.");
                    return;
                }
                const encrypted = await encryptWithPSK(messageContent, currentPSK);
                msgPayload.encryptedPayload = encrypted;
                msgPayload.content = null; // Clear plain content for encrypted messages
                topic = MESSAGING_TOPIC + recipientClientId;
            } else {
                alert("Invalid message type selected.");
                return;
            }

            await signAndPublish(topic, msgPayload, 'MESSAGING_EVENT');
            appendLog(`Sent ${messageType} message to ${recipientClientId || 'public'}.`, 'success');

            document.getElementById('messageContent').value = '';
        }

        function addKnownPublicKey() {
            const clientId = document.getElementById('peerClientIdForKey').value.trim();
            const armoredKey = document.getElementById('peerOpenPGPPublicKeyInput').value.trim();

            if (!clientId || !armoredKey) {
                alert("Please provide both Client ID and Armored Public Key.");
                return;
            }

            try {
                // Directly apply the state update for known public keys
                applyLocalStateUpdate({
                    id: `manual_key_add_${clientId}`,
                    type: 'KEY_EXCHANGE_PUBLIC_KEY',
                    data: { clientId: clientId, publicKeyArmored: armoredKey }
                });
                appendLog(`Added OpenPGP public key for ${clientId}.`, 'success');
                document.getElementById('peerClientIdForKey').value = '';
                document.getElementById('peerOpenPGPPublicKeyInput').value = '';
            } catch (e) {
                console.error("Failed to add public key:", e);
                appendLog(`Error adding public key: ${e.message}`, 'error');
            }
        }

        // --- Media Attachment Logic (re-using previous code) ---
        let adAudioBlob = null;
        let adVideoBlob = null;
        let videoStream = null;
        let adSnapshotBlob = null;
        let snapshotStream = null;
        let adUploadedImageBase64 = null;
        let adUploadedImageMimeType = null;
        let adRecognizedText = '';
        let speechRecognition = null;
        let isSpeechListening = false;
        let adGeolocation = null;
        let adUploadedFileBase64 = null;
        let adUploadedFileMimeType = null;
        let adUploadedFileName = null;
        let adDrawingCommands = [];
        let adCanvasCurrentMode = 'draw';
        let adCanvasIsDrawing = false;
        let adCanvasLastX = 0;
        let adCanvasLastY = 0;

        document.getElementById('recordAdAudioButton').addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                adMediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                let audioChunks = []; adMediaRecorder.ondataavailable = event => { audioChunks.push(event.data); };
                adMediaRecorder.onstop = () => {
                    adAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const audioUrl = URL.createObjectURL(adAudioBlob);
                    document.getElementById('adAudioPlayback').src = audioUrl; document.getElementById('adAudioPlayback').classList.remove('hidden');
                    document.getElementById('playAdAudioButton').disabled = false; displayStatus('adAudioStatus', 'Audio recorded. Ready to attach to ad.', 'info');
                    isAdAudioRecording = false;
                };
                adMediaRecorder.start(); isAdAudioRecording = true;
                document.getElementById('recordAdAudioButton').disabled = true; document.getElementById('stopAdAudioButton').disabled = false; document.getElementById('playAdAudioButton').disabled = true;
                displayStatus('adAudioStatus', 'Recording audio for ad...', 'info');
            } catch (error) { console.error('Error accessing microphone:', error); displayStatus('adAudioStatus', `Error accessing microphone: ${error.message}`, 'error'); document.getElementById('recordAdAudioButton').disabled = false; document.getElementById('stopAdAudioButton').disabled = true; document.getElementById('playAdAudioButton').disabled = true; }
        });

        document.getElementById('stopAdAudioButton').addEventListener('click', () => {
            if (adMediaRecorder && isAdAudioRecording) { adMediaRecorder.stop(); adMediaRecorder.stream.getTracks().forEach(track => track.stop()); document.getElementById('stopAdAudioButton').disabled = true; document.getElementById('recordAdAudioButton').disabled = false; }
        });

        document.getElementById('playAdAudioButton').addEventListener('click', () => {
            if (document.getElementById('adAudioPlayback').src) { document.getElementById('adAudioPlayback').play(); displayStatus('adAudioStatus', 'Playing ad audio...', 'info'); }
        });

        document.getElementById('startAdVideoButton').addEventListener('click', async () => {
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                document.getElementById('webcamVideoPreview').srcObject = videoStream; document.getElementById('webcamVideoPreview').classList.remove('hidden');
                adVideoRecorder = new MediaRecorder(videoStream, { mimeType: 'video/webm' });
                let videoChunks = []; adVideoRecorder.ondataavailable = event => { videoChunks.push(event.data); };
                adVideoRecorder.onstop = () => {
                    adVideoBlob = new Blob(videoChunks, { type: 'video/webm' });
                    const videoUrl = URL.createObjectURL(adVideoBlob);
                    document.getElementById('adVideoPlayback').src = videoUrl; document.getElementById('adVideoPlayback').classList.remove('hidden');
                    document.getElementById('playAdVideoButton').disabled = false; displayStatus('adVideoStatus', 'Video recorded. Ready to attach to ad.', 'info');
                    isAdVideoRecording = false;
                    document.getElementById('webcamVideoPreview').classList.add('hidden');
                    if (videoStream) { videoStream.getTracks().forEach(track => track.stop()); videoStream = null; }
                };
                adVideoRecorder.start(); isAdVideoRecording = true;
                document.getElementById('startAdVideoButton').disabled = true; document.getElementById('stopAdVideoButton').disabled = false; document.getElementById('playAdVideoButton').disabled = true;
                displayStatus('adVideoStatus', 'Recording video for ad...', 'info');
            } catch (error) { console.error('Error accessing webcam for video:', error); displayStatus('adVideoStatus', `Error accessing webcam: ${error.message}`, 'error'); document.getElementById('startAdVideoButton').disabled = false; document.getElementById('stopAdVideoButton').disabled = true; document.getElementById('playAdVideoButton').disabled = true; }
        });

        document.getElementById('stopAdVideoButton').addEventListener('click', () => {
            if (adVideoRecorder && isAdVideoRecording) { adVideoRecorder.stop(); }
        });

        document.getElementById('playAdVideoButton').addEventListener('click', () => {
            if (document.getElementById('adVideoPlayback').src) { document.getElementById('adVideoPlayback').play(); displayStatus('adVideoStatus', 'Playing ad video...', 'info'); }
        });

        document.getElementById('startWebcamSnapshotButton').addEventListener('click', async () => {
            try {
                snapshotStream = await navigator.mediaDevices.getUserMedia({ video: true });
                document.getElementById('webcamSnapshotPreview').srcObject = snapshotStream; document.getElementById('webcamSnapshotPreview').classList.remove('hidden');
                document.getElementById('startWebcamSnapshotButton').disabled = true; document.getElementById('takeSnapshotButton').disabled = false; document.getElementById('stopWebcamSnapshotButton').disabled = false;
                displayStatus('adSnapshotStatus', 'Webcam started. Take a snapshot.', 'info');
            } catch (error) { console.error('Error accessing webcam for snapshot:', error); displayStatus('adSnapshotStatus', `Error accessing webcam: ${error.message}`, 'error'); document.getElementById('startWebcamSnapshotButton').disabled = false; document.getElementById('takeSnapshotButton').disabled = true; document.getElementById('stopWebcamSnapshotButton').disabled = true; }
        });

        document.getElementById('takeSnapshotButton').addEventListener('click', () => {
            const canvas = document.createElement('canvas');
            canvas.width = document.getElementById('webcamSnapshotPreview').videoWidth; canvas.height = document.getElementById('webcamSnapshotPreview').videoHeight;
            const ctx = canvas.getContext('2d'); ctx.drawImage(document.getElementById('webcamSnapshotPreview'), 0, 0, canvas.width, canvas.height);
            canvas.toBlob(blob => {
                adSnapshotBlob = blob;
                document.getElementById('imagePreview').src = URL.createObjectURL(blob); document.getElementById('imagePreview').classList.remove('hidden');
                displayStatus('adSnapshotStatus', 'Snapshot taken. Ready to attach.', 'success');
            }, 'image/png');
        });

        document.getElementById('stopWebcamSnapshotButton').addEventListener('click', () => {
            if (snapshotStream) { snapshotStream.getTracks().forEach(track => track.stop()); snapshotStream = null; }
            document.getElementById('webcamSnapshotPreview').classList.add('hidden');
            document.getElementById('startWebcamSnapshotButton').disabled = false; document.getElementById('takeSnapshotButton').disabled = true; document.getElementById('stopWebcamSnapshotButton').disabled = true;
            displayStatus('adSnapshotStatus', 'Webcam stopped.', 'info');
        });

        document.getElementById('uploadImageButton').addEventListener('click', () => { document.getElementById('uploadImageInput').click(); });

        document.getElementById('uploadImageInput').addEventListener('change', (event) => {
            const file = event.target.files[0]; if (!file) { return; }
            if (!file.type.startsWith('image/')) { displayStatus('adImageUploadStatus', 'Please upload an image file.', 'error'); return; }
            const reader = new FileReader(); reader.onload = (e) => {
                adUploadedImageBase64 = e.target.result; adUploadedImageMimeType = file.type;
                document.getElementById('uploadedImagePreview').src = adUploadedImageBase64; document.getElementById('uploadedImagePreview').classList.remove('hidden');
                document.getElementById('clearImageButton').disabled = false; displayStatus('adImageUploadStatus', 'Image uploaded. Ready to attach.', 'success');
            }; reader.readAsDataURL(file);
        });

        document.getElementById('clearImageButton').addEventListener('click', () => {
            adUploadedImageBase64 = null; adUploadedImageMimeType = null;
            document.getElementById('uploadedImagePreview').src = ''; document.getElementById('uploadedImagePreview').classList.add('hidden');
            document.getElementById('clearImageButton').disabled = true; document.getElementById('uploadImageInput').value = '';
            displayStatus('adImageUploadStatus', 'Image cleared.', 'info');
        });

        document.getElementById('startSpeechButton').addEventListener('click', () => {
            if (!('webkitSpeechRecognition' in window)) { displayStatus('adSpeechStatus', 'Speech Recognition not supported by your browser.', 'error'); return; }
            speechRecognition = new webkitSpeechRecognition();
            speechRecognition.continuous = true; speechRecognition.interimResults = true; speechRecognition.lang = 'en-US';
            speechRecognition.onstart = () => { isSpeechListening = true; displayStatus('adSpeechStatus', 'Listening for speech...', 'info'); document.getElementById('startSpeechButton').disabled = true; document.getElementById('stopSpeechButton').disabled = false; };
            speechRecognition.onresult = (event) => {
                let interimTranscript = ''; let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) { finalTranscript += event.results[i][0].transcript; }
                    else { interimTranscript += event.results[i][0].transcript; }
                }
                document.getElementById('adSpeechText').value = adRecognizedText + finalTranscript + interimTranscript;
            };
            speechRecognition.onerror = (event) => { console.error('Speech recognition error:', event.error); displayStatus('adSpeechStatus', `Speech error: ${event.error}`, 'error'); isSpeechListening = false; document.getElementById('startSpeechButton').disabled = false; document.getElementById('stopSpeechButton').disabled = true; };
            speechRecognition.onend = () => {
                isSpeechListening = false; adRecognizedText = document.getElementById('adSpeechText').value;
                displayStatus('adSpeechStatus', 'Speech recognition stopped. Text captured.', 'info');
                document.getElementById('startSpeechButton').disabled = false; document.getElementById('stopSpeechButton').disabled = true;
            };
            speechRecognition.start();
        });

        document.getElementById('stopSpeechButton').addEventListener('click', () => {
            if (speechRecognition && isSpeechListening) { speechRecognition.stop(); }
        });

        document.getElementById('getAdLocationButton').addEventListener('click', () => {
            if (!('geolocation' in navigator)) { displayStatus('adLocationStatus', 'Geolocation not supported by your browser.', 'error'); return; }
            displayStatus('adLocationStatus', 'Getting location...', 'info');
            navigator.geolocation.getCurrentPosition((position) => {
                adGeolocation = { latitude: position.coords.latitude, longitude: position.coords.longitude };
                document.getElementById('adLocationDisplay').textContent = `Lat: ${adGeolocation.latitude.toFixed(4)}, Lon: ${adGeolocation.longitude.toFixed(4)}`;
                document.getElementById('adLocationDisplay').classList.remove('hidden');
                document.getElementById('clearAdLocationButton').disabled = false;
                displayStatus('adLocationStatus', 'Location captured. Ready to attach.', 'success');
            }, (error) => {
                console.error('Geolocation error:', error); displayStatus('adLocationStatus', `Location error: ${error.message}`, 'error');
            });
        });

        document.getElementById('clearAdLocationButton').addEventListener('click', () => {
            adGeolocation = null; document.getElementById('adLocationDisplay').textContent = ''; document.getElementById('adLocationDisplay').classList.add('hidden');
            document.getElementById('clearAdLocationButton').disabled = true; displayStatus('adLocationStatus', 'Location cleared.', 'info');
        });

        document.getElementById('uploadFileAdButton').addEventListener('click', () => { document.getElementById('uploadFileAdInput').click(); });

        document.getElementById('uploadFileAdInput').addEventListener('change', (event) => {
            const file = event.target.files[0]; if (!file) { return; }
            const reader = new FileReader(); reader.onload = (e) => {
                adUploadedFileBase64 = e.target.result; adUploadedFileMimeType = file.type; adUploadedFileName = file.name;
                document.getElementById('adFileNameDisplay').textContent = `File: ${adUploadedFileName} (${(file.size / 1024).toFixed(2)} KB)`;
                document.getElementById('adFileNameDisplay').classList.remove('hidden');
                document.getElementById('clearFileAdButton').disabled = false; displayStatus('adFileUploadStatus', 'File uploaded. Ready to attach.', 'success');
            }; reader.readAsDataURL(file);
        });

        document.getElementById('clearFileAdButton').addEventListener('click', () => {
            adUploadedFileBase64 = null; adUploadedFileMimeType = null; adUploadedFileName = null;
            document.getElementById('adFileNameDisplay').textContent = ''; document.getElementById('adFileNameDisplay').classList.add('hidden');
            document.getElementById('clearFileAdButton').disabled = true; document.getElementById('uploadFileAdInput').value = '';
            displayStatus('adFileUploadStatus', 'File cleared.', 'info');
        });

        const adSharedCanvas = document.getElementById('adSharedCanvas');
        const adCtx = adSharedCanvas.getContext('2d');
        adCtx.lineCap = 'round'; adCtx.lineJoin = 'round';

        function setAdCanvasDrawingMode(mode) {
            adCanvasCurrentMode = mode;
            document.getElementById('adCanvasDrawModeButton').classList.toggle('active', mode === 'draw');
            document.getElementById('adCanvasTextModeButton').classList.toggle('active', mode === 'text');
            document.getElementById('adCanvasImageModeButton').classList.toggle('active', mode === 'image');
            adSharedCanvas.style.cursor = mode === 'draw' ? 'crosshair' : 'text';
            if (mode === 'image') adSharedCanvas.style.cursor = 'copy';
        }

        document.getElementById('adCanvasDrawModeButton').addEventListener('click', () => setAdCanvasDrawingMode('draw'));
        document.getElementById('adCanvasTextModeButton').addEventListener('click', () => setAdCanvasDrawingMode('text'));
        document.getElementById('adCanvasImageModeButton').addEventListener('click', () => setAdCanvasDrawingMode('image'));

        document.getElementById('adCanvasColorPicker').addEventListener('input', () => { adCtx.strokeStyle = document.getElementById('adCanvasColorPicker').value; adCtx.fillStyle = document.getElementById('adCanvasColorPicker').value; });
        document.getElementById('adCanvasLineWidth').addEventListener('input', () => { adCtx.lineWidth = document.getElementById('adCanvasLineWidth').value; });

        document.getElementById('clearAdCanvasButton').addEventListener('click', () => {
            adCtx.clearRect(0, 0, adSharedCanvas.width, adSharedCanvas.height);
            adDrawingCommands = []; displayStatus('adCanvasStatus', 'Ad canvas cleared.', 'info');
        });

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: (evt.clientX - rect.left) * (canvas.width / rect.width), y: (evt.clientY - rect.height) * (canvas.height / rect.height) };
        }

        adSharedCanvas.addEventListener('mousedown', (e) => {
            if (!wallet) { displayStatus('adCanvasStatus', 'Please generate wallet first to interact with canvas.', 'error'); return; }
            const pos = getMousePos(adSharedCanvas, e); adCanvasLastX = pos.x; adCanvasLastY = pos.y; adCanvasIsDrawing = true;
            if (adCanvasCurrentMode === 'text') {
                const text = prompt('Enter text:');
                if (text) {
                    const command = { type: 'text', text: text, x: pos.x, y: pos.y, font: `${document.getElementById('adCanvasLineWidth').value * 5}px Inter`, color: document.getElementById('adCanvasColorPicker').value };
                    adDrawingCommands.push(command); redrawCanvasContent(adCtx, [command]);
                } adCanvasIsDrawing = false;
            } else if (adCanvasCurrentMode === 'image') {
                const command = { type: 'image_placeholder', x: pos.x - 25, y: pos.y - 25, width: 50, height: 50, color: document.getElementById('adCanvasColorPicker').value, contentAddress: `image-placeholder-${Math.random().toString(36).substring(7)}` };
                adDrawingCommands.push(command); redrawCanvasContent(adCtx, [command]); adCanvasIsDrawing = false;
            }
        });

        adSharedCanvas.addEventListener('mousemove', (e) => {
            if (!adCanvasIsDrawing || adCanvasCurrentMode !== 'draw') return;
            const pos = getMousePos(adSharedCanvas, e);
            const command = { type: 'line', x1: adCanvasLastX, y1: adCanvasLastY, x2: pos.x, y2: pos.y, color: document.getElementById('adCanvasColorPicker').value, width: document.getElementById('adCanvasLineWidth').value };
            adDrawingCommands.push(command); redrawCanvasContent(adCtx, [command]);
            adCanvasLastX = pos.x; adCanvasLastY = pos.y;
        });

        adSharedCanvas.addEventListener('mouseup', () => { adCanvasIsDrawing = false; });
        adSharedCanvas.addEventListener('mouseout', () => { adCanvasIsDrawing = false; });

        function redrawCanvasContent(targetCtx, commands) {
            targetCtx.clearRect(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
            commands.forEach(command => {
                targetCtx.strokeStyle = command.color; targetCtx.fillStyle = command.color; targetCtx.lineWidth = command.width;
                if (command.type === 'line') { targetCtx.beginPath(); targetCtx.moveTo(command.x1, command.y1); targetCtx.lineTo(command.x2, command.y2); targetCtx.stroke(); }
                else if (command.type === 'text') { targetCtx.font = command.font; targetCtx.fillText(command.text, command.x, command.y); }
                else if (command.type === 'image_placeholder') { targetCtx.fillRect(command.x, command.y, command.width, command.height); targetCtx.strokeRect(command.x, command.y, command.width, command.height); targetCtx.font = '10px Inter'; targetCtx.fillStyle = 'white'; targetCtx.fillText('IMG', command.x + 10, command.y + 30); }
            });
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function displayStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.className = `status-message ${type === 'success' ? 'success' : type === 'error' ? 'error' : 'status-info'}`;
                element.classList.remove('hidden');
            }
        }

        function appendLog(message, type = 'info') {
            const feed = document.getElementById('marketplaceFeed');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
            feed.prepend(entry);
        }

        document.addEventListener('DOMContentLoaded', () => {
            updateUIFromState();
            setAdCanvasDrawingMode('draw');
            adCtx.strokeStyle = document.getElementById('adCanvasColorPicker').value;
            adCtx.fillStyle = document.getElementById('adCanvasColorPicker').value;
            adCtx.lineWidth = document.getElementById('adCanvasLineWidth').value;
        });
    </script>
</body>
</html>
