<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computational Universe Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(26, 32, 44, 0.8);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 1rem;
            padding: 1rem;
            background-color: rgba(26, 32, 44, 0.8);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 1rem;
            z-index: 10;
        }
        button {
            background-color: #4a5568; /* Darker gray */
            color: #e2e8f0;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background-color: #6a758a; /* Lighter gray on hover */
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            white-space: nowrap;
            pointer-events: none; /* Allow mouse events to pass through */
            transform: translate(-50%, -100%); /* Center above the point */
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .label.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="info-panel" class="text-sm">
        <p><strong>Phase:</strong> <span id="current-phase">Initializing...</span></p>
        <p><strong>Points:</strong> <span id="point-count">0</span></p>
        <p><strong>Axiom:</strong> <span id="current-axiom">None</span></p>
        <p>Drag to rotate, scroll to zoom.</p>
    </div>

    <div id="controls">
        <button id="continue-button" disabled>Continue</button>
        <button id="reset-button">Reset</button>
    </div>

    <script type="module">
        // --- UBHP and Computational Universe Model Axioms ---
        // These are directly from your provided files, simplified to just axiom names.
        const allInitialAxiomSystems = [
            ["LineBetweenPoints", "A straight line can be drawn between any two points."],
            ["LineExtension", "A finite line can be extended indefinitely in a straight line."],
            ["CircleConstruction", "A circle can be drawn with any center and radius."],
            ["RightAngleEquality", "All right angles are equal."],
            ["ParallelPostulate", "If a line intersects two lines and the interior angles are less than two right angles, those lines will meet on that side."],
            ["StateVector", "A system’s state is a vector in a complex Hilbert space."],
            ["ObservablesHermitian", "Observables are Hermitian operators on that space."],
            ["MeasurementCollapse", "Measurement collapses state into an eigenstate of the operator."],
            ["BornRule", "Probability is given by the squared amplitude of the projection."],
            ["UnitaryEvolution", "The system evolves unitarily over time (Schrödinger’s Equation)."],
            ["Commutativity", "a + b = b + a"],
            ["Associativity", "(a + b) + c = a + (b + c)"],
            ["Distributivity", "a × (b + c) = (a × b) + (a × c)"],
            ["Identity", "a + 0 = a"],
            ["Complement", "a + a′ = 1"],
            ["ZeroIsNatural", "0 is a natural number."],
            ["SuccessorExists", "Every number has a unique successor."],
            ["NoPredecessorForZero", "0 is not the successor of any number."],
            ["InjectiveSuccessor", "If S(a) = S(b), then a = b."],
            ["Induction", "If a property holds for 0 and for S(n), it holds for all n."],
            ["FoldThroughTwoPoints", "A fold can be made that passes through two points."],
            ["FoldPointOntoPoint", "A fold can place one point onto another."],
            ["FoldLineOntoLine", "A fold can place one line onto another."],
            ["PerpendicularFromPoint", "A fold can be perpendicular to a line through a point."],
            ["PointToLineThroughPoint", "A fold brings a point to a line and passes through another point."],
        ];

        // --- Three.js Setup ---
        let scene, camera, renderer;
        let points = [];
        let labels = [];
        let lines = [];
        let currentPhase = 0;
        let animationFrameId;
        let pointAddInterval;
        let axiomIndex = 0; // To cycle through axioms

        const infoPanel = document.getElementById('info-panel');
        const currentPhaseSpan = document.getElementById('current-phase');
        const pointCountSpan = document.getElementById('point-count');
        const currentAxiomSpan = document.getElementById('current-axiom');
        const continueButton = document.getElementById('continue-button');
        const resetButton = document.getElementById('reset-button');

        const phases = [
            { name: "Initial Axiom Set (25 Axioms)", maxPoints: allInitialAxiomSystems.length, pointScale: 0.1, lineDensity: 0, layout: 'grid' },
            { name: "Expansion (100 Points)", maxPoints: 100, pointScale: 0.08, lineDensity: 0.1, layout: 'sphere' },
            { name: "Expansion (500 Points)", maxPoints: 500, pointScale: 0.06, lineDensity: 0.2, layout: 'cloud' },
            { name: "Expansion (1500 Points)", maxPoints: 1500, pointScale: 0.04, lineDensity: 0.3, layout: 'cube' },
            { name: "Expansion (3000 Points)", maxPoints: 3000, pointScale: 0.03, lineDensity: 0.4, layout: 'dual-cubes' },
            { name: "Expansion (6000 Points)", maxPoints: 6000, pointScale: 0.02, lineDensity: 0.5, layout: 'quad-cubes' },
            { name: "Full Dual Inverse Merkaba God Complex (10000 Points)", maxPoints: 10000, pointScale: 0.015, lineDensity: 0.7, layout: 'merkaba' }
        ];

        // --- Mouse and Touch Interaction for Camera (OrbitControls-like behavior) ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let initialPinchDistance = 0;
        let rotationSpeed = 0.005;
        let zoomSpeed = 0.1;

        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            scene.rotation.y += deltaX * rotationSpeed;
            scene.rotation.x += deltaY * rotationSpeed;
            scene.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, scene.rotation.x));

            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * zoomSpeed;
            camera.position.z = Math.max(5, Math.min(200, camera.position.z)); // Clamp zoom
        }

        function onTouchStart(event) {
            event.preventDefault(); // Prevent scrolling
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            } else if (event.touches.length === 2) {
                isDragging = false; // Disable single-finger drag for rotation
                initialPinchDistance = getDistance(event.touches[0], event.touches[1]);
            }
        }

        function onTouchMove(event) {
            event.preventDefault(); // Prevent scrolling
            if (event.touches.length === 1 && isDragging) {
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                scene.rotation.y += deltaX * rotationSpeed;
                scene.rotation.x += deltaY * rotationSpeed;
                scene.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, scene.rotation.x));

                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            } else if (event.touches.length === 2) {
                const currentPinchDistance = getDistance(event.touches[0], event.touches[1]);
                const deltaPinch = currentPinchDistance - initialPinchDistance;

                camera.position.z -= deltaPinch * zoomSpeed * 0.1; // Adjust zoom speed for touch
                camera.position.z = Math.max(5, Math.min(200, camera.position.z));

                initialPinchDistance = currentPinchDistance; // Update initial for continuous pinch
            }
        }

        function onTouchEnd() {
            isDragging = false;
            initialPinchDistance = 0;
        }


        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c); // Match body background

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50; // Adjusted for better initial view

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add event listeners for custom controls
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('wheel', onWheel, false);

            // Add touch event listeners
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            continueButton.addEventListener('click', expandUniverse);
            resetButton.addEventListener('click', resetAnimation);

            startPhase(currentPhase);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateLabels();
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            renderer.render(scene, camera);
            updateLabels();
        }

        function clearScene() {
            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            points = [];
            labels.forEach(label => label.element.remove()); // Remove HTML elements
            labels = [];
            lines = [];
            if (pointAddInterval) {
                clearInterval(pointAddInterval);
            }
        }

        function getNextAxiom() {
            const axiom = allInitialAxiomSystems[axiomIndex % allInitialAxiomSystems.length][0];
            axiomIndex++;
            return axiom;
        }

        function createLabelDiv(text) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label';
            labelDiv.textContent = text;
            document.body.appendChild(labelDiv);
            return labelDiv;
        }

        function addPoint(axiomName, x, y, z, phaseConfig) {
            const geometry = new THREE.SphereGeometry(phaseConfig.pointScale, 8, 8); // Smaller spheres
            const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
            const point = new THREE.Mesh(geometry, material);
            point.position.set(x, y, z);
            scene.add(point);
            points.push(point);

            // Create HTML label
            labels.push({ mesh: point, element: createLabelDiv(axiomName), axiom: axiomName });

            currentAxiomSpan.textContent = axiomName;
            pointCountSpan.textContent = points.length;
        }

        function addRandomPoint(phaseConfig) {
            let x, y, z;
            const spread = 20; // Controls the spatial spread of points

            switch (phaseConfig.layout) {
                case 'grid':
                    // For initial phase, a simple grid
                    const gridDim = Math.ceil(Math.cbrt(phaseConfig.maxPoints));
                    const currentIdx = points.length;
                    x = (currentIdx % gridDim) - gridDim / 2;
                    y = (Math.floor(currentIdx / gridDim) % gridDim) - gridDim / 2;
                    z = (Math.floor(currentIdx / (gridDim * gridDim))) - gridDim / 2;
                    break;
                case 'sphere':
                    // Points on a sphere
                    const radius = spread / 2;
                    const phi = Math.acos(2 * Math.random() - 1); // Latitude
                    const theta = Math.random() * Math.PI * 2; // Longitude
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * Math.cos(phi);
                    break;
                case 'cloud':
                    // Random points in a cube
                    x = (Math.random() - 0.5) * spread;
                    y = (Math.random() - 0.5) * spread;
                    z = (Math.random() - 0.5) * spread;
                    break;
                case 'cube':
                    // Points more concentrated towards a cube shape
                    x = (Math.random() - 0.5) * spread;
                    y = (Math.random() - 0.5) * spread;
                    z = (Math.random() - 0.5) * spread;
                    break;
                case 'dual-cubes':
                    // Two distinct clusters
                    const offset = spread / 4;
                    if (points.length % 2 === 0) {
                        x = (Math.random() - 0.5) * spread / 2 + offset;
                        y = (Math.random() - 0.5) * spread / 2 + offset;
                        z = (Math.random() - 0.5) * spread / 2 + offset;
                    } else {
                        x = (Math.random() - 0.5) * spread / 2 - offset;
                        y = (Math.random() - 0.5) * spread / 2 - offset;
                        z = (Math.random() - 0.5) * spread / 2 - offset;
                    }
                    break;
                case 'quad-cubes':
                    // Four distinct clusters
                    const quadOffset = spread / 6;
                    const clusterIndex = points.length % 4;
                    x = (Math.random() - 0.5) * spread / 3;
                    y = (Math.random() - 0.5) * spread / 3;
                    z = (Math.random() - 0.5) * spread / 3;
                    if (clusterIndex === 0) { x += quadOffset; y += quadOffset; z += quadOffset; }
                    else if (clusterIndex === 1) { x -= quadOffset; y += quadOffset; z += quadOffset; }
                    else if (clusterIndex === 2) { x += quadOffset; y -= quadOffset; z += quadOffset; }
                    else { x -= quadOffset; y -= quadOffset; z += quadOffset; }
                    break;
                case 'merkaba':
                    const merkabaSize = 10; // Smaller spread for a tighter merkaba
                    // Vertices of a cube
                    const cubeVertices = [
                        new THREE.Vector3(merkabaSize, merkabaSize, merkabaSize),
                        new THREE.Vector3(merkabaSize, merkabaSize, -merkabaSize),
                        new THREE.Vector3(merkabaSize, -merkabaSize, merkabaSize),
                        new THREE.Vector3(merkabaSize, -merkabaSize, -merkabaSize),
                        new THREE.Vector3(-merkabaSize, merkabaSize, merkabaSize),
                        new THREE.Vector3(-merkabaSize, merkabaSize, -merkabaSize),
                        new THREE.Vector3(-merkabaSize, -merkabaSize, merkabaSize),
                        new THREE.Vector3(-merkabaSize, -merkabaSize, -merkabaSize)
                    ];

                    // Vertices for two interpenetrating tetrahedrons (Star Tetrahedron / Merkaba)
                    // Tetrahedron 1 (pointing up)
                    const tetra1Vertices = [
                        cubeVertices[0], // +++
                        cubeVertices[7], // ---
                        cubeVertices[2], // +-+
                        cubeVertices[5]  // -+-
                    ];

                    // Tetrahedron 2 (pointing down)
                    const tetra2Vertices = [
                        cubeVertices[1], // ++-
                        cubeVertices[6], // --+
                        cubeVertices[3], // +--
                        cubeVertices[4]  // -++
                    ];

                    // Add lines for the tetrahedrons (only once per phase)
                    // We check if any lines already exist to prevent redrawing on every point
                    if (lines.length === 0) {
                        const drawTetrahedron = (vertices, color) => {
                            const edges = [
                                [0, 1], [0, 2], [0, 3],
                                [1, 2], [1, 3], [2, 3]
                            ];
                            edges.forEach(edge => {
                                const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5, linewidth: 2 });
                                const geometry = new THREE.BufferGeometry().setFromPoints([vertices[edge[0]], vertices[edge[1]]]);
                                const line = new THREE.Line(geometry, material);
                                scene.add(line);
                                lines.push(line);
                            });
                        };
                        drawTetrahedron(tetra1Vertices, 0xff0000); // Red for one tetrahedron
                        drawTetrahedron(tetra2Vertices, 0x0000ff); // Blue for the other

                        // Add a central "PEER" point
                        const peerGeometry = new THREE.SphereGeometry(phaseConfig.pointScale * 2, 16, 16);
                        const peerMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 }); // Purple
                        const peerPoint = new THREE.Mesh(peerGeometry, peerMaterial);
                        peerPoint.position.set(0, 0, 0); // Center of the Merkaba
                        scene.add(peerPoint);
                        points.unshift(peerPoint); // Add to beginning of points array for consistent indexing
                        labels.unshift({ mesh: peerPoint, element: createLabelDiv("PEER (Centroid)"), axiom: "PEER (Centroid)" });
                    }

                    // Distribute points for the merkaba
                    const totalVertices = tetra1Vertices.length + tetra2Vertices.length; // 8 vertices total
                    const totalEdges = 6 + 6; // 12 edges total
                    const pointsPerVertex = Math.floor(phaseConfig.maxPoints * 0.05); // 5% on vertices
                    const pointsPerEdge = Math.floor(phaseConfig.maxPoints * 0.10 / totalEdges); // 10% on edges

                    // Adjust currentPointCountInPhase to exclude the always-present PEER point
                    const currentPointCountInPhase = points.length - 1; // Subtract 1 for the PEER point

                    if (currentPointCountInPhase < totalVertices * pointsPerVertex) {
                        // Place points on vertices with some jitter
                        const vertexIndex = Math.floor(currentPointCountInPhase / pointsPerVertex) % totalVertices;
                        let v;
                        if (vertexIndex < tetra1Vertices.length) {
                            v = tetra1Vertices[vertexIndex];
                        } else {
                            v = tetra2Vertices[vertexIndex - tetra1Vertices.length];
                        }
                        x = v.x + (Math.random() - 0.5) * phaseConfig.pointScale * 5;
                        y = v.y + (Math.random() - 0.5) * phaseConfig.pointScale * 5;
                        z = v.z + (Math.random() - 0.5) * phaseConfig.pointScale * 5;
                    } else if (currentPointCountInPhase < totalVertices * pointsPerVertex + totalEdges * pointsPerEdge) {
                        // Place points along edges with some jitter
                        const edgePointIndex = currentPointCountInPhase - (totalVertices * pointsPerVertex);
                        const edgeIndex = Math.floor(edgePointIndex / pointsPerEdge) % totalEdges;
                        const edgeProgress = (edgePointIndex % pointsPerEdge) / pointsPerEdge;

                        const allEdges = [
                            // T1 edges
                            [tetra1Vertices[0], tetra1Vertices[1]], [tetra1Vertices[0], tetra1Vertices[2]], [tetra1Vertices[0], tetra1Vertices[3]],
                            [tetra1Vertices[1], tetra1Vertices[2]], [tetra1Vertices[1], tetra1Vertices[3]], [tetra1Vertices[2], tetra1Vertices[3]],
                            // T2 edges
                            [tetra2Vertices[0], tetra2Vertices[1]], [tetra2Vertices[0], tetra2Vertices[2]], [tetra2Vertices[0], tetra2Vertices[3]],
                            [tetra2Vertices[1], tetra2Vertices[2]], [tetra2Vertices[1], tetra2Vertices[3]], [tetra2Vertices[2], tetra2Vertices[3]]
                        ];

                        const edge = allEdges[edgeIndex];
                        const start = edge[0];
                        const end = edge[1];

                        x = start.x + (end.x - start.x) * edgeProgress + (Math.random() - 0.5) * phaseConfig.pointScale * 3;
                        y = start.y + (end.y - start.y) * edgeProgress + (Math.random() - 0.5) * phaseConfig.pointScale * 3;
                        z = start.z + (end.z - start.z) * edgeProgress + (Math.random() - 0.5) * phaseConfig.pointScale * 3;

                    } else {
                        // Randomly distribute remaining points within the bounding box of the merkaba
                        x = (Math.random() - 0.5) * merkabaSize * 2;
                        y = (Math.random() - 0.5) * merkabaSize * 2;
                        z = (Math.random() - 0.5) * merkabaSize * 2;
                    }
                    break;
                default:
                    x = (Math.random() - 0.5) * spread;
                    y = (Math.random() - 0.5) * spread;
                    z = (Math.random() - 0.5) * spread;
            }

            addPoint(getNextAxiom(), x, y, z, phaseConfig);

            // Add lines between nearby points to represent connections/hyperedges
            if (phaseConfig.lineDensity > 0 && points.length > 1) {
                const numConnections = Math.floor(Math.random() * (points.length * phaseConfig.lineDensity));
                const currentPoint = points[points.length - 1];
                for (let i = 0; i < numConnections; i++) {
                    const otherPoint = points[Math.floor(Math.random() * (points.length - 1))];
                    if (currentPoint !== otherPoint) {
                        const material = new THREE.LineBasicMaterial({ color: 0x34d399, transparent: true, opacity: 0.2 }); // Greenish lines
                        const geometry = new THREE.BufferGeometry().setFromPoints([currentPoint.position, otherPoint.position]);
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        lines.push(line);
                    }
                }
            }
        }

        function updateLabels() {
            labels.forEach(item => {
                const vector = new THREE.Vector3();
                item.mesh.getWorldPosition(vector); // Get world position of the mesh
                vector.project(camera); // Project to screen space

                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

                item.element.style.left = `${x}px`;
                item.element.style.top = `${y}px`;

                // Check if point is in front of camera
                const distance = item.mesh.position.distanceTo(camera.position);
                const maxDistance = 100; // Adjust based on scene scale
                const minOpacity = 0.1;

                // Simple visibility check (can be improved with frustum culling)
                if (vector.z < 1) { // If point is in front of camera
                     // Fade labels based on distance
                    const opacity = Math.max(minOpacity, 1 - (distance / maxDistance));
                    item.element.style.opacity = opacity.toFixed(2);
                    item.element.classList.add('visible');
                } else {
                    item.element.classList.remove('visible');
                }
            });
        }

        function startPhase(phaseIndex) {
            clearScene();
            currentPhase = phaseIndex;
            const phaseConfig = phases[currentPhase];
            currentPhaseSpan.textContent = phaseConfig.name;
            continueButton.disabled = true; // Disable until points are added

            let pointsAdded = 0;
            pointAddInterval = setInterval(() => {
                if (pointsAdded < phaseConfig.maxPoints) {
                    addRandomPoint(phaseConfig);
                    pointsAdded++;
                } else {
                    clearInterval(pointAddInterval);
                    continueButton.disabled = false; // Enable button when phase is complete
                    if (currentPhase === phases.length - 1) {
                        continueButton.textContent = "Animation Complete";
                        continueButton.disabled = true;
                    } else {
                        continueButton.textContent = "Continue to Next Phase";
                    }
                }
            }, 50); // Adjust interval for speed of point addition
        }

        function expandUniverse() {
            if (currentPhase < phases.length - 1) {
                startPhase(currentPhase + 1);
            }
        }

        function resetAnimation() {
            clearScene();
            currentPhase = 0;
            axiomIndex = 0; // Reset axiom index
            continueButton.textContent = "Continue";
            continueButton.disabled = true;
            currentAxiomSpan.textContent = "None";
            pointCountSpan.textContent = "0";
            startPhase(currentPhase);
        }

        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
