<!DOCTYPE html>
<html>
<head>
    <title>MerkabaGodComplex with Interactive Projections</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            font-family: 'Inter', sans-serif;
        }
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
        }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <div id="controls" class="absolute top-4 left-4 p-4 bg-gray-900 bg-opacity-70 text-white rounded-lg shadow-xl w-72 md:w-80 space-y-4 max-h-[80vh] overflow-y-auto z-10">
        <h3 class="text-xl font-bold text-teal-300">CUE Geometric Field</h3>
        <p class="text-sm text-gray-300">Interact with the core structures and their projections.</p>
        
        <!-- View Mode Selector -->
        <div class="space-y-1">
            <label for="viewMode" class="block text-sm font-medium text-gray-400">Active Structure</label>
            <select id="viewMode" class="w-full p-2 rounded-md bg-gray-800 border border-gray-700 text-white">
                <option value="merkaba">Merkaba Structure (7-Fold)</option>
                <option value="axiomatic">Axiomatic Layers (5-Fold)</option>
                <option value="harmonic">Harmonic Field (24-Fold)</option>
                <option value="bridge">Bridge Geometry (35-Fold)</option>
                <option value="emergent">Emergent Geometry</option>
                <option value="twoD">2D Plane Mode</option>
                <option value="sphere">Spherical Geometry Mode</option>
                <option value="tetrahedron">Tetrahedral Axiom Mode</option>
            </select>
        </div>

        <!-- Sliders -->
        <div class="slider-container space-y-1">
            <label for="rotationSpeed" class="block text-sm font-medium text-gray-400">Rotation Speed</label>
            <input type="range" id="rotationSpeed" min="0" max="0.1" step="0.001" value="0.02" class="w-full">
        </div>
        
        <div class="slider-container space-y-1">
            <label for="scaleFactor" class="block text-sm font-medium text-gray-400">Scale Factor</label>
            <input type="range" id="scaleFactor" min="0.5" max="2" step="0.1" value="1" class="w-full">
        </div>
        
        <div class="slider-container space-y-1">
            <label for="harmonicFrequency" class="block text-sm font-medium text-gray-400">Harmonic Frequency</label>
            <input type="range" id="harmonicFrequency" min="0" max="10" step="0.1" value="3" class="w-full">
        </div>
        
        <div class="slider-container space-y-1">
            <label for="projectionStrength" class="block text-sm font-medium text-gray-400">Projection Strength</label>
            <input type="range" id="projectionStrength" min="0" max="2" step="0.1" value="1" class="w-full">
        </div>
        
        <!-- Buttons -->
        <div class="grid grid-cols-2 gap-2">
            <button id="addNineNodeGrid" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors">Add 9-Node Grid</button>
            <button id="addVertex" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">Add Single Vertex</button>
            <button id="toggleAnimation" class="col-span-2 px-4 py-2 bg-emerald-600 text-white rounded-md hover:bg-emerald-700 transition-colors">Pause Animation</button>
            <button id="resetView" class="col-span-1 px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors">Reset View</button>
            <button id="clearVertices" class="col-span-1 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors">Clear Vertices</button>
        </div>
    </div>
    
    <div id="info" class="absolute bottom-4 left-4 p-4 bg-gray-900 bg-opacity-70 text-white rounded-lg shadow-xl w-72 md:w-80 z-10">
        <h4 class="text-lg font-semibold text-teal-300">Instructions</h4>
        <p class="text-sm text-gray-300 mt-2">
            Click "Add 9-Node Grid" to create an interactive 3x3 array of vertices.<br>
            Drag the vertices with your mouse to see their "lie lines" project onto the active CUE structure.<br>
            The projections are based on the core geometric principles of the selected structure.
        </p>
    </div>
    
    <div id="message-box" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-50">
        <div class="bg-gray-800 p-6 rounded-lg text-white text-center shadow-lg">
            <p id="message-text" class="text-lg"></p>
            <button id="close-message" class="mt-4 px-4 py-2 bg-blue-600 rounded-md hover:bg-blue-700 transition-colors">OK</button>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Use a simple custom message box instead of alert()
        function showMessage(text) {
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            messageText.textContent = text;
            messageBox.classList.remove('hidden');
        }
        document.getElementById('close-message').addEventListener('click', () => {
            document.getElementById('message-box').classList.add('hidden');
        });

        // Initialize Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        // Add orbit controls for camera movement
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(0, 5, 10);
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Main groups for each CUE structure
        const merkabaGroup = new THREE.Group();
        scene.add(merkabaGroup);

        const axiomaticGroup = new THREE.Group();
        axiomaticGroup.visible = false;
        scene.add(axiomaticGroup);

        const harmonicGroup = new THREE.Group();
        harmonicGroup.visible = false;
        scene.add(harmonicGroup);

        const bridgeGroup = new THREE.Group();
        bridgeGroup.visible = false;
        scene.add(bridgeGroup);

        const emergentGroup = new THREE.Group();
        emergentGroup.visible = false;
        scene.add(emergentGroup);
        
        // New groups for the requested modes
        const twoDGroup = new THREE.Group();
        twoDGroup.visible = false;
        scene.add(twoDGroup);
        
        const sphereGroup = new THREE.Group();
        sphereGroup.visible = false;
        scene.add(sphereGroup);
        
        const tetrahedronGroup = new THREE.Group();
        tetrahedronGroup.visible = false;
        scene.add(tetrahedronGroup);

        // Group for projected vertices and their lie lines
        const vertexProjectionGroup = new THREE.Group();
        scene.add(vertexProjectionGroup);

        // Colors for the different principles
        const colors = {
            sevenFold: 0xaa00ff,    // Purple for 7-fold
            fiveFold: 0x00aaff,      // Blue for 5-fold
            twentyFourFold: 0xffaa00, // Orange for 24-fold
            thirtyFiveFold: 0x00ffaa, // Teal for 35-fold
            inverse: 0xff0066,        // Pink for inverse
            twoD: 0x00ffff,           // Cyan for 2D plane
            sphere: 0xffaaff,         // Pink-purple for Sphere
            tetrahedron: 0xccff00,    // Lime green for Tetrahedron
            projection: 0x00ff00,     // Green for projected vertices
            lieLine: 0xffff00         // Yellow for lie lines
        };
        
        // --- Structure Creation Functions ---
        function createMerkaba() {
            merkabaGroup.clear();
            const size = 2;
            const geometry = new THREE.TetrahedronGeometry(size);
            
            const materialUp = new THREE.MeshPhongMaterial({
                color: colors.sevenFold, transparent: true, opacity: 0.8, wireframe: false, side: THREE.DoubleSide
            });
            const tetraUp = new THREE.Mesh(geometry, materialUp);
            tetraUp.rotation.y = Math.PI / 4;
            merkabaGroup.add(tetraUp);
            
            const materialDown = new THREE.MeshPhongMaterial({
                color: colors.inverse, transparent: true, opacity: 0.8, wireframe: false, side: THREE.DoubleSide
            });
            const tetraDown = new THREE.Mesh(geometry, materialDown);
            tetraDown.rotation.y = Math.PI / 4;
            tetraDown.rotation.x = Math.PI;
            merkabaGroup.add(tetraDown);
            
            const sphereGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: colors.sevenFold, emissiveIntensity: 0.5 });
            
            for (let i = 0; i < 7; i++) {
                const angle = (i / 7) * Math.PI * 2;
                const radius = size * 1.5;
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial.clone());
                sphere.position.x = Math.cos(angle) * radius;
                sphere.position.z = Math.sin(angle) * radius;
                merkabaGroup.add(sphere);
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0), new THREE.Vector3(sphere.position.x, sphere.position.y, sphere.position.z)
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: colors.sevenFold, transparent: true, opacity: 0.5 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                merkabaGroup.add(line);
            }
            
            const centerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, emissive: colors.sevenFold, emissiveIntensity: 1.0, transparent: true, opacity: 0.9
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            merkabaGroup.add(centerSphere);
        }

        function createAxiomaticLayers() {
            axiomaticGroup.clear();
            const layers = 5;
            const radius = 3;
            const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            
            for (let l = 0; l < layers; l++) {
                const layerRadius = radius * (l + 1) / layers;
                const spheresInLayer = 5 * (l + 1);
                
                for (let i = 0; i < spheresInLayer; i++) {
                    const angle = (i / spheresInLayer) * Math.PI * 2;
                    const sphereMaterial = new THREE.MeshPhongMaterial({ 
                        color: colors.fiveFold, emissive: colors.fiveFold, emissiveIntensity: 0.3
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.x = Math.cos(angle) * layerRadius;
                    sphere.position.z = Math.sin(angle) * layerRadius;
                    sphere.position.y = (l - (layers / 2)) * 0.5;
                    axiomaticGroup.add(sphere);
                    
                    if (i < spheresInLayer - 1) {
                        const nextAngle = ((i + 1) / spheresInLayer) * Math.PI * 2;
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3( Math.cos(angle) * layerRadius, sphere.position.y, Math.sin(angle) * layerRadius ),
                            new THREE.Vector3( Math.cos(nextAngle) * layerRadius, sphere.position.y, Math.sin(nextAngle) * layerRadius )
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({ color: colors.fiveFold, transparent: true, opacity: 0.3 });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        axiomaticGroup.add(line);
                    }
                    
                    if (l < layers - 1) {
                        const nextLayerSpheres = 5 * (l + 2);
                        const correspondingIndex = Math.floor(i * nextLayerSpheres / spheresInLayer);
                        const nextAngle = (correspondingIndex / nextLayerSpheres) * Math.PI * 2;
                        const nextLayerRadius = radius * (l + 2) / layers;
                        
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3( Math.cos(angle) * layerRadius, sphere.position.y, Math.sin(angle) * layerRadius ),
                            new THREE.Vector3( Math.cos(nextAngle) * nextLayerRadius, sphere.position.y + 0.5, Math.sin(nextAngle) * nextLayerRadius )
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({ color: colors.fiveFold, transparent: true, opacity: 0.2 });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        axiomaticGroup.add(line);
                    }
                }
            }
            
            const dodecahedronGeometry = new THREE.DodecahedronGeometry(1);
            const dodecahedronMaterial = new THREE.MeshPhongMaterial({
                color: colors.fiveFold, transparent: true, opacity: 0.7, wireframe: false
            });
            const dodecahedron = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial);
            axiomaticGroup.add(dodecahedron);
        }

        function createHarmonicField() {
            harmonicGroup.clear();
            const size = 4;
            const segments = 24;
            const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            
            const dodecahedronGeometry = new THREE.DodecahedronGeometry(size * 0.8);
            const dodecahedronMaterial = new THREE.MeshPhongMaterial({
                color: colors.twentyFourFold, transparent: true, opacity: 0.2, wireframe: true, side: THREE.DoubleSide
            });
            const dodecahedron1 = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial);
            harmonicGroup.add(dodecahedron1);
            
            const dodecahedron2 = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial.clone());
            dodecahedron2.rotation.y = Math.PI / 5;
            harmonicGroup.add(dodecahedron2);
            
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const radius = size * 1.2;
                
                const sphereMaterial = new THREE.MeshPhongMaterial({ 
                    color: colors.twentyFourFold, emissive: colors.twentyFourFold, emissiveIntensity: 0.5
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.x = Math.cos(angle) * radius;
                sphere.position.z = Math.sin(angle) * radius;
                harmonicGroup.add(sphere);
                
                const nextAngle = ((i + 1) % segments) / segments * Math.PI * 2;
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3( Math.cos(angle) * radius, 0, Math.sin(angle) * radius ),
                    new THREE.Vector3( Math.cos(nextAngle) * radius, 0, Math.sin(nextAngle) * radius )
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: colors.twentyFourFold, transparent: true, opacity: 0.5 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                harmonicGroup.add(line);
                
                const verticalLineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3( Math.cos(angle) * radius, -size * 0.5, Math.sin(angle) * radius ),
                    new THREE.Vector3( Math.cos(angle) * radius, size * 0.5, Math.sin(angle) * radius )
                ]);
                const verticalLine = new THREE.Line(verticalLineGeometry, lineMaterial);
                harmonicGroup.add(verticalLine);
            }
            
            const icosahedronGeometry = new THREE.IcosahedronGeometry(size * 0.4);
            const icosahedronMaterial = new THREE.MeshPhongMaterial({
                color: colors.twentyFourFold, transparent: true, opacity: 0.6, wireframe: false
            });
            const icosahedron = new THREE.Mesh(icosahedronGeometry, icosahedronMaterial);
            harmonicGroup.add(icosahedron);
        }

        function createBridgeGeometry() {
            bridgeGroup.clear();
            const size = 3;
            const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            
            for (let ring = 0; ring < 7; ring++) {
                const radius = size * (ring + 1) / 7;
                const yPos = (ring - 3) * 0.5;
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    
                    const sphereMaterial = new THREE.MeshPhongMaterial({ 
                        color: colors.thirtyFiveFold, emissive: colors.thirtyFiveFold, emissiveIntensity: 0.4
                    });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.x = Math.cos(angle) * radius;
                    sphere.position.z = Math.sin(angle) * radius;
                    sphere.position.y = yPos;
                    bridgeGroup.add(sphere);
                    
                    const nextAngle = ((i + 1) % 5) / 5 * Math.PI * 2;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3( Math.cos(angle) * radius, yPos, Math.sin(angle) * radius ),
                        new THREE.Vector3( Math.cos(nextAngle) * radius, yPos, Math.sin(nextAngle) * radius )
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: colors.thirtyFiveFold, transparent: true, opacity: 0.3 });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    bridgeGroup.add(line);
                    
                    if (ring < 6) {
                        const nextRadius = size * (ring + 2) / 7;
                        const nextYPos = ((ring + 1) - 3) * 0.5;
                        
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3( Math.cos(angle) * radius, yPos, Math.sin(angle) * radius ),
                            new THREE.Vector3( Math.cos(angle) * nextRadius, nextYPos, Math.sin(angle) * nextRadius )
                        ]);
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        bridgeGroup.add(line);
                    }
                }
            }
            
            for (let i = 0; i < 7; i++) {
                const angle = (i / 7) * Math.PI * 2;
                const radius = size * 1.1;
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0), new THREE.Vector3( Math.cos(angle) * radius, 0, Math.sin(angle) * radius )
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: colors.sevenFold, transparent: true, opacity: 0.5 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                bridgeGroup.add(line);
            }
            
            const centerGeometry = new THREE.SphereGeometry(0.4, 32, 32);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, emissive: colors.thirtyFiveFold, emissiveIntensity: 0.8, transparent: true, opacity: 0.9
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            bridgeGroup.add(centerSphere);
        }

        function createEmergentGeometry() {
            emergentGroup.clear();
            const size = 3;
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            
            const pascalLayers = 6;
            let vertices = [];
            
            for (let layer = 0; layer < pascalLayers; layer++) {
                const layerVertices = layer + 1;
                const layerRadius = size * (layer + 1) / pascalLayers;
                const yPos = (layer - pascalLayers/2) * 0.6;
                
                for (let i = 0; i < layerVertices; i++) {
                    const angle = (i / layerVertices) * Math.PI * 2;
                    const polarity = (i % 2 === 0) ? 1 : -1;
                    
                    const sphereMaterial = new THREE.MeshPhongMaterial({ 
                        color: polarity > 0 ? 0x00ffaa : 0xff0066,
                        emissive: polarity > 0 ? 0x00aa77 : 0xaa0044,
                        emissiveIntensity: 0.3
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.x = Math.cos(angle) * layerRadius;
                    sphere.position.z = Math.sin(angle) * layerRadius;
                    sphere.position.y = yPos;
                    emergentGroup.add(sphere);
                    
                    vertices.push({
                        x: sphere.position.x, y: sphere.position.y, z: sphere.position.z, polarity: polarity
                    });
                    
                    if (layer > 0) {
                        const prevLayer = layer - 1;
                        const prevLayerVertices = prevLayer + 1;
                        
                        let connections = [];
                        if (i === 0) { connections = [0]; } 
                        else if (i === layerVertices - 1) { connections = [prevLayerVertices - 1]; } 
                        else {
                            const ratio = i / layerVertices;
                            const prevIndex1 = Math.floor(ratio * prevLayerVertices);
                            const prevIndex2 = Math.min(prevIndex1 + 1, prevLayerVertices - 1);
                            connections = [prevIndex1, prevIndex2];
                        }
                        
                        for (const prevIndex of connections) {
                            const prevVertexIndex = (prevLayer * (prevLayer + 1)) / 2 + prevIndex;
                            const prevVertex = vertices[prevVertexIndex];
                            
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3( prevVertex.x, prevVertex.y, prevVertex.z ),
                                new THREE.Vector3( sphere.position.x, sphere.position.y, sphere.position.z )
                            ]);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xffffff, transparent: true, opacity: 0.2 
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            emergentGroup.add(line);
                        }
                    }
                }
            }
            
            const faceGeometry = new THREE.IcosahedronGeometry(size * 0.7);
            const faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff, transparent: true, opacity: 0.1, wireframe: false, side: THREE.DoubleSide
            });
            const faces = new THREE.Mesh(faceGeometry, faceMaterial);
            emergentGroup.add(faces);
            
            const centerGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 1.0, transparent: true, opacity: 0.9
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            emergentGroup.add(centerSphere);
        }
        
        // --- NEW MODE CREATION FUNCTIONS ---
        function create2DPlane() {
            twoDGroup.clear();
            const size = 8;
            const divisions = 20;
            const gridHelper = new THREE.GridHelper(size, divisions, colors.twoD, colors.twoD);
            twoDGroup.add(gridHelper);
            
            const planeGeometry = new THREE.PlaneGeometry(size, size);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: colors.twoD,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            twoDGroup.add(plane);
        }
        
        function createSphereMode() {
            sphereGroup.clear();
            const radius = 4;
            const segments = 64;
            const sphereGeometry = new THREE.SphereGeometry(radius, segments, segments);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: colors.sphere,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            const mainSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereGroup.add(mainSphere);
            
            // Add a few reference points on the surface
            const pointGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const pointMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: colors.sphere,
                emissiveIntensity: 0.8
            });
            
            const points = [
                new THREE.Vector3(0, radius, 0),
                new THREE.Vector3(0, -radius, 0),
                new THREE.Vector3(radius, 0, 0),
                new THREE.Vector3(-radius, 0, 0),
                new THREE.Vector3(0, 0, radius),
                new THREE.Vector3(0, 0, -radius)
            ];
            
            points.forEach(pos => {
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.position.copy(pos);
                sphereGroup.add(point);
            });
        }
        
        function createTetrahedralMode() {
            tetrahedronGroup.clear();
            const size = 3;
            const geometry = new THREE.TetrahedronGeometry(size);
            const material = new THREE.MeshPhongMaterial({
                color: colors.tetrahedron,
                transparent: true,
                opacity: 0.8,
                wireframe: false,
                side: THREE.DoubleSide
            });
            const tetrahedron = new THREE.Mesh(geometry, material);
            tetrahedron.rotation.x = 0.5;
            tetrahedron.rotation.y = 0.5;
            tetrahedronGroup.add(tetrahedron);
            
            // Add spheres at the vertices
            const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: colors.tetrahedron,
                emissiveIntensity: 0.8
            });
            
            const vertices = tetrahedron.geometry.attributes.position.array;
            for(let i = 0; i < vertices.length; i += 3) {
                const pos = new THREE.Vector3(vertices[i], vertices[i+1], vertices[i+2]);
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(pos);
                tetrahedronGroup.add(sphere);
            }
        }
        
        // Initialize all structures
        createMerkaba();
        createAxiomaticLayers();
        createHarmonicField();
        createBridgeGeometry();
        createEmergentGeometry();
        create2DPlane();
        createSphereMode();
        createTetrahedralMode();

        // Animation and interaction variables
        let animationRunning = true;
        let rotationSpeed = 0.02;
        let scaleFactor = 1;
        let harmonicFrequency = 3;
        let projectionStrength = 1;
        let time = 0;
        let vertexCounter = 0;
        let isDragging = false;
        let selectedVertex = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        const dragPlane = new THREE.Plane();
        const dragOffset = new THREE.Vector3();

        function addVertex() {
            vertexCounter++;
            const x = (Math.random() - 0.5) * 6;
            const y = (Math.random() - 0.5) * 6;
            const z = (Math.random() - 0.5) * 6;
            createInteractiveVertex(new THREE.Vector3(x, y, z));
        }

        function addNineNodeGrid() {
            vertexProjectionGroup.clear();
            vertexCounter = 0;
            
            const gridCount = 3;
            const spacing = 2;
            const startX = -spacing;
            const startY = -spacing;
            
            for (let i = 0; i < gridCount; i++) {
                for (let j = 0; j < gridCount; j++) {
                    const x = startX + i * spacing;
                    const y = startY + j * spacing;
                    const z = 0;
                    createInteractiveVertex(new THREE.Vector3(x, y, z));
                }
            }
        }
        
        function createInteractiveVertex(position) {
            vertexCounter++;
            const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: colors.projection,
                emissive: colors.projection,
                emissiveIntensity: 0.7
            });
            const vertex = new THREE.Mesh(sphereGeometry, sphereMaterial);
            vertex.position.copy(position);
            vertex.userData.originalPosition = position.clone();
            vertex.userData.id = vertexCounter;
            vertex.userData.isDraggable = true;
            vertexProjectionGroup.add(vertex);
            
            createLieLines(vertex);
        }

        function createLieLines(vertex) {
            if (vertex.userData.lieLines) {
                vertex.userData.lieLines.forEach(line => {
                    vertexProjectionGroup.remove(line);
                });
            }
            const lines = [];
            
            const structureType = document.getElementById('viewMode').value;
            let referencePoints = [];
            
            switch(structureType) {
                case 'merkaba':
                    merkabaGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                            referencePoints.push(child.position.clone());
                        }
                    });
                    break;
                case 'axiomatic':
                    axiomaticGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                             referencePoints.push(child.position.clone());
                        }
                    });
                    break;
                case 'harmonic':
                    harmonicGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                            referencePoints.push(child.position.clone());
                        }
                    });
                    break;
                case 'bridge':
                    bridgeGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                            referencePoints.push(child.position.clone());
                        }
                    });
                    break;
                case 'emergent':
                    emergentGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                            referencePoints.push(child.position.clone());
                        }
                    });
                    break;
                case 'twoD':
                    // Use a few points on the plane
                    referencePoints.push(new THREE.Vector3(4, 0, 4));
                    referencePoints.push(new THREE.Vector3(-4, 0, 4));
                    referencePoints.push(new THREE.Vector3(4, 0, -4));
                    referencePoints.push(new THREE.Vector3(-4, 0, -4));
                    break;
                case 'sphere':
                    sphereGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry && child.scale.length() > 0.5) {
                            referencePoints.push(child.position.clone());
                        }
                    });
                    break;
                case 'tetrahedron':
                    tetrahedronGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                            referencePoints.push(child.position.clone());
                        }
                    });
                    break;
            }
            
            if (referencePoints.length === 0) {
                referencePoints.push(new THREE.Vector3(0, 0, 0));
            }
            
            referencePoints.forEach(refPoint => {
                const direction = refPoint.clone().sub(vertex.position).normalize();
                const extendedPoint = refPoint.clone().add(direction.multiplyScalar(projectionStrength * 5));
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    vertex.position.clone(), extendedPoint
                ]);
                
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: colors.lieLine, transparent: true, opacity: 0.6
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                vertexProjectionGroup.add(line);
                lines.push(line);
            });
            
            vertex.userData.lieLines = lines;
        }

        function updateAllLieLines() {
            const linesToRemove = [];
            vertexProjectionGroup.children.forEach(child => {
                if (child instanceof THREE.Line) {
                    linesToRemove.push(child);
                }
            });
            linesToRemove.forEach(line => vertexProjectionGroup.remove(line));

            vertexProjectionGroup.children.forEach(child => {
                if (child.userData.isDraggable) {
                    createLieLines(child);
                }
            });
        }

        function onDocumentMouseDown(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(vertexProjectionGroup.children, true);
            
            if (intersects.length > 0 && intersects[0].object.userData.isDraggable) {
                controls.enabled = false;
                isDragging = true;
                selectedVertex = intersects[0].object;
                
                const intersectionPoint = intersects[0].point;
                dragPlane.setFromNormalAndCoplanarPoint(camera.position.clone().normalize(), intersectionPoint);
                dragOffset.copy(intersectionPoint).sub(selectedVertex.position);
            }
        }
        
        function onDocumentMouseMove(event) {
            if (!isDragging) return;
            event.preventDefault();
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, intersection);
            
            selectedVertex.position.copy(intersection.sub(dragOffset));
            updateLieLinesForSingleVertex(selectedVertex);
        }
        
        function onDocumentMouseUp() {
            isDragging = false;
            selectedVertex = null;
            controls.enabled = true;
        }

        function updateLieLinesForSingleVertex(vertex) {
            if (vertex.userData.lieLines) {
                vertex.userData.lieLines.forEach(line => {
                    vertexProjectionGroup.remove(line);
                });
            }
            createLieLines(vertex);
        }
        
        renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
        renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
        renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);
        
        function onDocumentTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.touches[0].clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(vertexProjectionGroup.children, true);
                
                if (intersects.length > 0 && intersects[0].object.userData.isDraggable) {
                    controls.enabled = false;
                    isDragging = true;
                    selectedVertex = intersects[0].object;
                    
                    const intersectionPoint = intersects[0].point;
                    dragPlane.setFromNormalAndCoplanarPoint(camera.position.clone().normalize(), intersectionPoint);
                    dragOffset.copy(intersectionPoint).sub(selectedVertex.position);
                }
            }
        }

        function onDocumentTouchMove(event) {
            if (!isDragging || event.touches.length !== 1) return;
            event.preventDefault();

            mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.touches[0].clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, intersection);
            
            selectedVertex.position.copy(intersection.sub(dragOffset));
            updateLieLinesForSingleVertex(selectedVertex);
        }
        
        function onDocumentTouchEnd() {
            isDragging = false;
            selectedVertex = null;
            controls.enabled = true;
        }

        renderer.domElement.addEventListener('touchstart', onDocumentTouchStart, false);
        renderer.domElement.addEventListener('touchmove', onDocumentTouchMove, false);
        renderer.domElement.addEventListener('touchend', onDocumentTouchEnd, false);

        // --- UI Control Event Listeners ---
        document.getElementById('viewMode').addEventListener('change', function() {
            const mode = this.value;
            
            merkabaGroup.visible = (mode === 'merkaba');
            axiomaticGroup.visible = (mode === 'axiomatic');
            harmonicGroup.visible = (mode === 'harmonic');
            bridgeGroup.visible = (mode === 'bridge');
            emergentGroup.visible = (mode === 'emergent');
            twoDGroup.visible = (mode === 'twoD');
            sphereGroup.visible = (mode === 'sphere');
            tetrahedronGroup.visible = (mode === 'tetrahedron');
            
            updateAllLieLines();
        });

        document.getElementById('rotationSpeed').addEventListener('input', function() {
            rotationSpeed = parseFloat(this.value);
        });

        document.getElementById('scaleFactor').addEventListener('input', function() {
            scaleFactor = parseFloat(this.value);
            [merkabaGroup, axiomaticGroup, harmonicGroup, bridgeGroup, emergentGroup, twoDGroup, sphereGroup, tetrahedronGroup, vertexProjectionGroup].forEach(group => {
                group.scale.set(scaleFactor, scaleFactor, scaleFactor);
            });
        });

        document.getElementById('harmonicFrequency').addEventListener('input', function() {
            harmonicFrequency = parseFloat(this.value);
        });

        document.getElementById('projectionStrength').addEventListener('input', function() {
            projectionStrength = parseFloat(this.value);
            updateAllLieLines();
        });

        document.getElementById('addVertex').addEventListener('click', function() {
            addVertex();
        });

        document.getElementById('addNineNodeGrid').addEventListener('click', function() {
            addNineNodeGrid();
        });

        document.getElementById('toggleAnimation').addEventListener('click', function() {
            animationRunning = !animationRunning;
            this.textContent = animationRunning ? 'Pause Animation' : 'Resume Animation';
        });

        document.getElementById('resetView').addEventListener('click', function() {
            controls.reset();
            camera.position.set(0, 5, 10);
            controls.update();
        });

        document.getElementById('clearVertices').addEventListener('click', function() {
            vertexProjectionGroup.clear();
            vertexCounter = 0;
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (animationRunning) {
                time += 0.01;
                
                // Rotate groups
                merkabaGroup.rotation.y += rotationSpeed;
                axiomaticGroup.rotation.y += rotationSpeed * 0.7;
                harmonicGroup.rotation.y += rotationSpeed * 0.5;
                harmonicGroup.rotation.x += rotationSpeed * 0.3;
                bridgeGroup.rotation.y += rotationSpeed * 0.6;
                emergentGroup.rotation.y += rotationSpeed * 0.4;
                twoDGroup.rotation.z += rotationSpeed * 0.2;
                sphereGroup.rotation.y += rotationSpeed * 0.5;
                tetrahedronGroup.rotation.y += rotationSpeed * 0.8;
                
                // Add harmonic pulsation
                const pulse = Math.sin(time * harmonicFrequency) * 0.1 + 1;
                [merkabaGroup, axiomaticGroup, harmonicGroup, bridgeGroup, emergentGroup, twoDGroup, sphereGroup, tetrahedronGroup].forEach(group => {
                    group.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                            const originalScale = 1;
                            child.scale.set(originalScale * pulse, originalScale * pulse, originalScale * pulse);
                        }
                    });
                });
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = function() {
            animate();
        };
    </script>
</body>
</html>
