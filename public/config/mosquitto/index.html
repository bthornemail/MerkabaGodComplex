<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js MQTT Controller</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        
        .container {
            display: grid;
            grid-template-columns: repeat(2, 160px);
            grid-template-rows: repeat(3, 160px);
            gap: 10px;
            width: 340px;
            margin: 0 auto;
        }
        
        .controller-view {
            grid-column: 1 / span 2;
            width: 160px;
            height: 160px;
            border: 2px solid #444;
            margin-bottom: 10px;
            justify-self: center;
            position: relative;
        }
        
        .fixed-view {
            border: 2px solid #444;
            background: #333;
        }
        
        .controls {
            margin: 20px auto;
            width: 340px;
            text-align: center;
        }
        
        .status {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        
        button {
            margin: 5px;
            padding: 8px 16px;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #666;
        }
        
        button:disabled {
            background: #333;
            cursor: not-allowed;
        }
        
        input {
            margin: 5px;
            padding: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h2>Three.js MQTT Controller</h2>
        <div>
            <input type="text" id="mqttBroker" placeholder="MQTT Broker URL" value="ws://localhost:8083/mqtt">
            <button id="connectBtn">Connect</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
        </div>
        <div>
            <input type="text" id="topicPrefix" placeholder="Topic Prefix" value="threejs/cube">
        </div>
        <div class="status" id="status">Disconnected</div>
    </div>

    <div class="container">
        <!-- Controller view spanning top row -->
        <div id="controllerView" class="controller-view"></div>

        <!-- 4 fixed views -->
        <canvas id="frontView" class="fixed-view" width="160" height="160"></canvas>
        <canvas id="backView" class="fixed-view" width="160" height="160"></canvas>
        <canvas id="leftView" class="fixed-view" width="160" height="160"></canvas>
        <canvas id="rightView" class="fixed-view" width="160" height="160"></canvas>
    </div>

    <div class="controls">
        <button id="publishViews">Publish All Views</button>
        <button id="autoPublish">Auto Publish: OFF</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <script>
        class ThreeJSMQTTController {
            constructor() {
                this.canvasSize = 160;
                this.mqttClient = null;
                this.topicPrefix = 'threejs/cube';
                this.isConnected = false;
                this.autoPublishEnabled = false;
                this.autoPublishInterval = null;
                
                this.fixedCameraPositions = {
                    front: new THREE.Vector3(0, 0, 5),
                    back: new THREE.Vector3(0, 0, -5),
                    left: new THREE.Vector3(-5, 0, 0),
                    right: new THREE.Vector3(5, 0, 0)
                };
                
                this.currentRotation = { x: 0, y: 0 };
                
                this.setupThreeJS();
                this.setupUI();
            }
            
            setupThreeJS() {
                // Controller scene setup
                this.controllerScene = new THREE.Scene();
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshNormalMaterial();
                this.controllerCube = new THREE.Mesh(geometry, material);
                this.controllerScene.add(this.controllerCube);
                
                this.controllerCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                this.controllerCamera.position.set(3, 3, 3);
                this.controllerCamera.lookAt(0, 0, 0);
                
                this.controllerRenderer = new THREE.WebGLRenderer({ antialias: true });
                this.controllerRenderer.setSize(this.canvasSize, this.canvasSize);
                document.getElementById('controllerView').appendChild(this.controllerRenderer.domElement);
                
                // Fixed view scenes and renderers
                this.fixedScenes = {};
                this.fixedCubes = {};
                this.fixedCameras = {};
                this.fixedRenderers = {};
                
                Object.keys(this.fixedCameraPositions).forEach(viewName => {
                    // Scene and cube for this view
                    const scene = new THREE.Scene();
                    const cube = new THREE.Mesh(geometry.clone(), material.clone());
                    scene.add(cube);
                    
                    // Camera for this view
                    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                    camera.position.copy(this.fixedCameraPositions[viewName]);
                    camera.lookAt(0, 0, 0);
                    camera.updateMatrixWorld();
                    
                    // Renderer for this view
                    const canvas = document.getElementById(`${viewName}View`);
                    const renderer = new THREE.WebGLRenderer({ 
                        canvas: canvas, 
                        antialias: true,
                        preserveDrawingBuffer: true 
                    });
                    renderer.setSize(this.canvasSize, this.canvasSize);
                    
                    this.fixedScenes[viewName] = scene;
                    this.fixedCubes[viewName] = cube;
                    this.fixedCameras[viewName] = camera;
                    this.fixedRenderers[viewName] = renderer;
                });
                
                this.animate();
            }
            
            setupUI() {
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                const publishBtn = document.getElementById('publishViews');
                const autoPublishBtn = document.getElementById('autoPublish');
                
                connectBtn.addEventListener('click', () => this.connectMQTT());
                disconnectBtn.addEventListener('click', () => this.disconnectMQTT());
                publishBtn.addEventListener('click', () => this.publishAllViews());
                autoPublishBtn.addEventListener('click', () => this.toggleAutoPublish());
                
                // Mouse controls for controller view
                let isMouseDown = false;
                let lastMouseX = 0;
                let lastMouseY = 0;
                
                const controllerCanvas = this.controllerRenderer.domElement;
                
                // Make sure canvas can receive focus and prevent context menu
                controllerCanvas.style.cursor = 'grab';
                controllerCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                controllerCanvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isMouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    controllerCanvas.style.cursor = 'grabbing';
                    console.log('Mouse down at:', lastMouseX, lastMouseY);
                });
                
                controllerCanvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown) return;
                    
                    e.preventDefault();
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    console.log('Mouse delta:', deltaX, deltaY);
                    
                    this.currentRotation.y += deltaX * 0.01;
                    this.currentRotation.x += deltaY * 0.01;
                    
                    this.updateRotation();
                    if (this.isConnected) {
                        this.publishRotation();
                    }
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (isMouseDown) {
                        isMouseDown = false;
                        controllerCanvas.style.cursor = 'grab';
                        console.log('Mouse up');
                    }
                });
                
                // Touch controls for mobile
                controllerCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        isMouseDown = true;
                        lastMouseX = e.touches[0].clientX;
                        lastMouseY = e.touches[0].clientY;
                    }
                });
                
                controllerCanvas.addEventListener('touchmove', (e) => {
                    if (!isMouseDown || e.touches.length !== 1) return;
                    
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - lastMouseX;
                    const deltaY = e.touches[0].clientY - lastMouseY;
                    
                    this.currentRotation.y += deltaX * 0.01;
                    this.currentRotation.x += deltaY * 0.01;
                    
                    this.updateRotation();
                    if (this.isConnected) {
                        this.publishRotation();
                    }
                    
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                });
                
                controllerCanvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    isMouseDown = false;
                });
            }
            
            connectMQTT() {
                const brokerUrl = document.getElementById('mqttBroker').value;
                this.topicPrefix = document.getElementById('topicPrefix').value;
                
                try {
                    const url = new URL(brokerUrl);
                    const clientId = 'threejs_controller_' + Math.random().toString(36).substr(2, 9);
                    
                    this.mqttClient = new Paho.MQTT.Client(url.hostname, parseInt(url.port), clientId);
                    
                    this.mqttClient.onConnectionLost = (responseObject) => {
                        if (responseObject.errorCode !== 0) {
                            console.log("Connection lost: " + responseObject.errorMessage);
                            this.updateStatus('Connection lost: ' + responseObject.errorMessage);
                            this.isConnected = false;
                            this.updateUI();
                        }
                    };
                    
                    this.mqttClient.onMessageArrived = (message) => {
                        this.handleMQTTMessage(message.destinationName, message.payloadString);
                    };
                    
                    const connectOptions = {
                        onSuccess: () => {
                            console.log("Connected to MQTT broker");
                            this.updateStatus('Connected to ' + brokerUrl);
                            this.isConnected = true;
                            this.updateUI();
                            
                            // Subscribe to control topics
                            this.mqttClient.subscribe(`${this.topicPrefix}/control/rotation`);
                            this.mqttClient.subscribe(`${this.topicPrefix}/control/request_views`);
                            this.mqttClient.subscribe(`${this.topicPrefix}/control/request_view`);
                        },
                        onFailure: (error) => {
                            console.log("Connection failed: " + error.errorMessage);
                            this.updateStatus('Connection failed: ' + error.errorMessage);
                        }
                    };
                    
                    this.mqttClient.connect(connectOptions);
                    
                } catch (error) {
                    console.error('Invalid broker URL:', error);
                    this.updateStatus('Invalid broker URL');
                }
            }
            
            disconnectMQTT() {
                if (this.mqttClient && this.isConnected) {
                    this.mqttClient.disconnect();
                    this.isConnected = false;
                    this.updateStatus('Disconnected');
                    this.updateUI();
                }
            }
            
            handleMQTTMessage(topic, message) {
                try {
                    if (topic === `${this.topicPrefix}/control/rotation`) {
                        const rotation = JSON.parse(message);
                        this.currentRotation.x = rotation.x || 0;
                        this.currentRotation.y = rotation.y || 0;
                        this.updateRotation();
                        
                    } else if (topic === `${this.topicPrefix}/control/request_views`) {
                        this.publishAllViews();
                        
                    } else if (topic === `${this.topicPrefix}/control/request_view`) {
                        this.publishView(message);
                    }
                } catch (error) {
                    console.error('Error handling MQTT message:', error);
                }
            }
            
            updateRotation() {
                // Apply rotation to controller cube
                this.controllerCube.rotation.x = this.currentRotation.x;
                this.controllerCube.rotation.y = this.currentRotation.y;
                
                // Apply inverse rotation to fixed view cubes
                Object.values(this.fixedCubes).forEach(cube => {
                    cube.rotation.x = -this.currentRotation.x;
                    cube.rotation.y = -this.currentRotation.y;
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Render controller view
                this.controllerRenderer.render(this.controllerScene, this.controllerCamera);
                
                // Render fixed views
                Object.keys(this.fixedRenderers).forEach(viewName => {
                    this.fixedRenderers[viewName].render(
                        this.fixedScenes[viewName], 
                        this.fixedCameras[viewName]
                    );
                });
            }
            
            publishRotation() {
                if (this.isConnected && this.mqttClient) {
                    const message = new Paho.MQTT.Message(JSON.stringify(this.currentRotation));
                    message.destinationName = `${this.topicPrefix}/state/rotation`;
                    this.mqttClient.send(message);
                }
            }
            
            publishView(viewName) {
                if (!this.isConnected || !this.fixedRenderers[viewName]) return;
                
                const canvas = this.fixedRenderers[viewName].domElement;
                const imageData = canvas.toDataURL('image/png');
                
                const message = new Paho.MQTT.Message(imageData);
                message.destinationName = `${this.topicPrefix}/images/${viewName}`;
                this.mqttClient.send(message);
                
                console.log(`Published ${viewName} view`);
            }
            
            publishAllViews() {
                if (!this.isConnected) return;
                
                Object.keys(this.fixedRenderers).forEach(viewName => {
                    this.publishView(viewName);
                });
                
                this.publishRotation();
                console.log('Published all views');
            }
            
            toggleAutoPublish() {
                this.autoPublishEnabled = !this.autoPublishEnabled;
                const btn = document.getElementById('autoPublish');
                
                if (this.autoPublishEnabled) {
                    btn.textContent = 'Auto Publish: ON';
                    this.autoPublishInterval = setInterval(() => {
                        if (this.isConnected) {
                            this.publishAllViews();
                        }
                    }, 100); // 10 FPS
                } else {
                    btn.textContent = 'Auto Publish: OFF';
                    if (this.autoPublishInterval) {
                        clearInterval(this.autoPublishInterval);
                        this.autoPublishInterval = null;
                    }
                }
            }
            
            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }
            
            updateUI() {
                document.getElementById('connectBtn').disabled = this.isConnected;
                document.getElementById('disconnectBtn').disabled = !this.isConnected;
            }
        }
        
        // Initialize the controller when page loads
        window.addEventListener('load', () => {
            const controller = new ThreeJSMQTTController();
        });
    </script>
</body>
</html>
