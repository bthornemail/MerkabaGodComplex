<!DOCTYPE html>
<html>
<head>
    <title>MerkabaGodComplex Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        select, button {
            margin: 5px 0;
            width: 100%;
        }
        .slider-container {
            margin: 10px 0;
        }
        label {
            display: block;
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>MerkabaGodComplex Visualization</h3>
        <select id="viewMode">
            <option value="merkaba">Merkaba Structure (7-Fold)</option>
            <option value="axiomatic">Axiomatic Layers (5-Fold)</option>
            <option value="harmonic">Harmonic Field (24-Fold)</option>
            <option value="bridge">Bridge Geometry (35-Fold)</option>
            <option value="emergent">Emergent Geometry</option>
        </select>
        
        <div class="slider-container">
            <label for="rotationSpeed">Rotation Speed</label>
            <input type="range" id="rotationSpeed" min="0" max="0.1" step="0.001" value="0.02">
        </div>
        
        <div class="slider-container">
            <label for="scaleFactor">Scale Factor</label>
            <input type="range" id="scaleFactor" min="0.5" max="2" step="0.1" value="1">
        </div>
        
        <div class="slider-container">
            <label for="harmonicFrequency">Harmonic Frequency</label>
            <input type="range" id="harmonicFrequency" min="0" max="10" step="0.1" value="3">
        </div>
        
        <button id="toggleAnimation">Pause Animation</button>
        <button id="resetView">Reset View</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Initialize Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(0, 5, 10);
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Create the Merkaba structure
        let merkabaGroup = new THREE.Group();
        scene.add(merkabaGroup);

        // Create the axiomatic layers
        let axiomaticGroup = new THREE.Group();
        axiomaticGroup.visible = false;
        scene.add(axiomaticGroup);

        // Create the harmonic field
        let harmonicGroup = new THREE.Group();
        harmonicGroup.visible = false;
        scene.add(harmonicGroup);

        // Create the bridge geometry
        let bridgeGroup = new THREE.Group();
        bridgeGroup.visible = false;
        scene.add(bridgeGroup);

        // Create emergent geometry
        let emergentGroup = new THREE.Group();
        emergentGroup.visible = false;
        scene.add(emergentGroup);

        // Colors for the different principles
        const colors = {
            sevenFold: 0xaa00ff,    // Purple for 7-fold
            fiveFold: 0x00aaff,      // Blue for 5-fold
            twentyFourFold: 0xffaa00, // Orange for 24-fold
            thirtyFiveFold: 0x00ffaa, // Teal for 35-fold
            inverse: 0xff0066        // Pink for inverse
        };

        // Create the Merkaba structure (7-fold principle)
        function createMerkaba() {
            merkabaGroup.clear();
            
            // Create two tetrahedrons (upward and downward pointing)
            const size = 2;
            const geometry = new THREE.TetrahedronGeometry(size);
            
            // Upward tetrahedron (positive)
            const materialUp = new THREE.MeshPhongMaterial({
                color: colors.sevenFold,
                transparent: true,
                opacity: 0.8,
                wireframe: false,
                side: THREE.DoubleSide
            });
            const tetraUp = new THREE.Mesh(geometry, materialUp);
            tetraUp.rotation.y = Math.PI / 4;
            merkabaGroup.add(tetraUp);
            
            // Downward tetrahedron (negative)
            const materialDown = new THREE.MeshPhongMaterial({
                color: colors.inverse,
                transparent: true,
                opacity: 0.8,
                wireframe: false,
                side: THREE.DoubleSide
            });
            const tetraDown = new THREE.Mesh(geometry, materialDown);
            tetraDown.rotation.y = Math.PI / 4;
            tetraDown.rotation.x = Math.PI;
            merkabaGroup.add(tetraDown);
            
            // Add 7 spheres representing the 7-fold principle
            const sphereGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: colors.sevenFold, emissiveIntensity: 0.5 });
            
            for (let i = 0; i < 7; i++) {
                const angle = (i / 7) * Math.PI * 2;
                const radius = size * 1.5;
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial.clone());
                sphere.position.x = Math.cos(angle) * radius;
                sphere.position.z = Math.sin(angle) * radius;
                merkabaGroup.add(sphere);
                
                // Add connecting lines
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(sphere.position.x, sphere.position.y, sphere.position.z)
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: colors.sevenFold, transparent: true, opacity: 0.5 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                merkabaGroup.add(line);
            }
            
            // Add central sphere representing the divine source
            const centerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, 
                emissive: colors.sevenFold, 
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.9
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            merkabaGroup.add(centerSphere);
        }

        // Create the axiomatic layers (5-fold principle)
        function createAxiomaticLayers() {
            axiomaticGroup.clear();
            
            const layers = 5;
            const radius = 3;
            const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            
            for (let l = 0; l < layers; l++) {
                const layerRadius = radius * (l + 1) / layers;
                const spheresInLayer = 5 * (l + 1);
                
                for (let i = 0; i < spheresInLayer; i++) {
                    const angle = (i / spheresInLayer) * Math.PI * 2;
                    const sphereMaterial = new THREE.MeshPhongMaterial({ 
                        color: colors.fiveFold,
                        emissive: colors.fiveFold,
                        emissiveIntensity: 0.3
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.x = Math.cos(angle) * layerRadius;
                    sphere.position.z = Math.sin(angle) * layerRadius;
                    sphere.position.y = (l - (layers / 2)) * 0.5;
                    
                    axiomaticGroup.add(sphere);
                    
                    // Connect to next sphere in layer
                    if (i < spheresInLayer - 1) {
                        const nextAngle = ((i + 1) / spheresInLayer) * Math.PI * 2;
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(
                                Math.cos(angle) * layerRadius,
                                sphere.position.y,
                                Math.sin(angle) * layerRadius
                            ),
                            new THREE.Vector3(
                                Math.cos(nextAngle) * layerRadius,
                                sphere.position.y,
                                Math.sin(nextAngle) * layerRadius
                            )
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: colors.fiveFold, 
                            transparent: true, 
                            opacity: 0.3 
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        axiomaticGroup.add(line);
                    }
                    
                    // Connect to corresponding sphere in next layer
                    if (l < layers - 1) {
                        const nextLayerSpheres = 5 * (l + 2);
                        const correspondingIndex = Math.floor(i * nextLayerSpheres / spheresInLayer);
                        const nextAngle = (correspondingIndex / nextLayerSpheres) * Math.PI * 2;
                        const nextLayerRadius = radius * (l + 2) / layers;
                        
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(
                                Math.cos(angle) * layerRadius,
                                sphere.position.y,
                                Math.sin(angle) * layerRadius
                            ),
                            new THREE.Vector3(
                                Math.cos(nextAngle) * nextLayerRadius,
                                sphere.position.y + 0.5,
                                Math.sin(nextAngle) * nextLayerRadius
                            )
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: colors.fiveFold, 
                            transparent: true, 
                            opacity: 0.2 
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        axiomaticGroup.add(line);
                    }
                }
            }
            
            // Add central dodecahedron representing the 25 axioms
            const dodecahedronGeometry = new THREE.DodecahedronGeometry(1);
            const dodecahedronMaterial = new THREE.MeshPhongMaterial({
                color: colors.fiveFold,
                transparent: true,
                opacity: 0.7,
                wireframe: false
            });
            const dodecahedron = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial);
            axiomaticGroup.add(dodecahedron);
        }

        // Create the harmonic field (24-fold principle)
        function createHarmonicField() {
            harmonicGroup.clear();
            
            const size = 4;
            const segments = 24;
            const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            
            // Create biphasic dodecahedral structure
            const dodecahedronGeometry = new THREE.DodecahedronGeometry(size * 0.8);
            const dodecahedronMaterial = new THREE.MeshPhongMaterial({
                color: colors.twentyFourFold,
                transparent: true,
                opacity: 0.2,
                wireframe: true,
                side: THREE.DoubleSide
            });
            const dodecahedron1 = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial);
            harmonicGroup.add(dodecahedron1);
            
            const dodecahedron2 = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial.clone());
            dodecahedron2.rotation.y = Math.PI / 5;
            harmonicGroup.add(dodecahedron2);
            
            // Create 24 harmonic points
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const radius = size * 1.2;
                
                // Create harmonic spheres
                const sphereMaterial = new THREE.MeshPhongMaterial({ 
                    color: colors.twentyFourFold,
                    emissive: colors.twentyFourFold,
                    emissiveIntensity: 0.5
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.x = Math.cos(angle) * radius;
                sphere.position.z = Math.sin(angle) * radius;
                harmonicGroup.add(sphere);
                
                // Create connecting lines to form a torus
                const nextAngle = ((i + 1) % segments) / segments * Math.PI * 2;
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    ),
                    new THREE.Vector3(
                        Math.cos(nextAngle) * radius,
                        0,
                        Math.sin(nextAngle) * radius
                    )
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: colors.twentyFourFold, 
                    transparent: true, 
                    opacity: 0.5 
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                harmonicGroup.add(line);
                
                // Create vertical connections
                const verticalLineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(
                        Math.cos(angle) * radius,
                        -size * 0.5,
                        Math.sin(angle) * radius
                    ),
                    new THREE.Vector3(
                        Math.cos(angle) * radius,
                        size * 0.5,
                        Math.sin(angle) * radius
                    )
                ]);
                const verticalLine = new THREE.Line(verticalLineGeometry, lineMaterial);
                harmonicGroup.add(verticalLine);
            }
            
            // Add central icosahedron for higher harmonic resolution
            const icosahedronGeometry = new THREE.IcosahedronGeometry(size * 0.4);
            const icosahedronMaterial = new THREE.MeshPhongMaterial({
                color: colors.twentyFourFold,
                transparent: true,
                opacity: 0.6,
                wireframe: false
            });
            const icosahedron = new THREE.Mesh(icosahedronGeometry, icosahedronMaterial);
            harmonicGroup.add(icosahedron);
        }

        // Create the bridge geometry (35-fold principle)
        function createBridgeGeometry() {
            bridgeGroup.clear();
            
            const size = 3;
            const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            
            // Create 7 rings of 5 spheres each (35 total)
            for (let ring = 0; ring < 7; ring++) {
                const radius = size * (ring + 1) / 7;
                const yPos = (ring - 3) * 0.5;
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    
                    // Create sphere
                    const sphereMaterial = new THREE.MeshPhongMaterial({ 
                        color: colors.thirtyFiveFold,
                        emissive: colors.thirtyFiveFold,
                        emissiveIntensity: 0.4
                    });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.x = Math.cos(angle) * radius;
                    sphere.position.z = Math.sin(angle) * radius;
                    sphere.position.y = yPos;
                    bridgeGroup.add(sphere);
                    
                    // Connect to next sphere in ring
                    const nextAngle = ((i + 1) % 5) / 5 * Math.PI * 2;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(
                            Math.cos(angle) * radius,
                            yPos,
                            Math.sin(angle) * radius
                        ),
                        new THREE.Vector3(
                            Math.cos(nextAngle) * radius,
                            yPos,
                            Math.sin(nextAngle) * radius
                        )
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: colors.thirtyFiveFold, 
                        transparent: true, 
                        opacity: 0.3 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    bridgeGroup.add(line);
                    
                    // Connect to corresponding sphere in next ring
                    if (ring < 6) {
                        const nextRadius = size * (ring + 2) / 7;
                        const nextYPos = ((ring + 1) - 3) * 0.5;
                        
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(
                                Math.cos(angle) * radius,
                                yPos,
                                Math.sin(angle) * radius
                            ),
                            new THREE.Vector3(
                                Math.cos(angle) * nextRadius,
                                nextYPos,
                                Math.sin(angle) * nextRadius
                            )
                        ]);
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        bridgeGroup.add(line);
                    }
                }
            }
            
            // Add central connection lines between 7-fold and 5-fold
            for (let i = 0; i < 7; i++) {
                const angle = (i / 7) * Math.PI * 2;
                const radius = size * 1.1;
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    )
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: colors.sevenFold, 
                    transparent: true, 
                    opacity: 0.5 
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                bridgeGroup.add(line);
            }
            
            // Add central sphere representing the bridge
            const centerGeometry = new THREE.SphereGeometry(0.4, 32, 32);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, 
                emissive: colors.thirtyFiveFold, 
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.9
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            bridgeGroup.add(centerSphere);
        }

        // Create emergent geometry (vertices, edges, faces)
        function createEmergentGeometry() {
            emergentGroup.clear();
            
            const size = 3;
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            
            // Create vertices based on Pascal's Triangle layers
            const pascalLayers = 6;
            let vertexCount = 0;
            let vertices = [];
            
            for (let layer = 0; layer < pascalLayers; layer++) {
                const layerVertices = layer + 1;
                const layerRadius = size * (layer + 1) / pascalLayers;
                const yPos = (layer - pascalLayers/2) * 0.6;
                
                for (let i = 0; i < layerVertices; i++) {
                    const angle = (i / layerVertices) * Math.PI * 2;
                    const polarity = (i % 2 === 0) ? 1 : -1; // Alternating polarity
                    
                    const sphereMaterial = new THREE.MeshPhongMaterial({ 
                        color: polarity > 0 ? 0x00ffaa : 0xff0066,
                        emissive: polarity > 0 ? 0x00aa77 : 0xaa0044,
                        emissiveIntensity: 0.3
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.x = Math.cos(angle) * layerRadius;
                    sphere.position.z = Math.sin(angle) * layerRadius;
                    sphere.position.y = yPos;
                    emergentGroup.add(sphere);
                    
                    vertices.push({
                        x: sphere.position.x,
                        y: sphere.position.y,
                        z: sphere.position.z,
                        polarity: polarity
                    });
                    vertexCount++;
                    
                    // Connect to previous layer vertices (Fibonacci connections)
                    if (layer > 0) {
                        const prevLayer = layer - 1;
                        const prevLayerVertices = prevLayer + 1;
                        
                        // Fibonacci-like connections
                        let connections = [];
                        if (i === 0) {
                            connections = [0];
                        } else if (i === layerVertices - 1) {
                            connections = [prevLayerVertices - 1];
                        } else {
                            const ratio = i / layerVertices;
                            const prevIndex1 = Math.floor(ratio * prevLayerVertices);
                            const prevIndex2 = Math.min(prevIndex1 + 1, prevLayerVertices - 1);
                            connections = [prevIndex1, prevIndex2];
                        }
                        
                        for (const prevIndex of connections) {
                            const prevVertexIndex = (prevLayer * (prevLayer + 1)) / 2 + prevIndex;
                            const prevVertex = vertices[prevVertexIndex];
                            
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(
                                    prevVertex.x,
                                    prevVertex.y,
                                    prevVertex.z
                                ),
                                new THREE.Vector3(
                                    sphere.position.x,
                                    sphere.position.y,
                                    sphere.position.z
                                )
                            ]);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xffffff, 
                                transparent: true, 
                                opacity: 0.2 
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            emergentGroup.add(line);
                        }
                    }
                }
            }
            
            // Create faces based on containment principle (Pi = 0)
            const faceGeometry = new THREE.IcosahedronGeometry(size * 0.7);
            const faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1,
                wireframe: false,
                side: THREE.DoubleSide
            });
            const faces = new THREE.Mesh(faceGeometry, faceMaterial);
            emergentGroup.add(faces);
            
            // Add central point representing zero-point resolution
            const centerGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, 
                emissive: 0xffffff, 
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.9
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            emergentGroup.add(centerSphere);
        }

        // Initialize all structures
        createMerkaba();
        createAxiomaticLayers();
        createHarmonicField();
        createBridgeGeometry();
        createEmergentGeometry();

        // Animation variables
        let animationRunning = true;
        let rotationSpeed = 0.02;
        let scaleFactor = 1;
        let harmonicFrequency = 3;
        let time = 0;

        // UI controls
        document.getElementById('viewMode').addEventListener('change', function() {
            const mode = this.value;
            
            merkabaGroup.visible = (mode === 'merkaba');
            axiomaticGroup.visible = (mode === 'axiomatic');
            harmonicGroup.visible = (mode === 'harmonic');
            bridgeGroup.visible = (mode === 'bridge');
            emergentGroup.visible = (mode === 'emergent');
        });

        document.getElementById('rotationSpeed').addEventListener('input', function() {
            rotationSpeed = parseFloat(this.value);
        });

        document.getElementById('scaleFactor').addEventListener('input', function() {
            scaleFactor = parseFloat(this.value);
            merkabaGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
            axiomaticGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
            harmonicGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
            bridgeGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
            emergentGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
        });

        document.getElementById('harmonicFrequency').addEventListener('input', function() {
            harmonicFrequency = parseFloat(this.value);
        });

        document.getElementById('toggleAnimation').addEventListener('click', function() {
            animationRunning = !animationRunning;
            this.textContent = animationRunning ? 'Pause Animation' : 'Resume Animation';
        });

        document.getElementById('resetView').addEventListener('click', function() {
            controls.reset();
            camera.position.set(0, 5, 10);
            controls.update();
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (animationRunning) {
                time += 0.01;
                
                // Rotate groups
                merkabaGroup.rotation.y += rotationSpeed;
                axiomaticGroup.rotation.y += rotationSpeed * 0.7;
                harmonicGroup.rotation.y += rotationSpeed * 0.5;
                harmonicGroup.rotation.x += rotationSpeed * 0.3;
                bridgeGroup.rotation.y += rotationSpeed * 0.6;
                emergentGroup.rotation.y += rotationSpeed * 0.4;
                
                // Add harmonic pulsation
                const pulse = Math.sin(time * harmonicFrequency) * 0.1 + 1;
                merkabaGroup.children.forEach(child => {
                    if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                        child.scale.set(pulse, pulse, pulse);
                    }
                });
                
                axiomaticGroup.children.forEach(child => {
                    if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                        child.scale.set(pulse * 0.8, pulse * 0.8, pulse * 0.8);
                    }
                });
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>