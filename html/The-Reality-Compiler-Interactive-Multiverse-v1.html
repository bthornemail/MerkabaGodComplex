<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Reality Compiler - Interactive Multiverse</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #050510; }
        .glass-panel {
            background: rgba(20, 20, 35, 0.7);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        canvas:hover { cursor: pointer; }
        .sidebar { transition: transform 0.3s ease-in-out; }
        .sidebar.hidden-right { transform: translateX(110%); }
    </style>
    <!-- Importmap for Three.js modules -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
</head>
<body class="text-white overflow-hidden">
    <canvas id="main-canvas" class="absolute top-0 left-0 w-full h-full z-0"></canvas>

    <!-- Left Sidebar for Pipeline Creation -->
    <div class="sidebar absolute top-5 left-5 z-10 p-4 rounded-xl glass-panel shadow-lg flex flex-col gap-4 w-64">
        <h3 class="text-lg font-bold text-indigo-300">System Creator</h3>
        
        <div id="pipeline-functions">
            <label class="font-bold text-gray-300">1. Select Functions:</label>
            <!-- Checkboxes will be dynamically inserted here -->
        </div>

        <div>
            <label for="pipeline-input" class="font-bold text-gray-300">2. Initial Data (JSON):</label>
            <textarea id="pipeline-input" class="w-full h-24 bg-gray-900/50 rounded-lg p-2 text-xs font-mono mt-2 focus:outline-none focus:ring-2 focus:ring-indigo-400">{"value":10}</textarea>
        </div>
        
        <button id="add-system-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg transition-all duration-300 shadow-md">
            Add Custom System
        </button>
    </div>

    <!-- Right Sidebar for Inspection -->
    <div id="inspector-sidebar" class="sidebar hidden-right absolute top-5 right-5 z-10 p-4 rounded-xl glass-panel shadow-lg flex flex-col gap-4 w-72">
        <h3 class="text-lg font-bold text-yellow-300">System Inspector</h3>
        <div id="selected-info" class="flex flex-col gap-2 text-sm">
            <div class="flex justify-between border-b border-yellow-900/50 pb-1">
                <span class="font-bold">ID:</span>
                <span id="selected-id" class="font-mono text-gray-300"></span>
            </div>
            <div class="flex flex-col gap-1 border-b border-yellow-900/50 pb-1">
                <span class="font-bold">Pipeline:</span>
                <span id="selected-pipeline" class="font-mono text-gray-300 text-xs break-all"></span>
            </div>
            <div class="flex flex-col gap-1">
                <span class="font-bold">Latest Result:</span>
                <pre id="selected-result" class="font-mono text-gray-300 text-xs bg-gray-900/50 p-2 rounded-md max-h-48 overflow-auto"></pre>
            </div>
        </div>
    </div>


    <!-- Bottom Control Panel -->
    <div class="controls-panel absolute bottom-5 left-1/2 -translate-x-1/2 z-10 p-4 rounded-xl glass-panel shadow-lg flex items-center flex-wrap justify-center gap-4">
        <button id="run-sequence-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg transition-all duration-300 shadow-md">
            Run Selection Sequence
        </button>
        <div id="info-display" class="bg-gray-900/50 p-2 rounded-lg text-sm flex flex-col text-center">
             <div>
                <span class="font-mono text-indigo-300">Systems Active: </span>
                <span id="system-count" class="font-mono text-gray-300">0</span>
             </div>
             <div id="sequence-display" class="mt-1 pt-1 border-t border-indigo-900/50">
                <span class="font-mono text-indigo-300">Sequence: </span>
                <span id="sequence-queue" class="font-mono text-gray-300">None</span>
             </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Core Logic (Minimized for brevity) ---
        function harmonize(input) { const s=JSON.stringify(input); let h=0; for(let i=0;i<s.length;i++){h=((h<<5)-h)+s.charCodeAt(i);h|=0} return {id:`hv-${h.toString(16)}`,h}; }
        class CQEExecutionMapper { constructor(){this.cqe=new (class{bind(a,b){return{bound:a.map((v,i)=>v+(b[i]||0))}} unbind(b,a){return b.map((v,i)=>v-(a[i]||0))}})()} compare(t1,t2){const ml=Math.max(t1.length,t2.length),p1=[...t1,...new Array(ml-t1.length).fill(0)],p2=[...t2,...new Array(ml-t2.length).fill(0)];const{bound}=this.cqe.bind(p1,p2);const ub=this.cqe.unbind(bound,p1);let s=0;for(let i=0;i<ml;i++){s+=Math.pow((ub[i]||0)-(p2[i]||0),2)} return{rmse:Math.sqrt(s/ml),similarity:1/(1+Math.sqrt(s/ml))};} }
        class RecursiveEncoder { constructor(){this.stack=[]} async execute(p,d){let data=d;this.stack=[];for(const s of p){this.stack.push({lambda:s,args:[data]});data=await s.implementation(data);this.stack[this.stack.length-1].result=data}return data} getExecutionTrace(){return this.stack.map(s=>harmonize(s).h)} }
        
        // Pure Function Library for Mathematical Computations
        const PURE_FUNCTIONS = {
            // Basic arithmetic pure functions
            add: (a, b) => a + b,
            subtract: (a, b) => a - b,
            multiply: (a, b) => a * b,
            divide: (a, b) => b !== 0 ? a / b : NaN,
            modulo: (a, b) => a % b,
            power: (a, b) => Math.pow(a, b),
            
            // Advanced mathematical functions
            sqrt: (x) => Math.sqrt(x),
            abs: (x) => Math.abs(x),
            floor: (x) => Math.floor(x),
            ceil: (x) => Math.ceil(x),
            round: (x) => Math.round(x),
            sin: (x) => Math.sin(x),
            cos: (x) => Math.cos(x),
            tan: (x) => Math.tan(x),
            log: (x) => Math.log(x),
            exp: (x) => Math.exp(x),
            
            // Array operations (pure)
            sum: (arr) => arr.reduce((acc, val) => acc + val, 0),
            product: (arr) => arr.reduce((acc, val) => acc * val, 1),
            max: (arr) => Math.max(...arr),
            min: (arr) => Math.min(...arr),
            mean: (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b) / arr.length : 0,
            
            // Functional combinators
            compose: (f, g) => (x) => f(g(x)),
            curry: (f) => (a) => (b) => f(a, b),
            partial: (f, ...args) => (...restArgs) => f(...args, ...restArgs),
            
            // Data transformation functions
            map: (fn, arr) => arr.map(fn),
            filter: (predicate, arr) => arr.filter(predicate),
            reduce: (fn, initial, arr) => arr.reduce(fn, initial),
            
            // Logic functions
            and: (a, b) => a && b,
            or: (a, b) => a || b,
            not: (a) => !a,
            equals: (a, b) => a === b,
            greaterThan: (a, b) => a > b,
            lessThan: (a, b) => a < b,
        };

        // Pure Function Computation Engine
        class PureFunctionEngine {
            constructor() {
                this.functions = { ...PURE_FUNCTIONS };
                this.computationHistory = [];
            }
            
            // Register a new pure function
            registerFunction(name, fn) {
                if (typeof fn === 'function') {
                    this.functions[name] = fn;
                    return true;
                }
                return false;
            }
            
            // Compute with pure functions
            compute(functionName, ...args) {
                if (this.functions[functionName]) {
                    const result = this.functions[functionName](...args);
                    this.computationHistory.push({
                        function: functionName,
                        args: args,
                        result: result,
                        timestamp: Date.now()
                    });
                    return result;
                }
                throw new Error(`Function ${functionName} not found`);
            }
            
            // Compose multiple functions
            composeChain(operations, initialValue) {
                return operations.reduce((value, op) => {
                    return this.compute(op.function, value, ...op.args || []);
                }, initialValue);
            }
            
            // Get computation history
            getHistory() {
                return [...this.computationHistory];
            }
            
            // Clear history
            clearHistory() {
                this.computationHistory = [];
            }
        }

        const ALL_FUNCTIONS = {
            initWithValue: { description: 'Init w/ Value', implementation: data => ({ ...data, value: data.value || 1 }) },
            initWithEnergy: { description: 'Init w/ Energy', implementation: data => ({ ...data, energy: data.energy || 100 }) },
            doubleValue: { description: 'Double Value', implementation: data => ({ ...data, value: (data.value || 0) * 2 }) },
            halveValue: { description: 'Halve Value', implementation: data => ({ ...data, value: (data.value || 0) / 2 }) },
            decayEnergy: { description: 'Decay Energy', implementation: data => ({ ...data, energy: (data.energy || 0) * 0.9 }) },
            oscillate: { description: 'Oscillate', implementation: data => ({ ...data, value: Math.sin((data.phase||0) + Date.now()/1000).toFixed(2) })},
            setStateGrown: { description: 'Set State: Grown', implementation: data => ({ ...data, state: 'Grown' }) },
            setStateDecayed: { description: 'Set State: Decayed', implementation: data => ({ ...data, state: 'Decayed' }) },
            
            // Pure function integration functions
            pureMath: { description: 'Pure Math', implementation: data => {
                const engine = new PureFunctionEngine();
                const value = data.value || 0;
                const result = engine.compute('add', value, engine.compute('multiply', value, 2));
                return { ...data, value: result, computation: 'add(x, multiply(x, 2))' };
            }},
            pureCompose: { description: 'Pure Compose', implementation: data => {
                const engine = new PureFunctionEngine();
                const operations = [
                    { function: 'multiply', args: [3] },
                    { function: 'add', args: [10] },
                    { function: 'sqrt' }
                ];
                const result = engine.composeChain(operations, data.value || 1);
                return { ...data, value: result, computation: 'sqrt(add(multiply(x, 3), 10))' };
            }},
            pureFilter: { description: 'Pure Filter', implementation: data => {
                const engine = new PureFunctionEngine();
                const arr = data.array || [1, 2, 3, 4, 5];
                const filtered = engine.compute('filter', x => x > 2, arr);
                return { ...data, array: filtered, computation: 'filter(x > 2)' };
            }},
            pureReduce: { description: 'Pure Reduce', implementation: data => {
                const engine = new PureFunctionEngine();
                const arr = data.array || [1, 2, 3, 4, 5];
                const sum = engine.compute('sum', arr);
                return { ...data, value: sum, computation: 'sum(array)' };
            }},
        };

        class ComputationalSystem {
            constructor(id, initialPosition, scene, pipeline, pipelineName) {
                this.id = id; this.scene = scene;
                this.position = initialPosition.clone();
                this.velocity = new THREE.Vector3(); this.acceleration = new THREE.Vector3();
                this.encoder = new RecursiveEncoder();
                this.pipeline = pipeline; this.pipelineName = pipelineName;
                this.executionTrace = []; this.latestResult = {};
                this.createMesh();
            }
            async run(initialData) { this.latestResult = await this.encoder.execute(this.pipeline, initialData); this.executionTrace = this.encoder.getExecutionTrace(); }
            createMesh() {
                const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
                this.material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.4, metalness: 0.3, roughness: 0.5, transparent: true, opacity: 0.9 });
                const geometry = new THREE.TetrahedronGeometry(1.5, 0);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.userData.system = this;
                this.scene.add(this.mesh);
            }
            update(deltaTime) {
                this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));
                this.velocity.multiplyScalar(0.96);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.acceleration.set(0, 0, 0);
                this.mesh.position.copy(this.position);
                this.mesh.rotation.x += this.velocity.y * 0.1;
                this.mesh.rotation.y += this.velocity.x * 0.1;
            }
            dispose() { this.scene.remove(this.mesh); }
        }

        class SimulationManager {
            constructor() {
                this.systems = []; this.nextSystemId = 0; this.selectedSystem = null;
                this.selectionQueue = []; // <-- New: For ordered execution
                this.mapper = new CQEExecutionMapper();
                this.INTER_FORCE_STRENGTH = 25.0; this.SIMILARITY_THRESHOLD = 0.9;
                this.initSceneAndSystems(); this.initUI(); this.animate();
            }
            async initSceneAndSystems() { this.initScene(); }
            initScene() {
                this.scene = new THREE.Scene(); this.clock = new THREE.Clock();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/innerHeight, 0.1, 2000);
                this.camera.position.set(0, 15, 50);
                const canvas = document.getElementById('main-canvas');
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.scene.add(new THREE.AmbientLight(0xcccccc, 1.5));
                this.scene.add(new THREE.DirectionalLight(0xffffff, 2.0));
                this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
                this.lineGeometry = new THREE.BufferGeometry();
                this.lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7 });
                this.lines = new THREE.LineSegments(this.lineGeometry, this.lineMaterial);
                this.scene.add(this.lines);
            }
            initUI() {
                document.getElementById('add-system-btn').addEventListener('click', () => this.addCustomSystem());
                document.getElementById('run-sequence-btn').addEventListener('click', () => this.runSelectionSequence());
                window.addEventListener('resize', () => this.onWindowResize(), false);
                window.addEventListener('click', (event) => this.onMouseClick(event), false);
                const functionsContainer = document.getElementById('pipeline-functions');
                Object.entries(ALL_FUNCTIONS).forEach(([key, func]) => {
                    const div = document.createElement('div'); div.className = 'flex items-center gap-2';
                    const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = key; checkbox.value = key; checkbox.className = 'form-checkbox h-4 w-4 text-indigo-600 bg-gray-800 border-gray-600 rounded';
                    const label = document.createElement('label'); label.htmlFor = key; label.textContent = func.description; label.className = 'text-sm';
                    div.appendChild(checkbox); div.appendChild(label); functionsContainer.appendChild(div);
                });
            }
            async addCustomSystem() {
                const selectedFunctions = []; const pipelineNameParts = [];
                document.querySelectorAll('#pipeline-functions input[type="checkbox"]:checked').forEach(c => { selectedFunctions.push(ALL_FUNCTIONS[c.value]); pipelineNameParts.push(c.value); });
                if (selectedFunctions.length === 0) { alert("Please select at least one function."); return; }
                const pipelineName = pipelineNameParts.join(' + ');
                let initialData;
                try { initialData = JSON.parse(document.getElementById('pipeline-input').value); } catch (e) { alert("Invalid JSON input."); return; }
                const spawnRadius = 30;
                const position = new THREE.Vector3((Math.random()-0.5)*spawnRadius, (Math.random()-0.5)*spawnRadius, (Math.random()-0.5)*spawnRadius);
                const system = new ComputationalSystem(this.nextSystemId++, position, this.scene, selectedFunctions, pipelineName);
                await system.run(initialData);
                this.systems.push(system);
                document.getElementById('system-count').textContent = this.systems.length;
            }
            async runSelectionSequence() {
                if (this.selectionQueue.length === 0) {
                    alert("No systems selected. Use Shift+Click to add systems to the sequence.");
                    return;
                }
                let initialData;
                try { initialData = JSON.parse(document.getElementById('pipeline-input').value); } catch (e) { alert("Invalid JSON input."); return; }

                for (const system of this.selectionQueue) {
                    await system.run(initialData);
                }
                // After running, update the inspector to show the last run system's results
                this.updateInspector(this.selectionQueue[this.selectionQueue.length - 1]);
            }
            updatePhysics(deltaTime) {
                const linePoints = []; const lineColors = [];
                const attractiveColor = new THREE.Color(0x00ff00);
                for (let i = 0; i < this.systems.length; i++) {
                    for (let j = i + 1; j < this.systems.length; j++) {
                        const sysA = this.systems[i]; const sysB = this.systems[j];
                        const { similarity } = this.mapper.compare(sysA.executionTrace, sysB.executionTrace);
                        const forceMag = (similarity - 0.5) * this.INTER_FORCE_STRENGTH;
                        const distVec = new THREE.Vector3().subVectors(sysB.position, sysA.position);
                        const distSq = Math.max(distVec.lengthSq(), 4);
                        const forceDir = distVec.normalize();
                        const finalForce = forceDir.multiplyScalar(forceMag / distSq);
                        sysA.acceleration.add(finalForce); sysB.acceleration.sub(finalForce);
                        if (similarity > this.SIMILARITY_THRESHOLD) {
                            linePoints.push(sysA.position, sysB.position);
                            lineColors.push(attractiveColor.r, attractiveColor.g, attractiveColor.b, attractiveColor.r, attractiveColor.g, attractiveColor.b);
                        }
                    }
                }
                this.lineGeometry.setFromPoints(linePoints);
                this.lineGeometry.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));
                for (const system of this.systems) { system.update(deltaTime); }
            }
            updateInspector(system) {
                const inspector = document.getElementById('inspector-sidebar');
                if (system) {
                    this.selectedSystem = system;
                    inspector.classList.remove('hidden-right');
                    document.getElementById('selected-id').textContent = `Sys-${this.selectedSystem.id}`;
                    document.getElementById('selected-pipeline').textContent = this.selectedSystem.pipelineName;
                    document.getElementById('selected-result').textContent = JSON.stringify(this.selectedSystem.latestResult, null, 2);
                } else {
                    this.selectedSystem = null;
                    inspector.classList.add('hidden-right');
                }
            }
            updateSequenceDisplay() {
                const queueDiv = document.getElementById('sequence-queue');
                if (this.selectionQueue.length > 0) {
                    queueDiv.textContent = this.selectionQueue.map(s => `Sys-${s.id}`).join(' â†’ ');
                } else {
                    queueDiv.textContent = "None";
                }
            }
            onMouseClick(event) {
                if (event.target.closest('.sidebar') || event.target.closest('.controls-panel')) return;
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);

                if (intersects.length > 0 && intersects[0].object.userData.system) {
                    const clickedSystem = intersects[0].object.userData.system;
                    if (event.shiftKey) {
                        // Add to queue if not already there
                        if (!this.selectionQueue.includes(clickedSystem)) {
                            this.selectionQueue.push(clickedSystem);
                        }
                    } else {
                        // Regular click resets the queue to just this one
                        this.selectionQueue = [clickedSystem];
                    }
                    this.updateInspector(clickedSystem);
                } else {
                    // Clicking background deselects and clears queue
                    this.selectionQueue = [];
                    this.updateInspector(null);
                }
                this.updateSequenceDisplay();
            }
            animate() {
                requestAnimationFrame(() => this.animate());
                const deltaTime = this.clock.getDelta();
                this.updatePhysics(deltaTime);
                // Visual feedback for selection
                for (const system of this.systems) {
                    const isSelected = this.selectedSystem === system;
                    const isInQueue = this.selectionQueue.includes(system);
                    if (isSelected) {
                        system.material.emissiveIntensity = 1.0; // Brightest for last selected
                    } else if (isInQueue) {
                        system.material.emissiveIntensity = 0.7; // Dimmer for others in queue
                    } else {
                        system.material.emissiveIntensity = 0.4;
                    }
                }
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        document.addEventListener('DOMContentLoaded', () => new SimulationManager());
    </script>
</body>
</html>