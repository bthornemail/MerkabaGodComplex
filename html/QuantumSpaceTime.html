<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platonic Reality Simulation Field</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.6);
            border-radius: 8px;
            max-width: 350px;
        }
        h1 { font-size: 1.2em; margin-top: 0; }
        p, label { font-size: 0.9em; }
        input { width: 100%; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Platonic Reality Simulation</h1>
        <p>A dynamic field where each tetrahedron generates a force based on its scalar state. Positive scalars (red) are repulsive; negative scalars (blue) are attractive. Change the L-Value to alter the forces of nature.</p>
        <label for="l-slider">Universal L-Value (Exponent): <span id="l-value">1.00</span></label>
        <input type="range" id="l-slider" min="-5" max="5" step="0.01" value="1">
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Universal Binary Transformer Algorithms (TypeScript-style) ---

        /**
         * @description The core scalar function Ï†(r_i, L). This now represents a force potential.
         * @param {THREE.Vector3} r - The data vector for a vertex.
         * @param {number} L - The exponent, representing state or "logical time".
         * @returns {number} The calculated scalar value (force magnitude).
         */
        function calculateScalar(r, L) {
            if (Math.abs(L) < 0.001) {
                return 0; // Avoid instability near zero.
            }
            // Your formula: (x^L + y^L + z^L) / L
            const numerator = Math.pow(r.x, L) + Math.pow(r.y, L) + Math.pow(r.z, L);
            return numerator / L;
        }

        /**
         * @description A class representing a Tetrahedron system with physical properties.
         */
        class TetrahedronSystem {
            constructor(initialPosition) {
                // Physics properties
                this.position = initialPosition;
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();

                // Geometric and data properties
                this.baseVertices = [
                    new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, -1, 1),
                    new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, -1, -1)
                ];
                this.dataVectors = [
                    new THREE.Vector3(1, 0.5, 0.2), new THREE.Vector3(0.2, 1, 0.5),
                    new THREE.Vector3(0.5, 0.2, 1), new THREE.Vector3(1, 1, 0.2)
                ];
                this.scalars = [0, 0, 0, 0];
            }

            /**
             * @description Updates the scalar values based on the current L.
             * @param {number} L - The current state exponent.
             */
            updateScalars(L) {
                for (let i = 0; i < this.dataVectors.length; i++) {
                    this.scalars[i] = calculateScalar(this.dataVectors[i], L);
                }
            }

            /**
             * @description Calculates the net force for the tetrahedron.
             * @returns {number} The average scalar value, representing force magnitude.
             */
            getNetForce() {
                return this.scalars.reduce((a, b) => a + b, 0) / this.scalars.length;
            }
        }

        // --- Three.js Visualization Setup ---

        let scene, camera, renderer, controls;
        const clock = new THREE.Clock();
        const field = []; // Will store { system: TetrahedronSystem, mesh: THREE.Mesh }

        // --- Field Parameters ---
        const GRID_SIZE = 5;
        const SPACING = 5;
        const MAX_DISTANCE = Math.sqrt(3) * (GRID_SIZE - 1) * SPACING / 2;
        const FORCE_STRENGTH = 0.5; // Multiplier for the force effect
        const DAMPING = 0.97; // Friction to prevent infinite velocity

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.025);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            createField();
            
            document.getElementById('l-slider').addEventListener('input', (event) => {
                const lValue = parseFloat(event.target.value);
                document.getElementById('l-value').textContent = lValue.toFixed(2);
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function createField() {
            const offset = (GRID_SIZE - 1) * SPACING / 2;

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let z = 0; z < GRID_SIZE; z++) {
                        const centerPosition = new THREE.Vector3(
                            x * SPACING - offset,
                            y * SPACING - offset,
                            z * SPACING - offset
                        );
                        
                        const system = new TetrahedronSystem(centerPosition.clone());
                        
                        const geometry = new THREE.BufferGeometry();
                        const material = new THREE.MeshStandardMaterial({
                            vertexColors: true,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.8
                        });

                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.copy(centerPosition);
                        scene.add(mesh);
                        field.push({ system, mesh });
                    }
                }
            }
        }

        function updatePhysicsAndVisuals(deltaTime) {
            const lValue = parseFloat(document.getElementById('l-slider').value);
            const color = new THREE.Color();

            for (const item of field) {
                const { system, mesh } = item;

                // 1. Update scalar values (force potential)
                system.updateScalars(lValue);

                // 2. Calculate and apply forces
                const forceMagnitude = system.getNetForce();
                const direction = system.position.length() > 0.01 ? system.position.clone().normalize() : new THREE.Vector3();
                const forceVector = direction.multiplyScalar(forceMagnitude * FORCE_STRENGTH);
                
                system.acceleration.copy(forceVector);
                system.velocity.add(system.acceleration.clone().multiplyScalar(deltaTime));
                system.velocity.multiplyScalar(DAMPING);
                system.position.add(system.velocity.clone().multiplyScalar(deltaTime));

                // 3. Update mesh position
                mesh.position.copy(system.position);

                // 4. Update mesh geometry based on "binary buffer" concept
                const morphFactor = system.position.length() / MAX_DISTANCE;
                const morphedPositions = system.baseVertices.map(p => p.clone().multiplyScalar(morphFactor));
                
                const geometry = mesh.geometry;
                geometry.setFromPoints([
                    morphedPositions[0], morphedPositions[1], morphedPositions[2],
                    morphedPositions[0], morphedPositions[1], morphedPositions[3],
                    morphedPositions[0], morphedPositions[2], morphedPositions[3],
                    morphedPositions[1], morphedPositions[2], morphedPositions[3],
                ]);
                geometry.computeVertexNormals();
                geometry.attributes.position.needsUpdate = true;

                // 5. Update mesh colors based on scalar values
                const { scalars } = system;
                const minScalar = Math.min(...scalars);
                const maxScalar = Math.max(...scalars);
                const colors = [];

                for (const scalar of scalars) {
                    const normalized = (maxScalar - minScalar) > 0.0001 ? (scalar - minScalar) / (maxScalar - minScalar) : 0.5;
                    color.setHSL(0.7 * (1 - normalized), 1.0, 0.5); // Blue to Red
                    colors.push(color.r, color.g, color.b);
                }

                const faceColors = [
                    ...colors.slice(0, 3), ...colors.slice(3, 6), ...colors.slice(6, 9),
                    ...colors.slice(0, 3), ...colors.slice(3, 6), ...colors.slice(9, 12),
                    ...colors.slice(0, 3), ...colors.slice(6, 9), ...colors.slice(9, 12),
                    ...colors.slice(3, 6), ...colors.slice(6, 9), ...colors.slice(9, 12),
                ];
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(faceColors, 3));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            controls.update();
            updatePhysicsAndVisuals(deltaTime);
            renderer.render(scene, camera);
        }

        // --- Run ---
        init();
        animate();

    </script>
</body>
</html>
