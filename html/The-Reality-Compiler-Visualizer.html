<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Reality Compiler Visualizer</title>
    <!-- Tailwind CSS for styling the UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #1a1a2e;
            color: white;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            padding: 1rem;
            background: rgba(45, 45, 66, 0.8);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        .btn {
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .btn-run {
            background-image: linear-gradient(to right, #6d28d9, #9333ea);
        }
        .btn-rollback {
            background-color: #ef4444;
        }
        .btn-sync {
            background-image: linear-gradient(to right, #10b981, #059669);
        }
    </style>
</head>
<body>

    <div class="ui-container">
        <button id="runBtn" class="btn btn-run">Run Cycle</button>
        <button id="rollbackBtn" class="btn btn-rollback">Rollback</button>
        <button id="syncBtn" class="btn btn-sync">Remote Sync</button>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. SET UP THE THREE.JS SCENE ---
        // A minimal setup to get a basic 3D environment running.
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add ambient light for general illumination
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Add a point light to cast shadows and highlights
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);

        camera.position.z = 10;

        // Mouse and touch control for camera rotation
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.01;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y,
            };
            const rotationQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(
                -deltaMove.y * rotationSpeed,
                -deltaMove.x * rotationSpeed,
                0,
                'XYZ'
            ));
            scene.quaternion.multiplyQuaternions(rotationQuaternion, scene.quaternion);
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });
        
        // Handle touch events for mobile rotation
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition.x = e.touches[0].clientX;
                previousMousePosition.y = e.touches[0].clientY;
            }
        });

        document.addEventListener('touchend', () => {
            isDragging = false;
        });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging || e.touches.length !== 1) return;
            const deltaMove = {
                x: e.touches[0].clientX - previousMousePosition.x,
                y: e.touches[0].clientY - previousMousePosition.y,
            };
            const rotationQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(
                -deltaMove.y * rotationSpeed,
                -deltaMove.x * rotationSpeed,
                0,
                'XYZ'
            ));
            scene.quaternion.multiplyQuaternions(rotationQuaternion, scene.quaternion);
            previousMousePosition.x = e.touches[0].clientX;
            previousMousePosition.y = e.touches[0].clientY;
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 2. THE REALITY COMPILER ALGORITHM (VISUAL) ---
        // This is where the abstract concepts are mapped to 3D objects.
        
        let localPolytope = []; // Represents the local execution trace / polytope
        let remotePolytope = []; // Represents a separate, remote trace
        let isSynced = false;

        // Function to create a single tetrahedron "cell"
        function createTetrahedron(position, color, scale = 1) {
            // A custom geometry for a perfect tetrahedron
            const vertices = [
                1, 1, 1,   -1, -1, 1,   -1, 1, -1,   1, -1, -1
            ];
            const indices = [
                2, 1, 0,   0, 3, 2,   1, 3, 0,   2, 3, 1
            ];
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color, 
                shininess: 100,
                specular: 0xcccccc,
                flatShading: false,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y, position.z);
            mesh.scale.set(scale, scale, scale);
            return mesh;
        }

        // Run Cycle (corresponds to a single execution of realityCompiler)
        function runCycle() {
            // "Run Cycle" corresponds to a single execution of the realityCompiler algorithm.
            // It generates a new "tetrahedron" (3-simplex cell) based on a new consensus.
            const newPos = {
                x: (Math.random() - 0.5) * 5,
                y: (Math.random() - 0.5) * 5,
                z: (Math.random() - 0.5) * 5
            };
            const newTetra = createTetrahedron(newPos, new THREE.Color(Math.random() * 0xffffff));
            scene.add(newTetra);
            localPolytope.push(newTetra);

            // If the local polytope is bound to another, new tetrahedrons should be attached to the previous one
            if (localPolytope.length > 1) {
                const lastTetra = localPolytope[localPolytope.length - 2];
                // "Binding two traces" is a visual attachment to the last created element.
                newTetra.position.copy(lastTetra.position).add(new THREE.Vector3(2, 0, 0));
            }
        }

        // Rollback (corresponds to popping a state)
        function rollback() {
            if (localPolytope.length > 0) {
                // "Rollback" is analogous to "popping" a tetrahedron from the growth history.
                const lastTetra = localPolytope.pop();
                scene.remove(lastTetra);
            }
        }

        // Remote Sync (corresponds to "gluing" two polytopes)
        function remoteSync() {
            if (localPolytope.length === 0) {
                 // Create a placeholder remote polytope to sync with.
                for (let i = 0; i < 3; i++) {
                     const remoteTetra = createTetrahedron(new THREE.Vector3(i * 2, -5, 0), 0x00bfff); // Blue tetrahedrons for remote
                     scene.add(remoteTetra);
                     remotePolytope.push(remoteTetra);
                }
            }
            if (!isSynced && localPolytope.length > 0) {
                // "Remote Sync" is the "gluing" of two separate polytopes.
                // We align the remote polytope with the last local one.
                const lastLocalTetra = localPolytope[localPolytope.length - 1];
                remotePolytope.forEach((tetra, index) => {
                    const newPos = lastLocalTetra.position.clone().add(new THREE.Vector3(2 + index * 2, 0, 0));
                    tetra.position.lerp(newPos, 0.5); // Smoothly move it into place
                    localPolytope.push(tetra); // Now it's part of the local polytope
                });
                isSynced = true;
                // Once synced, the `realityCompiler` function will treat this new, combined polytope as the new basis for growth.
            }
        }

        // --- 3. THE MAIN ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            // Rotate the entire scene slightly to show the 3D nature of the polytope.
            if (!isDragging) {
                scene.rotation.y += 0.005;
                scene.rotation.x += 0.002;
            }
            renderer.render(scene, camera);
        }

        // Start the animation on window load.
        window.onload = function () {
             // Add initial tetrahedron
            const initialTetra = createTetrahedron({x:0,y:0,z:0}, 0xffd700);
            scene.add(initialTetra);
            localPolytope.push(initialTetra);
            animate();
        }

        // Attach event listeners to the buttons
        document.getElementById('runBtn').addEventListener('click', runCycle);
        document.getElementById('rollbackBtn').addEventListener('click', rollback);
        document.getElementById('syncBtn').addEventListener('click', remoteSync);

    </script>
</body>
</html>
