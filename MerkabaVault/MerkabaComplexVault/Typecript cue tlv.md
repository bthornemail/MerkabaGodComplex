// src/common/ubhp_types.ts
// NEW FILE: Defines core types for the Universal Binary Hypergraph Protocol (UBHP).

/**
 * SExprType Enumeration for Canonical Encoding
 * Defines the types of S-expressions for canonical binary serialization.
 * These types are fundamental for representing all data and executable logic
 * within the CUE as ArrayBuffers.
 */
export enum SExprType {
  NULL = 0x00,
  BOOL = 0x01,
  INT32 = 0x02,
  INT64 = 0x03, // For 64-bit integers
  FLOAT32 = 0x04, // For single-precision floats
  FLOAT64 = 0x05, // For double-precision floats
  STRING = 0x06, // UTF-8 encoded string
  SYMBOL = 0x07, // Lisp-style symbol (UTF-8 encoded)
  LIST = 0x08, // Ordered sequence of S-expressions
  LAMBDA = 0x09, // Executable function body as a nested S-expression
  REFERENCE = 0x0A, // Reference to another S-expression by its content-based address
  MODEL_WEIGHTS = 0x0B, // Specific type for serialized AI model weights (ArrayBuffer)
  SEED_TRANSFORM = 0x0C // Specific type for seed transformation data
}

/**
 * Represents a Harmonic Vector, a numerical signature derived from an ArrayBuffer S-expression.
 * This enables perceptual content addressing and geometric analysis.
 * It embodies the "point domain" transformation of binary data ("word domain").
 */
export interface HarmonicVector {
  id: string; // Unique identifier derived from the harmonic properties (perceptual content address)
  length: number; // Original byte length of the binary S-expression ArrayBuffer
  sin: number;    // Sine component derived from the Euclidean norm
  cos: number;    // Cosine component derived from the Golden Ratio
  tan: number;    // Tangent component derived from the Euclidean norm
  h: number;      // Hypotenuse (Euclidean norm) of the byte values
  buffer: ArrayBuffer; // The original ArrayBuffer S-expression, preserved for integrity
}

/**
 * Represents a transformation matrix in the harmonic space.
 * These matrices quantify the "translation" or shift in harmonic frequencies
 * between different states or interactions.
 * (Conceptual, simplified for prototype)
 */
export type TransformMatrix = number[][];

/**
 * Represents a Rectification Proof, which is generated by CAR.
 * It links a new event to an older event it has rectified, along with the proof.
 */
export interface RectificationProof {
  rectifiedEventId: string; // The ID of the older event that was rectified
  rectifyingEventId: string; // The ID of the new event that performed the rectification
  proofHash: string; // The cryptographic hash satisfying the dynamic prime modulus
  timestamp: number;
}

// --- UBHP-Specific Data Structures (Conceptual for full implementation) ---
// These interfaces are defined in the UBHP white paper but are complex.
// They are included here for conceptual completeness, though their full
// serialization/deserialization is not implemented in this prototype.

export interface SeedTransform {
  features: ArrayBuffer[];
  transformMatrix: Float32Array;
  consensusThreshold: number;
}

export interface ModelWeights {
  id: string;
  weights: ArrayBuffer;
  seedTransform: SeedTransform;
  harmonicSignature: HarmonicVector;
}


// src/common/canonical_sexpr.ts
// NEW FILE: Implements canonical binary serialization for S-expressions (TLV).

import { SExprType, HarmonicVector, ModelWeights, SeedTransform } from './ubhp_types';

/**
 * Variable-length integer encoding (LEB128-like for lengths).
 * Ensures compact representation for lengths and values.
 * @param value The number to encode.
 * @returns A Uint8Array representing the encoded variable-length integer.
 */
export function encodeVarInt(value: number): Uint8Array {
  const result: number[] = [];
  while (value >= 0x80) {
    result.push((value & 0x7F) | 0x80);
    value >>>= 7;
  }
  result.push(value & 0x7F); // Last byte does not have 0x80 bit set
  return new Uint8Array(result);
}

/**
 * CanonicalSExprEncoder Class Structure.
 * This class provides methods to serialize various data types into a canonical ArrayBuffer.
 * This is crucial for content-addressing, as identical logical content must produce identical binary.
 */
export class CanonicalSExprEncoder {
  private buffer: number[] = []; // Internal buffer for byte accumulation

  /** Encodes a null value. */
  encodeNull(): void { this.buffer.push(SExprType.NULL); }

  /** Encodes a boolean value. */
  encodeBool(value: boolean): void { this.buffer.push(SExprType.BOOL, value ? 1 : 0); }

  /** Encodes a 32-bit integer. */
  encodeInt32(value: number): void {
    this.buffer.push(SExprType.INT32);
    const view = new DataView(new ArrayBuffer(4));
    view.setInt32(0, value, true); // Little-endian
    for (let i = 0; i < 4; i++) this.buffer.push(view.getUint8(i));
  }

  /** Encodes a 64-bit float. */
  encodeFloat64(value: number): void {
    this.buffer.push(SExprType.FLOAT64);
    const view = new DataView(new ArrayBuffer(8));
    view.setFloat64(0, value, true); // Little-endian
    for (let i = 0; i < 8; i++) this.buffer.push(view.getUint8(i));
  }

  /** Encodes a UTF-8 string. */
  encodeString(value: string): void {
    this.buffer.push(SExprType.STRING);
    const utf8Bytes = new TextEncoder().encode(value);
    const lengthBytes = encodeVarInt(utf8Bytes.length);
    this.buffer.push(...lengthBytes, ...utf8Bytes);
  }

  /** Encodes a Lisp-style symbol (UTF-8 encoded). */
  encodeSymbol(value: string): void {
    this.buffer.push(SExprType.SYMBOL);
    const utf8Bytes = new TextEncoder().encode(value);
    const lengthBytes = encodeVarInt(utf8Bytes.length);
    this.buffer.push(...lengthBytes, ...utf8Bytes);
  }

  /**
   * Encodes a list of S-expressions.
   * Lists are encoded by their type, then the total length of their concatenated elements,
   * followed by the concatenated binary S-expressions of each element in order.
   * @param elements An array of ArrayBuffers, each representing a serialized S-expression.
   */
  encodeList(elements: ArrayBuffer[]): void {
    this.buffer.push(SExprType.LIST);
    const elementBuffers: Uint8Array[] = elements.map(e => new Uint8Array(e));
    let totalContentLength = 0;
    for (const elBuf of elementBuffers) totalContentLength += elBuf.length;

    const lengthBytes = encodeVarInt(totalContentLength); // Length of concatenated elements
    this.buffer.push(...lengthBytes);
    for (const elBuf of elementBuffers) this.buffer.push(...Array.from(elBuf));
  }

  /**
   * Encodes a lambda function body as a nested S-expression.
   * @param body An ArrayBuffer representing the serialized function logic.
   */
  encodeLambda(body: ArrayBuffer): void {
    this.buffer.push(SExprType.LAMBDA);
    const bodyArray = Array.from(new Uint8Array(body));
    const lengthBytes = encodeVarInt(bodyArray.length);
    this.buffer.push(...lengthBytes, ...bodyArray);
  }

  /**
   * Encodes a reference to another S-expression by its content-based address.
   * @param contentAddress An ArrayBuffer containing the raw bytes of the content address (e.g., a hash).
   */
  encodeReference(contentAddress: ArrayBuffer): void {
    this.buffer.push(SExprType.REFERENCE);
    const addressArray = Array.from(new Uint8Array(contentAddress));
    const lengthBytes = encodeVarInt(addressArray.length);
    this.buffer.push(...lengthBytes, ...addressArray);
  }

  /**
   * Encodes ModelWeights. (Simplified for prototype)
   * @param weights The ModelWeights object.
   */
  encodeModelWeights(weights: ModelWeights): void {
    this.buffer.push(SExprType.MODEL_WEIGHTS);
    this.encodeString(weights.id); // Encode ID
    this.encodeReference(new Uint8Array(weights.weights).buffer); // Reference to weights buffer (simplified)
    // Full implementation would encode SeedTransform and HarmonicSignature recursively
  }

  /**
   * Encodes SeedTransform. (Simplified for prototype)
   * @param transform The SeedTransform object.
   */
  encodeSeedTransform(transform: SeedTransform): void {
    this.buffer.push(SExprType.SEED_TRANSFORM);
    this.encodeList(transform.features); // Encode list of feature buffers
    this.encodeReference(new Uint8Array(transform.transformMatrix.buffer).buffer); // Reference to matrix (simplified)
    this.encodeFloat64(transform.consensusThreshold); // Encode threshold
  }

  /**
   * Encodes a HarmonicVector. (Simplified for prototype)
   * @param signature The HarmonicVector object.
   */
  encodeHarmonicSignature(signature: HarmonicVector): void {
    this.buffer.push(SExprType.REFERENCE); // Using REFERENCE type as a proxy for a content address
    this.encodeString(signature.id); // The ID is the content address
    // In a full implementation, the actual numeric values (length, sin, cos, tan, h)
    // would be encoded as a small list of floats.
  }

  /**
   * Returns the accumulated ArrayBuffer.
   * @returns The canonical ArrayBuffer representation of the S-expression.
   */
  getBuffer(): ArrayBuffer {
    return new Uint8Array(this.buffer).buffer;
  }

  /**
   * Static helper to serialize a simple JavaScript object into a canonical S-expression ArrayBuffer.
   * This is a simplified mapping for the prototype. A full implementation would traverse the object
   * and map its properties to SExprTypes.
   * @param obj The JavaScript object to serialize.
   * @returns An ArrayBuffer representing the canonical S-expression.
   */
  static serializeObject(obj: any): ArrayBuffer {
    const encoder = new CanonicalSExprEncoder();
    // For simplicity, we'll serialize objects as a list of key-value pairs (symbols and strings/numbers)
    // This is a basic representation, not a full UBHP object serialization.
    const elements: ArrayBuffer[] = [];
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        encoder.buffer = []; // Clear buffer for each element
        encoder.encodeSymbol(key);
        elements.push(encoder.getBuffer());

        encoder.buffer = []; // Clear buffer for value
        const value = obj[key];
        if (typeof value === 'string') {
          encoder.encodeString(value);
        } else if (typeof value === 'number') {
          encoder.encodeFloat64(value);
        } else if (typeof value === 'boolean') {
          encoder.encodeBool(value);
        } else if (value === null) {
          encoder.encodeNull();
        } else if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
          encoder.encodeReference(value); // Treat as reference for simplicity
        } else {
          // Recursive call for nested objects, or handle as string for now
          encoder.encodeString(JSON.stringify(value));
        }
        elements.push(encoder.getBuffer());
      }
    }
    encoder.buffer = []; // Reset main encoder buffer
    encoder.encodeList(elements);
    return encoder.getBuffer();
  }
}


// src/common/harmonic_geometry.ts
// NEW FILE: Implements harmonic signature generation and geometric primitives.

import { HarmonicVector } from './ubhp_types';
import { createHash } from 'crypto'; // For SHA-256

/**
 * Generates a numerical signature (HarmonicVector) from an ArrayBuffer S-expression.
 * This enables perceptual content addressing and geometric analysis.
 * It transforms the "word domain" (binary data) into the "point domain" (geometric representation).
 * @param inputSExpr The input ArrayBuffer S-expression.
 * @param originBuffer Optional origin for XOR operation (for shared context consensus).
 * @returns A HarmonicVector representing the S-expression's harmonic signature.
 */
export function harmonize(
  inputSExpr: ArrayBuffer,
  originBuffer?: ArrayBuffer
): HarmonicVector {
  const view = new Uint8Array(inputSExpr);
  const rawValues = Array.from(view);

  // XOR with origin if provided (for shared context consensus)
  const values = originBuffer
    ? rawValues.map((v, i) => v ^ new Uint8Array(originBuffer)[i % originBuffer.byteLength])
    : rawValues;

  const h = Math.hypot(...values); // Euclidean norm of the byte values
  const sin = Math.sin(h / Math.PI);
  const cos = Math.cos(h / 1.61803398875); // Golden ratio constant
  const tan = Math.tan(Math.PI / (h || 1e-10)); // Avoid division by zero

  // Generate a canonical ID using a cryptographic hash for uniqueness, augmented by harmonic properties.
  // This ensures collision resistance while retaining perceptual addressing.
  const cryptographicHash = createHash('sha256').update(new Uint8Array(inputSExpr)).digest('hex');
  const id = `UBHP-${cryptographicHash.substring(0, 8)}-H${h.toFixed(2)}-S${sin.toFixed(2)}-C${cos.toFixed(2)}`;

  return {
    id,
    length: values.length,
    sin,
    cos,
    tan,
    h,
    buffer: inputSExpr // Original buffer preserved, crucial for data integrity
  };
}

/**
 * Converts an ArrayBuffer (representing an S-expression) into a unit vector for geometric analysis.
 * This maps the raw binary data into an "invisible arrow pointing in a certain direction in space."
 * @param inputSExprBuffer The input ArrayBuffer S-expression.
 * @returns A number array representing the normalized vector (ray).
 */
export function typedArrayToRay(inputSExprBuffer: ArrayBuffer): number[] {
  const input = new Uint8Array(inputSExprBuffer);
  const norm = Math.hypot(...input);
  return norm === 0 ? Array.from(input) : Array.from(input).map((v) => v / norm);
}

/**
 * Quantifies the angular similarity between two normalized vectors.
 * If two things point in the same direction, they are said to be in harmony,
 * regardless of context, keywords, or language.
 * @param a The first normalized vector.
 * @param b The second normalized vector.
 * @returns The cosine similarity between the two vectors.
 */
export function cosineSimilarity(a: number[], b: number[]): number {
  let dot = 0;
  let normA = 0;
  let normB = 0;
  const len = Math.min(a.length, b.length); // Ensure same length for dot product

  for (let i = 0; i < len; i++) {
    dot += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
  return magnitude === 0 ? 0 : dot / magnitude; // Handle division by zero
}

/**
 * Computes the element-wise average of multiple numerical vectors.
 * Represents the average "content" or "form" of a collection of data features.
 * @param vectors An array of numerical vectors.
 * @returns The centroid vector.
 */
export function calculateCentroid(vectors: number[][]): number[] {
  if (vectors.length === 0) return [];
  const dimensions = vectors[0].length;
  const centroid: number[] = new Array(dimensions).fill(0);
  for (const vec of vectors) {
    if (vec.length !== dimensions) throw new Error("All vectors must have the same dimension.");
    for (let i = 0; i < dimensions; i++) centroid[i] += vec[i];
  }
  for (let i = 0; i < dimensions; i++) centroid[i] /= vectors.length;
  return centroid;
}


// src/common/types.ts
// UPDATED FILE: Added UBHP-related types and RectificationProof.

import { createHash } from 'crypto'; // Needed for generating unique IDs for Vec7HarmonyUnit
import { HarmonicVector, TransformMatrix, RectificationProof } from './ubhp_types'; // NEW IMPORT

// --- Core CUE Types ---
export type VectorState = number[];
export type KeyPair = { publicKey: string; privateKey: string; };

/**
 * Represents a signed message exchanged between peers.
 * All communications are cryptographically signed for verifiable provenance.
 */
export interface SignedMessage<T> {
  payload: T;
  sourceCredentialId: string; // The public key of the sender
  signature: string; // Base64 encoded signature of the payload
}

/**
 * Defines the scope and importance of an event, influencing the rigor of axiomatic validation.
 * This is the "Consensus Level" for Poly-Axiomatic Consensus.
 */
export type ConsensusLevel = 'LOCAL' | 'PEER_TO_PEER' | 'GROUP' | 'GLOBAL';

/**
 * The fundamental data structure for axiomatic validation, representing a state or event.
 * It must pass through seven phases of coherence, conceptually mapped to a Fano Plane.
 * Each Vec7HarmonyUnit is derived from a canonical ArrayBuffer S-expression.
 */
export interface Vec7HarmonyUnit {
  id: string; // Unique ID for this specific Vec7HarmonyUnit instance (e.g., hash of its content)
  phase: number; // The current phase of validation (0-6)
  vec1: { byteLength: number }; // Corresponds to Phase 0 (Read)
  vec2: { byteLength: number }; // Corresponds to Phase 1 (Write)
  vec3: [number, number, number]; // Corresponds to Phase 2 (Transform), representing geometric properties
  vec4: { bufferLengths: number[] }; // Corresponds to Phase 3 (Render)
  vec5: { byteLength: number }; // Corresponds to Phase 4 (Serialize)
  vec6: { byteLength: number }; // Corresponds to Phase 5 (Verify)
  vec7: { byteLength: number }; // Corresponds to Phase 6 (Harmonize)
  harmonicSignature: HarmonicVector; // The UBHP harmonic signature of the underlying S-expression
  underlyingSExprHash: string; // Cryptographic hash of the canonical S-expression
}

// --- Token Economy ---
export type TokenType = 'FUNGIBLE' | 'NON_FUNGIBLE';

/**
 * Represents the state of a digital asset within the CUE.
 * Tokens are native ledger entries, not external assets.
 */
export interface TokenState {
  tokenId: string;
  type: TokenType;
  ownerCredentialId: string;
  metadata: { name: string; description:string; [key: string]: any; };
}

/**
 * Represents a proposal for an atomic swap between tokens.
 * (Conceptual for future implementation)
 */
export interface SwapProposal {
  proposalId: string;
  offeredTokenId: string;
  requestedTokenId: string;
}

// --- Harmonic Compute ---
export type WasiCapability = 'logToConsole';

/**
 * Represents a peer's advertised compute resources and performance-based reputation.
 */
export interface ResourceManifest {
  jobsCompleted: number;
  avgExecutionTimeMs: number;
  reputation: number;
}

/**
 * Payload for a compute request, including the metered WASM binary and payment offer.
 */
export interface ComputeRequestPayload {
  jobId: string;
  meteredWasmBinary: number[]; // Array of bytes representing the WASM binary
  functionName: string;
  inputData: any[]; // Input arguments for the WASM function
  gasLimit: number;
  requestedCapabilities: WasiCapability[];
  paymentOffer: { tokenId: string, amount?: number };
}

// --- Agentic RPC (NEW PAYLOAD TYPES) ---
export interface TemperatureReadingPayload {
  sensorId: string;
  timestamp: number; // Unix timestamp in milliseconds
  value: number;
  unit: string;
}

export interface HVACCommandPayload {
  hvacId: string;
  command: 'HEAT' | 'COOL' | 'OFF';
  targetTemperature: number;
  timestamp: number;
}

export interface ThermostatPolicyPayload {
  agentId: string;
  desiredTemperature: number;
  tolerance: number;
  hvacDeviceId: string;
  sensorDeviceId: string;
}

/**
 * The top-level CUE event, broadcast across the network.
 * Includes new event types for agent interactions and rectification proofs.
 */
export interface CUE_Event {
  type: 'MINT_TOKEN' | 'PROPOSE_SWAP' | 'ACCEPT_SWAP' | 'COMPUTE_REQUEST' | 'SENSOR_READING' | 'HVAC_COMMAND' | 'SET_AGENT_POLICY' | 'RECTIFICATION_PROOF'; // NEW EVENT TYPE
  level: ConsensusLevel;
  payload: any;
  timestamp: number;
  // Add an optional field for the underlying S-expression hash, to link events to their UBHP representation
  // In a full implementation, the payload itself might be the serialized S-expression.
  sExprHash?: string;
}


// src/common/axioms.ts
// UPDATED FILE: HarmonyProcessor now leverages HarmonicVector for validation.

import { Vec7HarmonyUnit, ConsensusLevel } from './types';
import chalk from 'chalk';
import { HarmonicVector } from './ubhp_types'; // NEW IMPORT
import { cosineSimilarity } from './harmonic_geometry'; // NEW IMPORT

// This is the Grand Unified Axiom engine, implementing Poly-Axiomatic Consensus.

/**
 * Calculates a simple sum of byte lengths from a Vec7HarmonyUnit.
 * This is used for the Rectification Law.
 * @param unit The Vec7HarmonyUnit.
 * @returns The sum of relevant byte lengths.
 */
const getVectorSum = (unit: Vec7HarmonyUnit): number => {
    return unit.vec1.byteLength + unit.vec2.byteLength + unit.vec3.reduce((a,b)=>a+b,0) + unit.vec4.bufferLengths.reduce((a,b)=>a+b,0) + unit.vec5.byteLength + unit.vec6.byteLength + unit.vec7.byteLength;
}

/**
 * Implements the Harmonic Axioms, defining the prime moduli checks for each phase.
 * These checks ensure the intrinsic structural and logical coherence of a Vec7HarmonyUnit.
 * Conceptually, this relates to the Fano Plane grounding of the 7 phases.
 */
class HarmonicAxioms {
  // Definitive prime sets for each consensus level.
  // These primes are chosen based on their significance in the CUE's divine axiomatic system.
  private static readonly CONSENSUS_PRIMES: Record<ConsensusLevel, number[]> = {
      LOCAL: [3],        // Internal state management (e.g., rectification)
      PEER_TO_PEER: [3, 5], // Simple, direct interactions (e.g., messages, basic RPC)
      GROUP: [3, 5, 7],    // Actions affecting a limited set of peers (e.g., compute jobs, atomic swaps)
      GLOBAL: [3, 5, 7, 11] // Foundational state changes affecting the entire network (e.g., token minting)
  };

  /**
   * Performs a universal phase check against a given prime.
   * This is a simplified check for demonstration. In a full implementation, each phase
   * would have a specific, complex check related to its prime property (e.g., Modulo Prime, Twin Primes).
   * @param data The Vec7HarmonyUnit.
   * @param prime The prime number to check against.
   * @returns True if the magnitude is divisible by the prime, false otherwise.
   */
  private static universalPhaseCheck = (data: Vec7HarmonyUnit, prime: number): boolean => {
      // The magnitude here is a simplified representation of the unit's "energy" or "complexity".
      // In a full system, this would involve more intricate calculations based on the actual vector components.
      const magnitude = data.vec1.byteLength + data.vec5.byteLength + data.vec7.byteLength + data.harmonicSignature.h;
      return magnitude % prime === 0;
  }

  /**
   * Validates a Vec7HarmonyUnit against the required primes for a given consensus level.
   * @param vec7 The Vec7HarmonyUnit to validate.
   * @param level The ConsensusLevel for validation.
   * @returns True if all required prime checks pass, false otherwise.
   */
  static validateHarmonyUnit(vec7: Vec7HarmonyUnit, level: ConsensusLevel): boolean {
    const requiredPrimes = this.CONSENSUS_PRIMES[level];
    for (const prime of requiredPrimes) {
        if (!this.universalPhaseCheck(vec7, prime)) {
            console.error(chalk.red(`[Axiom] Check failed for phase ${vec7.phase} against prime base ${prime}.`));
            return false;
        }
    }
    return true;
  }
}

/**
 * The Harmony Processor is the Grand Unified Axiom engine.
 * It validates state transitions and ensures all changes adhere to the CUE's axiomatic principles.
 * This includes the "Rectification Law" (delta % 24 === 0), which is tied to the higher-order
 * universal constant %24===0, signifying "Full Merkaba Rectification."
 */
export class HarmonyProcessor {
  // RECTIFICATION_BASE (24) is a critical higher-order universal constant.
  // It signifies a biphasic dodecahedral cycle or a doubled completion, and is linked
  // to the emergence of five superimposed dodecahedron universes.
  // A state transition must be harmonically balanced by this base.
  private static readonly RECTIFICATION_BASE = 24;

  /**
   * Validates a state transition between an input and an output Vec7HarmonyUnit.
   * This is the core of the CUE's axiomatic consensus.
   * @param inputUnit The Vec7HarmonyUnit representing the state before the transition.
   * @param outputUnit The Vec7HarmonyUnit representing the state after the transition.
   * @param level The ConsensusLevel of the event triggering the transition.
   * @returns True if the transition is axiomatically valid, false otherwise.
   */
  static validateTransition(
    inputUnit: Vec7HarmonyUnit,
    outputUnit: Vec7HarmonyUnit,
    level: ConsensusLevel
  ): boolean {
    // 1. Validate the input state's intrinsic harmonic coherence.
    if (!HarmonicAxioms.validateHarmonyUnit(inputUnit, level)) {
        console.error(chalk.red.dim(`[HarmonyProcessor] Validation failed: Input state for phase ${inputUnit.phase} is invalid at consensus level '${level}'.`));
        return false;
    }
    // 2. Validate the output state's intrinsic harmonic coherence.
    if (!HarmonicAxioms.validateHarmonyUnit(outputUnit, level)) {
        console.error(chalk.red.dim(`[HarmonyProcessor] Validation failed: Output state for phase ${outputUnit.phase} is invalid at consensus level '${level}'.`));
        return false;
    }

    // 3. Apply the Rectification Law: The delta between input and output must be a multiple of RECTIFICATION_BASE.
    // This ensures the transition itself is harmonically balanced, contributing to "Full Merkaba Rectification."
    const transitionDelta = Math.abs(getVectorSum(outputUnit) - getVectorSum(inputUnit));
    if (transitionDelta % this.RECTIFICATION_BASE !== 0) {
        console.error(chalk.red.dim(`[HarmonyProcessor] Validation failed: State transition (delta=${transitionDelta}) was not harmonically balanced by base ${this.RECTIFICATION_BASE}.`));
        return false;
    }

    // 4. (Conceptual) Geometric Consensus Check for deeper coherence.
    // This would involve comparing the harmonic signatures of input and output units.
    // For a simple check, we can ensure a minimum cosine similarity threshold.
    const inputRay = inputUnit.harmonicSignature ? inputUnit.harmonicSignature.h : 0;
    const outputRay = outputUnit.harmonicSignature ? outputUnit.harmonicSignature.h : 0;

    // Simplified cosine similarity check for numeric 'h' values.
    // In a full implementation, typedArrayToRay would be used on the full buffer,
    // and cosineSimilarity would be applied to the resulting vectors.
    const geometricCoherence = (inputRay === 0 && outputRay === 0) ? 1 : cosineSimilarity([inputRay], [outputRay]);
    const GEOMETRIC_CONSENSUS_THRESHOLD = 0.7; // Example threshold

    if (geometricCoherence < GEOMETRIC_CONSENSUS_THRESHOLD) {
        console.error(chalk.red.dim(`[HarmonyProcessor] Validation failed: Geometric coherence (${geometricCoherence.toFixed(2)}) below threshold ${GEOMETRIC_CONSENSUS_THRESHOLD}.`));
        return false;
    }

    console.log(chalk.green.dim(`[HarmonyProcessor] Transition at level '${level}' is valid against primes: [${HarmonicAxioms['CONSENSUS_PRIMES'][level].join(', ')}], and exhibits geometric coherence.`));
    return true;
  }
}


// src/core/peer.ts
// UPDATED FILE: Peer class now integrates UBHP concepts and CAR.

import { createLibp2p, Libp2p, PeerId } from 'libp2p';
import { tcp } from '@libp2p/tcp';
import { mplex } from '@libp2p/mplex';
import { noise } from '@libp2p/noise';
import { kadDHT } from '@libp2p/kad-dht';
import { fromString, toString } from 'uint8arrays';
import { KeyPair, SignedMessage, CUE_Event, TokenState, SwapProposal, ComputeRequestPayload, ResourceManifest, Vec7HarmonyUnit, RectificationProof, TemperatureReadingPayload, HVACCommandPayload, ThermostatPolicyPayload } from '../common/types';
import { CryptoUtil } from '../common/crypto';
import { Sandbox } from '../common/sandbox';
import { HarmonyProcessor } from '../common/axioms';
import { existsSync, readFileSync, writeFileSync } from 'fs';
import chalk from 'chalk';
import { CanonicalSExprEncoder } from '../common/canonical_sexpr'; // NEW IMPORT
import { harmonize, typedArrayToRay, cosineSimilarity, calculateCentroid } from '../common/harmonic_geometry'; // NEW IMPORT
import { createHash } from 'crypto'; // For cryptographic hashing in proofs

const log = (peerId: string, message: string, color: (s:string)=>string = chalk.white) => {
    console.log(`${color(`[${peerId.slice(10, 16)}]`)} ${message}`);
};

/**
 * Creates a deterministic Vec7HarmonyUnit for state validation from a given payload.
 * This function now leverages the UBHP's canonical S-expression serialization and harmonic signatures.
 * Each Vec7HarmonyUnit is conceptually mapped to a Fano Plane, ensuring its intrinsic coherence.
 * @param payload The data payload to convert into a Vec7HarmonyUnit.
 * @param phase The current phase of the Vec7HarmonyUnit (0-6).
 * @returns A Vec7HarmonyUnit instance.
 */
const createVec7HarmonyUnit = (payload: any, phase: number): Vec7HarmonyUnit => {
    // 1. Canonical S-expression serialization of the payload.
    // This transforms the raw data into the UBHP's unified binary representation ("word domain").
    const sExprBuffer = CanonicalSExprEncoder.serializeObject(payload);
    const sExprHash = createHash('sha256').update(new Uint8Array(sExprBuffer)).digest('hex');

    // 2. Generate Harmonic Signature from the S-expression.
    // This transforms the S-expression into its "point domain" representation, a mathematical vibration.
    const harmonicSignature = harmonize(sExprBuffer);

    // 3. Populate Vec7HarmonyUnit components.
    // These values are simplified for the prototype but conceptually represent
    // properties derived from the S-expression and its harmonic signature.
    // In a full implementation, these would be rigorously derived from the 7 phases.
    const baseLength = harmonicSignature.length;
    const baseHash = parseInt(sExprHash.substring(0, 8), 16); // Use part of hash for deterministic values

    return {
        id: `V7-${sExprHash.substring(0, 12)}-P${phase}`, // Unique ID for this specific unit
        phase: phase,
        vec1: { byteLength: (baseLength % 11) + 1 }, // Phase 0: Read - Gatekeeping & Node Definition
        vec2: { byteLength: (baseLength % 13) + 2 }, // Phase 1: Write - Edge Definition & Interaction
        vec3: [3, 5, 7], // Phase 2: Transform - Prime Geometry (simplified)
        vec4: { bufferLengths: [11, 13] }, // Phase 3: Render - Sequential Primes (simplified)
        vec5: { byteLength: (baseLength % 17) + 5 }, // Phase 4: Serialize - Wilson Primes & Content-Addressable Reference
        vec6: { byteLength: (baseLength % 19) + 11 }, // Phase 5: Verify - Sophie Germain & Path & Provenance
        vec7: { byteLength: (baseLength % 23) + 7 }, // Phase 6: Harmonize - Circular Primes & Identity & Access
        harmonicSignature: harmonicSignature, // Link to the underlying harmonic signature
        underlyingSExprHash: sExprHash // Link to the canonical S-expression hash
    };
};

export class Peer {
  readonly credentialId: string;
  private privateKey: string;
  public node!: Libp2p;

  public peerState: VectorState = new Array(50).fill(1); // Placeholder for a more complex peer state vector.
  private tokenLedger: Map<string, TokenState> = new Map(); // Local ledger of tokens.
  private pendingSwaps: Map<string, SwapProposal> = new Map(); // Placeholder for pending swap agreements.
  // ResourceManifest for self-scored reputation.
  private resourceManifest: ResourceManifest = { jobsCompleted: 0, avgExecutionTimeMs: 0, reputation: 100 };

  // Store a history of Vec7HarmonyUnits for probabilistic rectification (CAR)
  private vec7History: Vec7HarmonyUnit[] = [];
  private readonly RECTIFICATION_HISTORY_WINDOW = 100; // Number of past events to consider for rectification

  private agentWasmBinary: Uint8Array | null = null;
  private currentThermostatPolicy: ThermostatPolicyPayload | null = null;

  constructor(private stateFilePath: string) {
    const { publicKey, privateKey } = this.loadOrGenerateIdentity();
    this.credentialId = publicKey;
    this.privateKey = privateKey;
    log(this.credentialId, `Identity loaded/generated.`, chalk.green);
  }

  private loadOrGenerateIdentity(): KeyPair {
    if (existsSync(this.stateFilePath)) {
      log(this.stateFilePath, 'Loading existing state...', chalk.yellow);
      const state = JSON.parse(readFileSync(this.stateFilePath, 'utf-8'));
      this.peerState = state.peerState;
      this.tokenLedger = new Map(state.tokenLedger);
      return { publicKey: state.credentialId, privateKey: state.privateKey };
    }
    const { publicKey, privateKey } = CryptoUtil.generateKeyPair();
    return { publicKey, privateKey };
  }

  private saveState(): void {
    const state = {
      credentialId: this.credentialId,
      privateKey: this.privateKey,
      peerState: this.peerState,
      tokenLedger: Array.from(this.tokenLedger.entries()), // Convert Map to Array for JSON serialization.
      // Note: vec7History is not persisted in this simple prototype for brevity,
      // but in a real system, it would be part of the persistent state or a separate log.
    };
    writeFileSync(this.stateFilePath, JSON.stringify(state, null, 2));
  }

  async start(bootstrapAddrs: string[] = []): Promise<void> {
    this.node = await createLibp2p({
      addresses: { listen: ['/ip4/0.0.0.0/tcp/0'] }, // Listen on all interfaces, random TCP port.
      transports: [tcp()], // Use TCP transport.
      streamMuxers: [mplex()], // Use mplex for stream multiplexing.
      connectionEncryption: [noise()], // Use noise for connection encryption.
      services: { dht: kadDHT({ protocol: '/cue-dht/1.0.0', clientMode: bootstrapAddrs.length > 0 }) }, // Kademlia DHT for peer discovery.
    });
    this.setupHandlers(); // Set up RPC handlers.
    await this.node.start();
    log(this.credentialId, `Peer online at ${this.node.getMultiaddrs()[0]?.toString()}`, chalk.cyan);
    
    for (const addr of bootstrapAddrs) {
        try {
            await this.node.dial(addr);
            log(this.credentialId, `Connected to bootstrap node ${addr.slice(-10)}`, chalk.blue);
        } catch (e) {
            log(this.credentialId, `Failed to connect to bootstrap node ${addr.slice(-10)}`, chalk.red);
        }
    }
    setInterval(() => {}, 1 << 30); // Keep the process alive indefinitely.
  }

  // Sets up handlers for incoming RPC streams.
  private setupHandlers(): void {
    this.node.handle('/cue-rpc/1.0.0', async ({ stream }) => {
        try {
            const data = await this.readStream(stream.source);
            await this.handleCUE_Event(JSON.parse(data));
        } catch (e) { log(this.credentialId, `Error handling RPC: ${(e as Error).message}`, chalk.red); }
    });
  }

  /**
   * Handles an incoming CUE event, including signature verification, axiomatic validation,
   * and Continuous Axiomatic Rectification (CAR) logic.
   * @param signedEvent The incoming signed CUE event.
   */
  private async handleCUE_Event(signedEvent: SignedMessage<CUE_Event>): Promise<void> {
    const payloadStr = JSON.stringify(signedEvent.payload);
    // 1. Identity Axiom (Signature Verification)
    if (!CryptoUtil.verify(payloadStr, signedEvent.signature, signedEvent.sourceCredentialId)) {
        log(this.credentialId, `Invalid signature from ${signedEvent.sourceCredentialId.slice(10, 16)}`, chalk.red); return;
    }
    
    const event = signedEvent.payload;
    
    // 2. Generate Vec7HarmonyUnits for axiomatic validation.
    // The "input state" is conceptually the current ledger, and "output state" is the proposed new state.
    // For simplicity in this prototype, we'll use the current tokenLedger as a proxy for input state,
    // and the event's payload as a proxy for the output state (after a hypothetical update).
    const inputUnit = createVec7HarmonyUnit(Array.from(this.tokenLedger.entries()), 0); // Current ledger state
    const outputUnit = createVec7HarmonyUnit(event.payload, 1); // Proposed state after event
    
    // 3. Poly-Axiomatic Consensus Check (HarmonyProcessor)
    if (!HarmonyProcessor.validateTransition(inputUnit, outputUnit, event.level)) {
        log(this.credentialId, `Event '${event.type}' REJECTED due to axiomatic violation.`, chalk.red.bold);
        return;
    }
    log(this.credentialId, `Processing valid event '${event.type}' from ${signedEvent.sourceCredentialId.slice(10, 16)}`, chalk.magenta);
    
    // Add the new Vec7HarmonyUnit to history for CAR.
    this.vec7History.push(outputUnit);
    if (this.vec7History.length > this.RECTIFICATION_HISTORY_WINDOW) {
      this.vec7History.shift(); // Keep history window size
    }

    // 4. Continuous Axiomatic Rectification (CAR) - Probabilistic Linkage for Rectification
    // This peer deterministically checks if it is "selected" to perform a Rectification Proof.
    // The "lottery" is based on the new event's harmonic signature and the peer's ID.
    if (event.type !== 'RECTIFICATION_PROOF') { // Avoid rectifying rectification proofs themselves
      const shouldRectify = this.shouldPerformRectification(outputUnit);
      if (shouldRectify && this.vec7History.length > 1) {
        // Select an older event from history to rectify against.
        const randomIndex = Math.floor(Math.random() * (this.vec7History.length - 1));
        const olderUnit = this.vec7History[randomIndex];
        
        log(this.credentialId, `CAR: Attempting to rectify event '${olderUnit.id.slice(0, 8)}' with new event '${outputUnit.id.slice(0, 8)}'...`, chalk.yellowBright);
        
        const rectificationProof = await this.generateRectificationProof(outputUnit, olderUnit);
        if (rectificationProof) {
          const carEvent: CUE_Event = {
            type: 'RECTIFICATION_PROOF',
            level: 'LOCAL', // Rectification proofs are LOCAL events for the generating peer
            payload: rectificationProof,
            timestamp: Date.now(),
            sExprHash: outputUnit.underlyingSExprHash // Link to the event that triggered it
          };
          // Broadcast the rectification proof to the network.
          await this.broadcast(carEvent);
          log(this.credentialId, `CAR: Broadcasted rectification proof for '${olderUnit.id.slice(0,8)}'.`, chalk.greenBright);
        } else {
          log(this.credentialId, `CAR: Failed to generate rectification proof for '${olderUnit.id.slice(0,8)}'.`, chalk.redBright);
        }
      }
    }

    // 5. Execute the event based on its type.
    switch(event.type) {
        case 'MINT_TOKEN': this.executeMint(event.payload, signedEvent.sourceCredentialId); break;
        case 'COMPUTE_REQUEST': await this.executeComputeRequest(event.payload); break;
        case 'SENSOR_READING': this.handleSensorReading(event.payload); break;
        case 'HVAC_COMMAND': this.handleHVACCommand(event.payload); break;
        case 'SET_AGENT_POLICY': this.setAgentPolicy(event.payload); break;
        case 'RECTIFICATION_PROOF': this.handleRectificationProof(event.payload); break; // NEW HANDLER
        // Future event types like PROPOSE_SWAP, ACCEPT_SWAP, etc., would be handled here.
    }
    this.saveState(); // Persist the updated state.
  }
  
  /**
   * Deterministically decides if this peer should perform a rectification proof for a given unit.
   * This is the "probabilistic linkage" aspect of CAR.
   * @param unit The Vec7HarmonyUnit to check.
   * @returns True if rectification should be performed, false otherwise.
   */
  private shouldPerformRectification(unit: Vec7HarmonyUnit): boolean {
    // A simple deterministic check based on the unit's harmonic ID and peer ID.
    // In a real system, this would be more sophisticated to ensure fair distribution of work.
    const combinedSeed = unit.harmonicSignature.id + this.credentialId;
    const hashValue = createHash('sha256').update(combinedSeed).digest('hex');
    const numericValue = parseInt(hashValue.substring(0, 4), 16); // Take first 4 hex chars
    
    // For prototype, rectify approximately 10% of the time.
    return numericValue % 1000 < 100;
  }

  /**
   * Generates a deterministic Rectification Proof.
   * This involves a "deterministic geometric proof-of-work."
   * @param rectifyingUnit The new Vec7HarmonyUnit performing the rectification.
   * @param rectifiedUnit The older Vec7HarmonyUnit being rectified.
   * @returns A RectificationProof object if successful, null otherwise.
   */
  private async generateRectificationProof(rectifyingUnit: Vec7HarmonyUnit, rectifiedUnit: Vec7HarmonyUnit): Promise<RectificationProof | null> {
    log(this.credentialId, `Generating geometric proof for rectification...`, chalk.gray);
    // 1. Get typedArrayToRay vectors for geometric consensus.
    const rectifyingRay = typedArrayToRay(rectifyingUnit.harmonicSignature.buffer);
    const rectifiedRay = typedArrayToRay(rectifiedUnit.harmonicSignature.buffer);

    // 2. Conceptual "Tetrahedron of Experience" and Centroid Calculation.
    // In a full implementation, this would involve more complex interactions with other
    // relevant Vec7HarmonyUnits in the "harmonic window" to form the 4-domain observation.
    const centroid = calculateCentroid([rectifyingRay, rectifiedRay]);

    // 3. Determine dynamic prime modulus for proof-of-work.
    // This modulus is derived from the combined harmonic properties of the two units.
    const combinedHarmonicValue = rectifyingUnit.harmonicSignature.h + rectifiedUnit.harmonicSignature.h;
    const dynamicPrimeModulus = Math.floor((combinedHarmonicValue % 19) + 3); // Ensures a prime-like modulus > 2

    // 4. Perform a simple proof-of-work: find a hash that satisfies the dynamic modulus.
    // This simulates the deterministic proof-of-work required for rectification.
    let nonce = 0;
    let proofHash = '';
    const MAX_NONCE = 10000; // Limit work for prototype

    while (nonce < MAX_NONCE) {
      const candidateHash = createHash('sha256').update(`${rectifyingUnit.id}-${rectifiedUnit.id}-${nonce}`).digest('hex');
      const numericHashPart = parseInt(candidateHash.substring(0, 8), 16); // Use first 8 hex chars
      
      if (numericHashPart % dynamicPrimeModulus === 0) {
        proofHash = candidateHash;
        break;
      }
      nonce++;
    }

    if (proofHash) {
      log(this.credentialId, `Proof generated with nonce ${nonce}, hash: ${proofHash.slice(0, 10)}...`, chalk.green.dim);
      return {
        rectifiedEventId: rectifiedUnit.id,
        rectifyingEventId: rectifyingUnit.id,
        proofHash: proofHash,
        timestamp: Date.now(),
      };
    }
    return null;
  }

  /**
   * Handles an incoming RECTIFICATION_PROOF event.
   * This peer verifies the proof and updates its internal confidence in the rectified event.
   * @param proof The RectificationProof payload.
   */
  private handleRectificationProof(proof: RectificationProof): void {
    log(this.credentialId, `Received Rectification Proof for '${proof.rectifiedEventId.slice(0, 8)}' from '${proof.rectifyingEventId.slice(0, 8)}'.`, chalk.blueBright);
    // In a full system, this would involve:
    // 1. Looking up the rectifiedEventId and rectifyingEventId in the local ledger.
    // 2. Re-running the geometric proof-of-work to verify the proofHash.
    // 3. Updating the "consensus strength" or "depth of validation" for the rectified event.
    // For this prototype, we'll just log its receipt.
  }

  private executeMint(payload: any, minterId: string) {
    const token: TokenState = { ...payload, ownerCredentialId: minterId };
    this.tokenLedger.set(token.tokenId, token);
    log(this.credentialId, `Minted token '${token.metadata.name}' for ${minterId.slice(10, 16)}`, chalk.yellow);
  }

  private async executeComputeRequest(payload: ComputeRequestPayload) {
    if (this.resourceManifest.jobsCompleted === -1) { log(this.credentialId, 'Rejecting compute job: Not a provider.', chalk.yellow); return; }
    log(this.credentialId, `Executing compute job '${payload.jobId}' in WASM sandbox...`, chalk.blue);
    try {
        const { result, duration } = await Sandbox.execute(
            Uint8Array.from(payload.meteredWasmBinary),
            payload.functionName, payload.inputData, payload.gasLimit, payload.requestedCapabilities
        );
        log(this.credentialId, `Job '${payload.jobId}' completed. Result: ${result}. Duration: ${duration.toFixed(2)}ms. Claiming payment...`, chalk.green.bold);
        this.updateReputation(duration);
    } catch (e) {
        log(this.credentialId, `Job '${payload.jobId}' failed during execution: ${(e as Error).message}`, chalk.red);
        this.resourceManifest.reputation = Math.max(0, this.resourceManifest.reputation - 10);
    }
  }

  private handleSensorReading(payload: TemperatureReadingPayload) {
    log(this.credentialId, `Received Temperature Reading: ${payload.value}°${payload.unit} from ${payload.sensorId}`, chalk.cyan);
    // If this peer is hosting an agent, trigger its logic
    if (this.agentWasmBinary && this.currentThermostatPolicy) {
        this.runAgentLogic(payload, this.currentThermostatPolicy);
    }
  }

  private handleHVACCommand(payload: HVACCommandPayload) {
    log(this.credentialId, `Executing HVAC Command: ${payload.command} to ${payload.targetTemperature}°C for ${payload.hvacId}`, chalk.green.bold);
  }

  private setAgentPolicy(payload: ThermostatPolicyPayload) {
    this.currentThermostatPolicy = payload;
    log(this.credentialId, `Agent policy set: Desired Temp ${payload.desiredTemperature}°C, Tolerance ${payload.tolerance}°C`, chalk.magentaBright);
  }

  public loadAgentWasm(binary: Uint8Array) {
    this.agentWasmBinary = binary;
    log(this.credentialId, `Agent WASM binary loaded.`, chalk.green);
  }

  private async runAgentLogic(
    sensorReading: TemperatureReadingPayload,
    policy: ThermostatPolicyPayload
  ): Promise<void> {
    if (!this.agentWasmBinary) {
      log(this.credentialId, 'No agent WASM loaded to run logic.', chalk.red);
      return;
    }

    log(this.credentialId, 'Running agent decision logic...', chalk.yellow);

    try {
      // For simplicity, we pass raw values. In a real CUE, these would be serialized
      // according to their HSDL schemas into byte arrays, and the WASM agent
      // would deserialize them using its internal adapter logic.
      // We'll create a mock memory layout for the agent WASM to read.
      const tempReadingBuffer = new ArrayBuffer(8); // For float and timestamp
      const tempReadingView = new DataView(tempReadingBuffer);
      tempReadingView.setFloat32(0, sensorReading.value, true); // Little-endian
      tempReadingView.setBigInt64(4, BigInt(sensorReading.timestamp), true);

      const policyBuffer = new ArrayBuffer(16); // For desiredTemp, tolerance, and hvacDeviceId (simplified)
      const policyView = new DataView(policyBuffer);
      policyView.setFloat32(0, policy.desiredTemperature, true);
      policyView.setFloat32(4, policy.tolerance, true);
      // For hvacDeviceId, we'll pass its hash or a simple numeric representation for this prototype.
      // In a real system, this would involve passing a pointer to the string in WASM memory.
      const hvacIdHash = createHash('sha256').update(policy.hvacDeviceId).digest('hex');
      policyView.setUint32(8, parseInt(hvacIdHash.substring(0, 8), 16), true);


      const { result: hvacCommandPtr, duration } = await Sandbox.execute(
        this.agentWasmBinary,
        'decideHVACAction',
        // Pass the buffers as Uint8Arrays for the sandbox to handle
        [new Uint8Array(tempReadingBuffer), new Uint8Array(policyBuffer)],
        1_000_000, // Gas limit for agent logic
        [] // Agent logic might not need external capabilities
      );

      // Interpret the result from WASM
      // If hvacCommandPtr is not 0, it means the agent decided on an action.
      // In a real scenario, you'd deserialize the HVACCommand from the WASM memory
      // using a helper function that understands the WASM memory layout and the HSDL schema.
      if (hvacCommandPtr !== 0) {
        // Mock deserialization for prototype:
        // Assume the WASM returns a simple integer representing the command type
        // and that the target temperature is the policy's desired temperature.
        let command: 'HEAT' | 'COOL' | 'OFF';
        switch (hvacCommandPtr) {
          case 1: command = 'HEAT'; break;
          case 2: command = 'COOL'; break;
          default: command = 'OFF'; break;
        }

        const hvacCommand: HVACCommandPayload = {
          hvacId: policy.hvacDeviceId,
          command: command,
          targetTemperature: policy.desiredTemperature,
          timestamp: Date.now(),
        };

        log(this.credentialId, `Agent decided to send HVAC command: ${hvacCommand.command}`, chalk.blueBright);
        const hvacEvent: CUE_Event = {
          type: 'HVAC_COMMAND',
          level: 'PEER_TO_PEER', // Or GROUP if multiple HVACs
          payload: hvacCommand,
          timestamp: Date.now(),
        };
        await this.broadcast(hvacEvent); // Agent autonomously broadcasts the command
      } else {
        log(this.credentialId, `Agent decided no HVAC action needed.`, chalk.gray);
      }
    } catch (e) {
      log(this.credentialId, `Agent logic failed: ${(e as Error).message}`, chalk.red);
      // Agent's reputation might be affected here.
    }
  }

  public sign<T>(payload: T): SignedMessage<T> {
    const payloadStr = JSON.stringify(payload);
    return { payload, sourceCredentialId: this.credentialId, signature: CryptoUtil.sign(payloadStr, this.privateKey) };
  }

  public async broadcast(event: CUE_Event): Promise<void> {
    const signedEvent = this.sign(event);
    log(this.credentialId, `Broadcasting event '${event.type}' to network...`, chalk.blue);
    // In a full Gossipsub implementation, this would publish to a topic.
    // For this prototype, we simulate broadcasting by dialing all known peers directly.
    for (const peerId of this.node.getPeers()) {
        try {
            const stream = await this.node.dialProtocol(peerId, '/cue-rpc/1.0.0');
            await stream.sink(this.writeStream(JSON.stringify(signedEvent)));
            stream.close();
        } catch (e) { log(this.credentialId, `Failed to broadcast to ${peerId.toString().slice(-6)}: ${(e as Error).message}`, chalk.red); }
    }
  }

  public benchmarkAndAdvertise(): void {
    this.resourceManifest = { jobsCompleted: 0, avgExecutionTimeMs: 0, reputation: 100 };
    log(this.credentialId, `Benchmark complete. Advertising as compute provider.`, chalk.yellow);
  }
  
  private updateReputation(duration: number) {
    const totalTime = this.resourceManifest.avgExecutionTimeMs * this.resourceManifest.jobsCompleted;
    this.resourceManifest.jobsCompleted++;
    this.resourceManifest.avgExecutionTimeMs = (totalTime + duration) / this.resourceManifest.jobsCompleted;
    this.resourceManifest.reputation += (10 - Math.min(10, duration / 10));
    log(this.credentialId, `Reputation updated: ${this.resourceManifest.reputation.toFixed(2)}`, chalk.yellow);
  }

  private writeStream = (data: string) => (source: any) => { source.push(fromString(data)); source.end(); }
  private readStream = async (source: any): Promise<string> => { let r = ''; for await (const c of source) r += toString(c.subarray()); return r; }
}


// assembly/agent_thermostat.ts
// NEW FILE: This WASM module represents the "brain" of our Smart Thermostat Agent.
// It takes a temperature reading and a policy, and decides if an HVAC command is needed.

// For AssemblyScript, we define interfaces that mirror our TypeScript types.
// These are conceptual for how data would be structured in WASM memory.

// @ts-ignore
@external("env", "Date.now")
declare function Date_now(): i64;

/**
 * The core agent logic.
 * Takes serialized temperature reading and thermostat policy as input.
 * Returns a simple integer representing the command (1=HEAT, 2=COOL, 0=OFF/No Action).
 *
 * @param currentTemp The current temperature reading (f32).
 * @param desiredTemp The desired temperature from the policy (f32).
 * @param tolerance The tolerance from the policy (f32).
 * @returns An integer representing the HVAC command (1 for HEAT, 2 for COOL, 0 for OFF/No Action).
 */
export function decideHVACAction(
  currentTemp: f32,
  desiredTemp: f32,
  tolerance: f32
): i32 {
  // Conceptual semantic check (agent "understands" temperature)
  // In a real ULMPKG, this would query a pre-compiled knowledge graph.
  // For this prototype, we assume the agent inherently understands these concepts.

  let command: i32 = 0; // 0 for OFF/No Action

  // Apply Principia-derived logic (conceptual: using axiomatic templates)
  // IF (currentTemp > desiredTemp + tolerance) THEN (command = "COOL")
  if (currentTemp > desiredTemp + tolerance) {
    command = 2; // COOL
  }
  // ELSE IF (currentTemp < desiredTemp - tolerance) THEN (command = "HEAT")
  else if (currentTemp < desiredTemp - tolerance) {
    command = 1; // HEAT
  } else {
    // Within tolerance, no action needed
    command = 0; // OFF / No Action
  }

  return command;
}


// package.json
// UPDATED FILE: Added new dependencies for UBHP and hashing.

{
  "name": "cue-production-prototype-final",
  "version": "1.0.0",
  "description": "The final, hardened CUE prototype with gas, capabilities, and reputation, now with UBHP and CAR integration.",
  "scripts": {
    "build:ts": "tsc",
    "build:asc": "asc assembly/index.ts --target release",
    "build:agent": "asc assembly/agent_thermostat.ts --target release --outFile assembly/build/agent_thermostat.wasm",
    "build": "npm run build:asc && npm run build:agent && npm run build:ts",
    "start:bootstrap": "node dist/nodes/bootstrap-node.js",
    "start:provider": "node dist/nodes/compute-provider.js",
    "start:client": "node dist/nodes/user-client.js",
    "start:agent": "node dist/nodes/agent-thermostat-node.js"
  },
  "dependencies": {
    "@libp2p/kad-dht": "^11.0.1",
    "@libp2p/mplex": "^9.0.0",
    "@libp2p/noise": "^13.0.0",
    "@libp2p/tcp": "^8.0.0",
    "@wasmer/wasi": "^1.2.2",
    "@wasmer/wasmfs": "^1.2.2",
    "chalk": "^4.1.2",
    "libp2p": "^1.1.0",
    "uint8arrays": "^4.0.6",
    "wasm-metering": "^2.1.0",
    "crypto-js": "^4.2.0" // NEW: For cryptographic hashing (e.g., SHA-256 for proofs)
  },
  "devDependencies": {
    "@types/node": "^20.8.9",
    "assemblyscript": "^0.27.22",
    "ts-node": "^10.9.1",
    "typescript": "^5.2.2"
  }
}


// README.md
// UPDATED FILE: Reflects new features and concepts.

# CUE - The Final Rectified Prototype


This project is a comprehensive, multi-process Node.js application demonstrating the final, hardened architecture of the Computational Universe Engine. This version integrates the **Universal Binary Hypergraph Protocol (UBHP)** and implements **Continuous Axiomatic Rectification (CAR)** as its core consensus mechanism.


## Features Implemented


-   **Real Cryptography**: ED25519 keypairs and message signing.
-   **State Persistence**: Each peer saves its identity and state to a local JSON file.
-   **Service Discovery**: Uses a `libp2p` DHT via a bootstrap node.
-   **Poly-Axiomatic Consensus**: A multi-level validation system that scales security with the importance of an event, using multi-prime checks.
-   **Unified Binary Hypergraph Protocol (UBHP)**:
    -   **Canonical S-expressions**: All data is represented as self-describing, executable binary ArrayBuffers.
    -   **Harmonic Signatures**: Data is transformed into perceptual "vibrations" for content addressing and geometric analysis.
-   **Continuous Axiomatic Rectification (CAR)**:
    -   The CUE's core consensus mechanism, ensuring continuous, emergent, and verifiable truth.
    -   Leverages **Geometric Consensus** (KNN-based alignment of harmonic vectors) for deterministic proofs.
    -   Utilizes the **Rectification Law** (transition delta % 24 === 0) for harmonically balanced state changes.
-   **Secure & Fair Compute Economy**:
    -   **WASM Sandbox**: Untrusted code is executed safely.
    -   **Gas Metering**: Prevents infinite loops and DoS attacks by limiting computation.
    -   **Reputation System**: Providers build reputation based on successful, efficient job execution, which is self-scored and propagated.
-   **Agentic Autonomy Example**: A Smart Thermostat Agent that uses WASM logic and CUE events to maintain a desired temperature.


## How to Run


You will need **four separate terminal windows** to run the full simulation, or three if you omit the `user-client`.


### Step 1: Build the Project


This is a critical first step. It compiles both the TypeScript source code and the **AssemblyScript code into WASM binaries** (for compute jobs and for the agent).


```bash
npm install
npm run build
```
This command must be run successfully before proceeding. It will create a `dist` folder and `assembly/build/optimized.wasm` (for compute) and `assembly/build/agent_thermostat.wasm` (for the agent).


### Step 2: Start the Bootstrap Node


This node acts as a stable anchor for the network.


In **Terminal 1**, run:
```bash
npm run start:bootstrap
```
After it starts, it will print its multiaddress. **Copy the full multiaddress** it prints to the console.


### Step 3: Configure and Start the Compute Provider (Optional)


In your code editor, open `src/nodes/compute-provider.ts`, `src/nodes/user-client.ts`, and `src/nodes/agent-thermostat-node.ts`. **Paste the multiaddress you copied** from the bootstrap node into the `BOOTSTRAP_ADDR` constant in all three files.


Now, in **Terminal 2**, run:
```bash
npm run start:provider
```
This peer will start, connect to the bootstrap node, benchmark itself, and then wait to accept compute jobs.


### Step 4: Run the User Client (Optional)


This peer will simulate a user offloading a computational task.


In **Terminal 3**, run:
```bash
npm run start:client
```
This client will:
1.  Start and connect to the network.
2.  Load and instrument the `optimized.wasm` file from disk.
3.  Mint a payment token (`GLOBAL` level event).
4.  Broadcast a `COMPUTE_REQUEST` (`GROUP` level event), sending the secure, metered WASM binary in the payload.
5.  Observe the network for `RECTIFICATION_PROOF` events, which are part of CAR.


### Step 5: Run the Smart Thermostat Agent Node (NEW)


This peer will simulate an autonomous agent reacting to sensor data and issuing commands.


In **Terminal 4** (or Terminal 3 if skipping the user client), run:
```bash
npm run start:agent
```
This agent node will:
1.  Start and connect to the network.
2.  Load its `agent_thermostat.wasm` binary.
3.  Broadcast a `SET_AGENT_POLICY` event (`GLOBAL` level) to define its desired temperature.
4.  Periodically simulate `SENSOR_READING` events (`LOCAL` level) and broadcast them.
5.  Based on its internal WASM logic (referencing conceptual semantic understanding from the ULMPKG), it will autonomously decide if an `HVAC_COMMAND` is needed.
6.  If a command is needed, it will broadcast the `HVAC_COMMAND` event (`PEER_TO_PEER` level) to the network. You will see this command logged by the agent itself.
7.  Participate in **Continuous Axiomatic Rectification (CAR)** by generating and verifying `RECTIFICATION_PROOF` events.


### Step 6: Observe the Universe


Watch the output in all terminals. You will see:
-   All nodes connect to the Bootstrap node.
-   The Client (if running) broadcasts `MINT_TOKEN` and `COMPUTE_REQUEST` events, which the Provider processes.
-   The Agent broadcasts its `SET_AGENT_POLICY` and then continuous `SENSOR_READING` events.
-   Crucially, you will observe **`RECTIFICATION_PROOF`** events being generated and processed by peers, demonstrating the **Continuous Axiomatic Rectification (CAR)** mechanism at work, ensuring the continuous coherence of the ledger.
-   The Agent's internal logic will autonomously determine when to broadcast `HVAC_COMMAND` events based on the simulated temperature readings and its set policy, demonstrating a CUE-native autonomous RPC.


This demonstrates a complete, end-to-end economic, agentic, and self-verifying interaction in a decentralized, secure, and persistent CUE network governed by a multi-level consensus model and continuous axiomatic rectification.
